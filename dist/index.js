"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod4) => function __require() {
  return mod4 || (0, cb[__getOwnPropNames(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod4, isNodeMode, target) => (target = mod4 != null ? __create(__getProtoOf(mod4)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod4 || !mod4.__esModule ? __defProp(target, "default", { value: mod4, enumerable: true }) : target,
  mod4
));
var __toCommonJS = (mod4) => __copyProps(__defProp({}, "__esModule", { value: true }), mod4);

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/utils.js
var require_utils = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/utils.js"(exports) {
    "use strict";
    exports.bigInt2BytesLE = function bigInt2BytesLE(_a, len) {
      const b = Array(len);
      let v = BigInt(_a);
      for (let i = 0; i < len; i++) {
        b[i] = Number(v & 0xFFn);
        v = v >> 8n;
      }
      return b;
    };
    exports.bigInt2U32LE = function bigInt2BytesLE(_a, len) {
      const b = Array(len);
      let v = BigInt(_a);
      for (let i = 0; i < len; i++) {
        b[i] = Number(v & 0xFFFFFFFFn);
        v = v >> 32n;
      }
      return b;
    };
    exports.isOcamNum = function(a) {
      if (!Array.isArray(a))
        return false;
      if (a.length != 3)
        return false;
      if (typeof a[0] !== "number")
        return false;
      if (typeof a[1] !== "number")
        return false;
      if (!Array.isArray(a[2]))
        return false;
      return true;
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_int.js
var require_build_int = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_int.js"(exports, module2) {
    "use strict";
    module2.exports = function buildInt(module3, n64, _prefix) {
      const prefix = _prefix || "int";
      if (module3.modules[prefix])
        return prefix;
      module3.modules[prefix] = {};
      const n32 = n64 * 2;
      const n8 = n64 * 8;
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("px", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pr"),
              i * 8,
              c.i64_load(
                c.getLocal("px"),
                i * 8
              )
            )
          );
        }
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pr"),
              i * 8,
              c.i64_const(0)
            )
          );
        }
      }
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.i64_store(
            c.getLocal("pr"),
            0,
            c.i64_const(1)
          )
        );
        for (let i = 1; i < n64; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pr"),
              i * 8,
              c.i64_const(0)
            )
          );
        }
      }
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("px", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c.ret(c.i64_eqz(
              c.i64_load(c.getLocal("px"))
            ));
          }
          return c.if(
            c.i64_eqz(
              c.i64_load(c.getLocal("px"), n * 8)
            ),
            getCompCode(n - 1),
            c.ret(c.i32_const(0))
          );
        }
        f.addCode(getCompCode(n64 - 1));
        f.addCode(c.ret(c.i32_const(0)));
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("px", "i32");
        f.addParam("py", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c.ret(c.i64_eq(
              c.i64_load(c.getLocal("px")),
              c.i64_load(c.getLocal("py"))
            ));
          }
          return c.if(
            c.i64_eq(
              c.i64_load(c.getLocal("px"), n * 8),
              c.i64_load(c.getLocal("py"), n * 8)
            ),
            getCompCode(n - 1),
            c.ret(c.i32_const(0))
          );
        }
        f.addCode(getCompCode(n64 - 1));
        f.addCode(c.ret(c.i32_const(0)));
      }
      function buildGte() {
        const f = module3.addFunction(prefix + "_gte");
        f.addParam("px", "i32");
        f.addParam("py", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c.ret(c.i64_ge_u(
              c.i64_load(c.getLocal("px")),
              c.i64_load(c.getLocal("py"))
            ));
          }
          return c.if(
            c.i64_lt_u(
              c.i64_load(c.getLocal("px"), n * 8),
              c.i64_load(c.getLocal("py"), n * 8)
            ),
            c.ret(c.i32_const(0)),
            c.if(
              c.i64_gt_u(
                c.i64_load(c.getLocal("px"), n * 8),
                c.i64_load(c.getLocal("py"), n * 8)
              ),
              c.ret(c.i32_const(1)),
              getCompCode(n - 1)
            )
          );
        }
        f.addCode(getCompCode(n64 - 1));
        f.addCode(c.ret(c.i32_const(0)));
      }
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.setReturnType("i32");
        f.addLocal("c", "i64");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal(
          "c",
          c.i64_add(
            c.i64_load32_u(c.getLocal("x")),
            c.i64_load32_u(c.getLocal("y"))
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("r"),
          c.getLocal("c")
        ));
        for (let i = 1; i < n32; i++) {
          f.addCode(c.setLocal(
            "c",
            c.i64_add(
              c.i64_add(
                c.i64_load32_u(c.getLocal("x"), 4 * i),
                c.i64_load32_u(c.getLocal("y"), 4 * i)
              ),
              c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
            )
          ));
          f.addCode(c.i64_store32(
            c.getLocal("r"),
            i * 4,
            c.getLocal("c")
          ));
        }
        f.addCode(c.i32_wrap_i64(c.i64_shr_u(c.getLocal("c"), c.i64_const(32))));
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.setReturnType("i32");
        f.addLocal("c", "i64");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal(
          "c",
          c.i64_sub(
            c.i64_load32_u(c.getLocal("x")),
            c.i64_load32_u(c.getLocal("y"))
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("r"),
          c.i64_and(
            c.getLocal("c"),
            c.i64_const("0xFFFFFFFF")
          )
        ));
        for (let i = 1; i < n32; i++) {
          f.addCode(c.setLocal(
            "c",
            c.i64_add(
              c.i64_sub(
                c.i64_load32_u(c.getLocal("x"), 4 * i),
                c.i64_load32_u(c.getLocal("y"), 4 * i)
              ),
              c.i64_shr_s(c.getLocal("c"), c.i64_const(32))
            )
          ));
          f.addCode(c.i64_store32(
            c.getLocal("r"),
            i * 4,
            c.i64_and(c.getLocal("c"), c.i64_const("0xFFFFFFFF"))
          ));
        }
        f.addCode(c.i32_wrap_i64(c.i64_shr_s(c.getLocal("c"), c.i64_const(32))));
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
          f.addLocal("y" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const loadX = [];
        const loadY = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadY[j]) {
            Y = c.teeLocal("y" + j, c.i64_load32_u(c.getLocal("y"), j * 4));
            loadY[j] = true;
          } else {
            Y = c.getLocal("y" + j);
          }
          return c.i64_mul(X, Y);
        }
        let c0 = "c0";
        let c1 = "c1";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          for (let i = Math.max(0, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          f.addCode(
            c.i64_store32(
              c.getLocal("r"),
              k * 4,
              c.getLocal(c0)
            )
          );
          [c0, c1] = [c1, c0];
          f.addCode(
            c.setLocal(
              c1,
              c.i64_shr_u(
                c.getLocal(c0),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 * 2 - 4,
            c.getLocal(c0)
          )
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        f.addLocal("c0_old", "i64");
        f.addLocal("c1_old", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const loadX = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadX[j]) {
            Y = c.teeLocal("x" + j, c.i64_load32_u(c.getLocal("x"), j * 4));
            loadX[j] = true;
          } else {
            Y = c.getLocal("x" + j);
          }
          return c.i64_mul(X, Y);
        }
        let c0 = "c0";
        let c1 = "c1";
        let c0_old = "c0_old";
        let c1_old = "c1_old";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          f.addCode(
            c.setLocal(c0, c.i64_const(0)),
            c.setLocal(c1, c.i64_const(0))
          );
          for (let i = Math.max(0, k - n32 + 1); i < k + 1 >> 1 && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          f.addCode(
            c.setLocal(
              c0,
              c.i64_shl(
                c.i64_and(
                  c.getLocal(c0),
                  c.i64_const(4294967295)
                ),
                c.i64_const(1)
              )
            )
          );
          f.addCode(
            c.setLocal(
              c1,
              c.i64_add(
                c.i64_shl(
                  c.getLocal(c1),
                  c.i64_const(1)
                ),
                c.i64_shr_u(
                  c.getLocal(c0),
                  c.i64_const(32)
                )
              )
            )
          );
          if (k % 2 == 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(k >> 1, k >> 1)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k > 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  c.i64_and(
                    c.getLocal(c0_old),
                    c.i64_const(4294967295)
                  )
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.i64_add(
                    c.getLocal(c1),
                    c.i64_shr_u(
                      c.getLocal(c0),
                      c.i64_const(32)
                    )
                  ),
                  c.getLocal(c1_old)
                )
              )
            );
          }
          f.addCode(
            c.i64_store32(
              c.getLocal("r"),
              k * 4,
              c.getLocal(c0)
            )
          );
          f.addCode(
            c.setLocal(
              c0_old,
              c.getLocal(c1)
            ),
            c.setLocal(
              c1_old,
              c.i64_shr_u(
                c.getLocal(c0_old),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 * 2 - 4,
            c.getLocal(c0_old)
          )
        );
      }
      function buildSquareOld() {
        const f = module3.addFunction(prefix + "_squareOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.getLocal("x"), c.getLocal("r")));
      }
      function _buildMul1() {
        const f = module3.addFunction(prefix + "__mul1");
        f.addParam("px", "i32");
        f.addParam("y", "i64");
        f.addParam("pr", "i32");
        f.addLocal("c", "i64");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal(
          "c",
          c.i64_mul(
            c.i64_load32_u(c.getLocal("px"), 0, 0),
            c.getLocal("y")
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("pr"),
          0,
          0,
          c.getLocal("c")
        ));
        for (let i = 1; i < n32; i++) {
          f.addCode(c.setLocal(
            "c",
            c.i64_add(
              c.i64_mul(
                c.i64_load32_u(c.getLocal("px"), 4 * i, 0),
                c.getLocal("y")
              ),
              c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
            )
          ));
          f.addCode(c.i64_store32(
            c.getLocal("pr"),
            i * 4,
            0,
            c.getLocal("c")
          ));
        }
      }
      function _buildAdd1() {
        const f = module3.addFunction(prefix + "__add1");
        f.addParam("x", "i32");
        f.addParam("y", "i64");
        f.addLocal("c", "i64");
        f.addLocal("px", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal("px", c.getLocal("x")));
        f.addCode(c.setLocal(
          "c",
          c.i64_add(
            c.i64_load32_u(c.getLocal("px"), 0, 0),
            c.getLocal("y")
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("px"),
          0,
          0,
          c.getLocal("c")
        ));
        f.addCode(c.setLocal(
          "c",
          c.i64_shr_u(
            c.getLocal("c"),
            c.i64_const(32)
          )
        ));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.i64_eqz(c.getLocal("c"))
          ),
          c.setLocal(
            "px",
            c.i32_add(
              c.getLocal("px"),
              c.i32_const(4)
            )
          ),
          c.setLocal(
            "c",
            c.i64_add(
              c.i64_load32_u(c.getLocal("px"), 0, 0),
              c.getLocal("c")
            )
          ),
          c.i64_store32(
            c.getLocal("px"),
            0,
            0,
            c.getLocal("c")
          ),
          c.setLocal(
            "c",
            c.i64_shr_u(
              c.getLocal("c"),
              c.i64_const(32)
            )
          ),
          c.br(0)
        )));
      }
      function buildDiv() {
        _buildMul1();
        _buildAdd1();
        const f = module3.addFunction(prefix + "_div");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("c", "i32");
        f.addParam("r", "i32");
        f.addLocal("rr", "i32");
        f.addLocal("cc", "i32");
        f.addLocal("eX", "i32");
        f.addLocal("eY", "i32");
        f.addLocal("sy", "i64");
        f.addLocal("sx", "i64");
        f.addLocal("ec", "i32");
        const c = f.getCodeBuilder();
        const Y = c.i32_const(module3.alloc(n8));
        const Caux = c.i32_const(module3.alloc(n8));
        const Raux = c.i32_const(module3.alloc(n8));
        const C = c.getLocal("cc");
        const R = c.getLocal("rr");
        const pr1 = module3.alloc(n8 * 2);
        const R1 = c.i32_const(pr1);
        const R2 = c.i32_const(pr1 + n8);
        f.addCode(c.if(
          c.getLocal("c"),
          c.setLocal("cc", c.getLocal("c")),
          c.setLocal("cc", Caux)
        ));
        f.addCode(c.if(
          c.getLocal("r"),
          c.setLocal("rr", c.getLocal("r")),
          c.setLocal("rr", Raux)
        ));
        f.addCode(c.call(prefix + "_copy", c.getLocal("x"), R));
        f.addCode(c.call(prefix + "_copy", c.getLocal("y"), Y));
        f.addCode(c.call(prefix + "_zero", C));
        f.addCode(c.call(prefix + "_zero", R1));
        f.addCode(c.setLocal("eX", c.i32_const(n8 - 1)));
        f.addCode(c.setLocal("eY", c.i32_const(n8 - 1)));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.i32_or(
              c.i32_load8_u(
                c.i32_add(Y, c.getLocal("eY")),
                0,
                0
              ),
              c.i32_eq(
                c.getLocal("eY"),
                c.i32_const(3)
              )
            )
          ),
          c.setLocal("eY", c.i32_sub(c.getLocal("eY"), c.i32_const(1))),
          c.br(0)
        )));
        f.addCode(
          c.setLocal(
            "sy",
            c.i64_add(
              c.i64_load32_u(
                c.i32_sub(
                  c.i32_add(Y, c.getLocal("eY")),
                  c.i32_const(3)
                ),
                0,
                0
              ),
              c.i64_const(1)
            )
          )
        );
        f.addCode(
          c.if(
            c.i64_eq(
              c.getLocal("sy"),
              c.i64_const(1)
            ),
            c.drop(c.i64_div_u(c.i64_const(0), c.i64_const(0)))
          )
        );
        f.addCode(c.block(c.loop(
          // while (eX>7)&&(Y[eX]==0) ex--;
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_or(
                c.i32_load8_u(
                  c.i32_add(R, c.getLocal("eX")),
                  0,
                  0
                ),
                c.i32_eq(
                  c.getLocal("eX"),
                  c.i32_const(7)
                )
              )
            ),
            c.setLocal("eX", c.i32_sub(c.getLocal("eX"), c.i32_const(1))),
            c.br(0)
          )),
          c.setLocal(
            "sx",
            c.i64_load(
              c.i32_sub(
                c.i32_add(R, c.getLocal("eX")),
                c.i32_const(7)
              ),
              0,
              0
            )
          ),
          c.setLocal(
            "sx",
            c.i64_div_u(
              c.getLocal("sx"),
              c.getLocal("sy")
            )
          ),
          c.setLocal(
            "ec",
            c.i32_sub(
              c.i32_sub(
                c.getLocal("eX"),
                c.getLocal("eY")
              ),
              c.i32_const(4)
            )
          ),
          // While greater than 32 bits or ec is neg, shr and inc exp
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_and(
                c.i64_eqz(
                  c.i64_and(
                    c.getLocal("sx"),
                    c.i64_const("0xFFFFFFFF00000000")
                  )
                ),
                c.i32_ge_s(
                  c.getLocal("ec"),
                  c.i32_const(0)
                )
              )
            ),
            c.setLocal(
              "sx",
              c.i64_shr_u(
                c.getLocal("sx"),
                c.i64_const(8)
              )
            ),
            c.setLocal(
              "ec",
              c.i32_add(
                c.getLocal("ec"),
                c.i32_const(1)
              )
            ),
            c.br(0)
          )),
          c.if(
            c.i64_eqz(c.getLocal("sx")),
            [
              ...c.br_if(
                2,
                c.i32_eqz(c.call(prefix + "_gte", R, Y))
              ),
              ...c.setLocal("sx", c.i64_const(1)),
              ...c.setLocal("ec", c.i32_const(0))
            ]
          ),
          c.call(prefix + "__mul1", Y, c.getLocal("sx"), R2),
          c.drop(c.call(
            prefix + "_sub",
            R,
            c.i32_sub(R2, c.getLocal("ec")),
            R
          )),
          c.call(
            prefix + "__add1",
            c.i32_add(C, c.getLocal("ec")),
            c.getLocal("sx")
          ),
          c.br(0)
        )));
      }
      function buildInverseMod() {
        const f = module3.addFunction(prefix + "_inverseMod");
        f.addParam("px", "i32");
        f.addParam("pm", "i32");
        f.addParam("pr", "i32");
        f.addLocal("t", "i32");
        f.addLocal("newt", "i32");
        f.addLocal("r", "i32");
        f.addLocal("qq", "i32");
        f.addLocal("qr", "i32");
        f.addLocal("newr", "i32");
        f.addLocal("swp", "i32");
        f.addLocal("x", "i32");
        f.addLocal("signt", "i32");
        f.addLocal("signnewt", "i32");
        f.addLocal("signx", "i32");
        const c = f.getCodeBuilder();
        const aux1 = c.i32_const(module3.alloc(n8));
        const aux2 = c.i32_const(module3.alloc(n8));
        const aux3 = c.i32_const(module3.alloc(n8));
        const aux4 = c.i32_const(module3.alloc(n8));
        const aux5 = c.i32_const(module3.alloc(n8));
        const aux6 = c.i32_const(module3.alloc(n8));
        const mulBuff = c.i32_const(module3.alloc(n8 * 2));
        const aux7 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("t", aux1),
          c.call(prefix + "_zero", aux1),
          c.setLocal("signt", c.i32_const(0))
        );
        f.addCode(
          c.setLocal("r", aux2),
          c.call(prefix + "_copy", c.getLocal("pm"), aux2)
        );
        f.addCode(
          c.setLocal("newt", aux3),
          c.call(prefix + "_one", aux3),
          c.setLocal("signnewt", c.i32_const(0))
        );
        f.addCode(
          c.setLocal("newr", aux4),
          c.call(prefix + "_copy", c.getLocal("px"), aux4)
        );
        f.addCode(c.setLocal("qq", aux5));
        f.addCode(c.setLocal("qr", aux6));
        f.addCode(c.setLocal("x", aux7));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.call(prefix + "_isZero", c.getLocal("newr"))
          ),
          c.call(prefix + "_div", c.getLocal("r"), c.getLocal("newr"), c.getLocal("qq"), c.getLocal("qr")),
          c.call(prefix + "_mul", c.getLocal("qq"), c.getLocal("newt"), mulBuff),
          c.if(
            c.getLocal("signt"),
            c.if(
              c.getLocal("signnewt"),
              c.if(
                c.call(prefix + "_gte", mulBuff, c.getLocal("t")),
                [
                  ...c.drop(c.call(prefix + "_sub", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(0))
                ],
                [
                  ...c.drop(c.call(prefix + "_sub", c.getLocal("t"), mulBuff, c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(1))
                ]
              ),
              [
                ...c.drop(c.call(prefix + "_add", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                ...c.setLocal("signx", c.i32_const(1))
              ]
            ),
            c.if(
              c.getLocal("signnewt"),
              [
                ...c.drop(c.call(prefix + "_add", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                ...c.setLocal("signx", c.i32_const(0))
              ],
              c.if(
                c.call(prefix + "_gte", c.getLocal("t"), mulBuff),
                [
                  ...c.drop(c.call(prefix + "_sub", c.getLocal("t"), mulBuff, c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(0))
                ],
                [
                  ...c.drop(c.call(prefix + "_sub", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(1))
                ]
              )
            )
          ),
          c.setLocal("swp", c.getLocal("t")),
          c.setLocal("t", c.getLocal("newt")),
          c.setLocal("newt", c.getLocal("x")),
          c.setLocal("x", c.getLocal("swp")),
          c.setLocal("signt", c.getLocal("signnewt")),
          c.setLocal("signnewt", c.getLocal("signx")),
          c.setLocal("swp", c.getLocal("r")),
          c.setLocal("r", c.getLocal("newr")),
          c.setLocal("newr", c.getLocal("qr")),
          c.setLocal("qr", c.getLocal("swp")),
          c.br(0)
        )));
        f.addCode(c.if(
          c.getLocal("signt"),
          c.drop(c.call(prefix + "_sub", c.getLocal("pm"), c.getLocal("t"), c.getLocal("pr"))),
          c.call(prefix + "_copy", c.getLocal("t"), c.getLocal("pr"))
        ));
      }
      buildCopy();
      buildZero();
      buildIsZero();
      buildOne();
      buildEq();
      buildGte();
      buildAdd();
      buildSub();
      buildMul();
      buildSquare();
      buildSquareOld();
      buildDiv();
      buildInverseMod();
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_gte");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_squareOld");
      module3.exportFunction(prefix + "_div");
      module3.exportFunction(prefix + "_inverseMod");
      return prefix;
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_timesscalar.js
var require_build_timesscalar = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_timesscalar.js"(exports, module2) {
    "use strict";
    module2.exports = function buildTimesScalar(module3, fnName, elementLen, opAB, opAA, opCopy, opInit) {
      const f = module3.addFunction(fnName);
      f.addParam("base", "i32");
      f.addParam("scalar", "i32");
      f.addParam("scalarLength", "i32");
      f.addParam("r", "i32");
      f.addLocal("i", "i32");
      f.addLocal("b", "i32");
      const c = f.getCodeBuilder();
      const aux = c.i32_const(module3.alloc(elementLen));
      f.addCode(
        c.if(
          c.i32_eqz(c.getLocal("scalarLength")),
          [
            ...c.call(opInit, c.getLocal("r")),
            ...c.ret([])
          ]
        )
      );
      f.addCode(c.call(opCopy, c.getLocal("base"), aux));
      f.addCode(c.call(opInit, c.getLocal("r")));
      f.addCode(c.setLocal("i", c.getLocal("scalarLength")));
      f.addCode(c.block(c.loop(
        c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
        c.setLocal(
          "b",
          c.i32_load8_u(
            c.i32_add(
              c.getLocal("scalar"),
              c.getLocal("i")
            )
          )
        ),
        ...innerLoop(),
        c.br_if(1, c.i32_eqz(c.getLocal("i"))),
        c.br(0)
      )));
      function innerLoop() {
        const code = [];
        for (let i = 0; i < 8; i++) {
          code.push(
            ...c.call(opAA, c.getLocal("r"), c.getLocal("r")),
            ...c.if(
              c.i32_ge_u(c.getLocal("b"), c.i32_const(128 >> i)),
              [
                ...c.setLocal(
                  "b",
                  c.i32_sub(
                    c.getLocal("b"),
                    c.i32_const(128 >> i)
                  )
                ),
                ...c.call(opAB, c.getLocal("r"), aux, c.getLocal("r"))
              ]
            )
          );
        }
        return code;
      }
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_batchinverse.js
var require_build_batchinverse = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_batchinverse.js"(exports, module2) {
    "use strict";
    module2.exports = buildBatchInverse;
    function buildBatchInverse(module3, prefix) {
      const n8 = module3.modules[prefix].n64 * 8;
      const f = module3.addFunction(prefix + "_batchInverse");
      f.addParam("pIn", "i32");
      f.addParam("inStep", "i32");
      f.addParam("n", "i32");
      f.addParam("pOut", "i32");
      f.addParam("outStep", "i32");
      f.addLocal("itAux", "i32");
      f.addLocal("itIn", "i32");
      f.addLocal("itOut", "i32");
      f.addLocal("i", "i32");
      const c = f.getCodeBuilder();
      const AUX = c.i32_const(module3.alloc(n8));
      f.addCode(
        c.setLocal("itAux", c.i32_load(c.i32_const(0))),
        c.i32_store(
          c.i32_const(0),
          c.i32_add(
            c.getLocal("itAux"),
            c.i32_mul(
              c.i32_add(
                c.getLocal("n"),
                c.i32_const(1)
              ),
              c.i32_const(n8)
            )
          )
        )
      );
      f.addCode(
        // aux[0] = a;
        c.call(prefix + "_one", c.getLocal("itAux")),
        // for (i=0;i<n;i++) aux[i] = aux[i-1]*in[i]
        c.setLocal("itIn", c.getLocal("pIn")),
        c.setLocal("itAux", c.i32_add(c.getLocal("itAux"), c.i32_const(n8))),
        c.setLocal("i", c.i32_const(0)),
        c.block(c.loop(
          c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("itIn")),
            c.call(
              prefix + "_copy",
              c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)),
              c.getLocal("itAux")
            ),
            c.call(
              prefix + "_mul",
              c.getLocal("itIn"),
              c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)),
              c.getLocal("itAux")
            )
          ),
          c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.getLocal("inStep"))),
          c.setLocal("itAux", c.i32_add(c.getLocal("itAux"), c.i32_const(n8))),
          c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        )),
        // point to the last
        c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.getLocal("inStep"))),
        c.setLocal("itAux", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))),
        // itOut = pOut + (n-1)*stepOut   // Point to the last
        c.setLocal(
          "itOut",
          c.i32_add(
            c.getLocal("pOut"),
            c.i32_mul(
              c.i32_sub(c.getLocal("n"), c.i32_const(1)),
              c.getLocal("outStep")
            )
          )
        ),
        // aux[n-1] = 1/aux[n-1]
        c.call(prefix + "_inverse", c.getLocal("itAux"), c.getLocal("itAux")),
        c.block(c.loop(
          c.br_if(1, c.i32_eqz(c.getLocal("i"))),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("itIn")),
            [
              ...c.call(
                prefix + "_copy",
                c.getLocal("itAux"),
                c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))
              ),
              ...c.call(
                prefix + "_zero",
                c.getLocal("itOut")
              )
            ],
            [
              ...c.call(prefix + "_copy", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)), AUX),
              ...c.call(
                prefix + "_mul",
                c.getLocal("itAux"),
                c.getLocal("itIn"),
                c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))
              ),
              ...c.call(
                prefix + "_mul",
                c.getLocal("itAux"),
                AUX,
                c.getLocal("itOut")
              )
            ]
          ),
          c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.getLocal("inStep"))),
          c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.getLocal("outStep"))),
          c.setLocal("itAux", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))),
          c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        ))
      );
      f.addCode(
        c.i32_store(
          c.i32_const(0),
          c.getLocal("itAux")
        )
      );
    }
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_batchconvertion.js
var require_build_batchconvertion = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_batchconvertion.js"(exports, module2) {
    "use strict";
    module2.exports = buildBatchConvertion;
    function buildBatchConvertion(module3, fnName, internalFnName, sizeIn, sizeOut, reverse) {
      if (typeof reverse === "undefined") {
        if (sizeIn < sizeOut) {
          reverse = true;
        } else {
          reverse = false;
        }
      }
      const f = module3.addFunction(fnName);
      f.addParam("pIn", "i32");
      f.addParam("n", "i32");
      f.addParam("pOut", "i32");
      f.addLocal("i", "i32");
      f.addLocal("itIn", "i32");
      f.addLocal("itOut", "i32");
      const c = f.getCodeBuilder();
      if (reverse) {
        f.addCode(
          c.setLocal(
            "itIn",
            c.i32_add(
              c.getLocal("pIn"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeIn)
              )
            )
          ),
          c.setLocal(
            "itOut",
            c.i32_add(
              c.getLocal("pOut"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeOut)
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn"), c.getLocal("itOut")),
            c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      } else {
        f.addCode(
          c.setLocal("itIn", c.getLocal("pIn")),
          c.setLocal("itOut", c.getLocal("pOut")),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn"), c.getLocal("itOut")),
            c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_add(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
    }
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_batchop.js
var require_build_batchop = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_batchop.js"(exports, module2) {
    "use strict";
    module2.exports = buildBatchConvertion;
    function buildBatchConvertion(module3, fnName, internalFnName, sizeIn, sizeOut, reverse) {
      if (typeof reverse === "undefined") {
        if (sizeIn < sizeOut) {
          reverse = true;
        } else {
          reverse = false;
        }
      }
      const f = module3.addFunction(fnName);
      f.addParam("pIn1", "i32");
      f.addParam("pIn2", "i32");
      f.addParam("n", "i32");
      f.addParam("pOut", "i32");
      f.addLocal("i", "i32");
      f.addLocal("itIn1", "i32");
      f.addLocal("itIn2", "i32");
      f.addLocal("itOut", "i32");
      const c = f.getCodeBuilder();
      if (reverse) {
        f.addCode(
          c.setLocal(
            "itIn1",
            c.i32_add(
              c.getLocal("pIn1"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeIn)
              )
            )
          ),
          c.setLocal(
            "itIn2",
            c.i32_add(
              c.getLocal("pIn2"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeIn)
              )
            )
          ),
          c.setLocal(
            "itOut",
            c.i32_add(
              c.getLocal("pOut"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeOut)
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn1"), c.getLocal("itIn2"), c.getLocal("itOut")),
            c.setLocal("itIn1", c.i32_sub(c.getLocal("itIn1"), c.i32_const(sizeIn))),
            c.setLocal("itIn2", c.i32_sub(c.getLocal("itIn2"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      } else {
        f.addCode(
          c.setLocal("itIn1", c.getLocal("pIn1")),
          c.setLocal("itIn2", c.getLocal("pIn2")),
          c.setLocal("itOut", c.getLocal("pOut")),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn1"), c.getLocal("itIn2"), c.getLocal("itOut")),
            c.setLocal("itIn1", c.i32_add(c.getLocal("itIn1"), c.i32_const(sizeIn))),
            c.setLocal("itIn2", c.i32_add(c.getLocal("itIn2"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_add(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
    }
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/bigint.js
var require_bigint = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/bigint.js"(exports, module2) {
    "use strict";
    function compare(a, b) {
      return a === b ? 0 : a > b ? 1 : -1;
    }
    function square4(n) {
      return n * n;
    }
    function isOdd4(n) {
      return n % 2n !== 0n;
    }
    function isEven(n) {
      return n % 2n === 0n;
    }
    function isNegative5(n) {
      return n < 0n;
    }
    function isPositive(n) {
      return n > 0n;
    }
    function bitLength5(n) {
      if (isNegative5(n)) {
        return n.toString(2).length - 1;
      } else {
        return n.toString(2).length;
      }
    }
    function abs4(n) {
      return n < 0n ? -n : n;
    }
    function isUnit(n) {
      return abs4(n) === 1n;
    }
    function modInv(a, n) {
      var t = 0n, newT = 1n, r = n, newR = abs4(a), q, lastT, lastR;
      while (newR !== 0n) {
        q = r / newR;
        lastT = t;
        lastR = r;
        t = newT;
        r = newR;
        newT = lastT - q * newT;
        newR = lastR - q * newR;
      }
      if (!isUnit(r))
        throw new Error(a.toString() + " and " + n.toString() + " are not co-prime");
      if (compare(t, 0n) === -1) {
        t = t + n;
      }
      if (isNegative5(a)) {
        return -t;
      }
      return t;
    }
    function modPow(n, exp7, mod4) {
      if (mod4 === 0n)
        throw new Error("Cannot take modPow with modulus 0");
      var r = 1n, base = n % mod4;
      if (isNegative5(exp7)) {
        exp7 = exp7 * -1n;
        base = modInv(base, mod4);
      }
      while (isPositive(exp7)) {
        if (base === 0n)
          return 0n;
        if (isOdd4(exp7))
          r = r * base % mod4;
        exp7 = exp7 / 2n;
        base = square4(base) % mod4;
      }
      return r;
    }
    function compareAbs(a, b) {
      a = a >= 0n ? a : -a;
      b = b >= 0n ? b : -b;
      return a === b ? 0 : a > b ? 1 : -1;
    }
    function isDivisibleBy(a, n) {
      if (n === 0n)
        return false;
      if (isUnit(n))
        return true;
      if (compareAbs(n, 2n) === 0)
        return isEven(a);
      return a % n === 0n;
    }
    function isBasicPrime(v) {
      var n = abs4(v);
      if (isUnit(n))
        return false;
      if (n === 2n || n === 3n || n === 5n)
        return true;
      if (isEven(n) || isDivisibleBy(n, 3n) || isDivisibleBy(n, 5n))
        return false;
      if (n < 49n)
        return true;
    }
    function prev(n) {
      return n - 1n;
    }
    function millerRabinTest(n, a) {
      var nPrev = prev(n), b = nPrev, r = 0, d, i, x;
      while (isEven(b))
        b = b / 2n, r++;
      next:
        for (i = 0; i < a.length; i++) {
          if (n < a[i])
            continue;
          x = modPow(BigInt(a[i]), b, n);
          if (isUnit(x) || x === nPrev)
            continue;
          for (d = r - 1; d != 0; d--) {
            x = square4(x) % n;
            if (isUnit(x))
              return false;
            if (x === nPrev)
              continue next;
          }
          return false;
        }
      return true;
    }
    function isPrime(p) {
      var isPrime2 = isBasicPrime(p);
      if (isPrime2 !== void 0)
        return isPrime2;
      var n = abs4(p);
      var bits4 = bitLength5(n);
      if (bits4 <= 64)
        return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
      var logN = Math.log(2) * Number(bits4);
      var t = Math.ceil(logN);
      for (var a = [], i = 0; i < t; i++) {
        a.push(BigInt(i + 2));
      }
      return millerRabinTest(n, a);
    }
    module2.exports.bitLength = bitLength5;
    module2.exports.isOdd = isOdd4;
    module2.exports.isNegative = isNegative5;
    module2.exports.abs = abs4;
    module2.exports.isUnit = isUnit;
    module2.exports.compare = compare;
    module2.exports.modInv = modInv;
    module2.exports.modPow = modPow;
    module2.exports.isPrime = isPrime;
    module2.exports.square = square4;
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_f1m.js
var require_build_f1m = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_f1m.js"(exports, module2) {
    "use strict";
    var buildInt = require_build_int();
    var utils2 = require_utils();
    var buildExp = require_build_timesscalar();
    var buildBatchInverse = require_build_batchinverse();
    var buildBatchConvertion = require_build_batchconvertion();
    var buildBatchOp = require_build_batchop();
    var { bitLength: bitLength5, modInv, modPow, isPrime, isOdd: isOdd4, square: square4 } = require_bigint();
    module2.exports = function buildF1m(module3, _q, _prefix, _intPrefix) {
      const q = BigInt(_q);
      const n64 = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n32 = n64 * 2;
      const n8 = n64 * 8;
      const prefix = _prefix || "f1m";
      if (module3.modules[prefix])
        return prefix;
      const intPrefix = buildInt(module3, n64, _intPrefix);
      const pq = module3.alloc(n8, utils2.bigInt2BytesLE(q, n8));
      const pR2 = module3.alloc(utils2.bigInt2BytesLE(square4(1n << BigInt(n64 * 64)) % q, n8));
      const pOne = module3.alloc(utils2.bigInt2BytesLE((1n << BigInt(n64 * 64)) % q, n8));
      const pZero = module3.alloc(utils2.bigInt2BytesLE(0n, n8));
      const _minusOne = q - 1n;
      const _e = _minusOne >> 1n;
      const pe = module3.alloc(n8, utils2.bigInt2BytesLE(_e, n8));
      const _ePlusOne = _e + 1n;
      const pePlusOne = module3.alloc(n8, utils2.bigInt2BytesLE(_ePlusOne, n8));
      module3.modules[prefix] = {
        pq,
        pR2,
        n64,
        q,
        pOne,
        pZero,
        pePlusOne
      };
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(intPrefix + "_copy", c.i32_const(pOne), c.getLocal("pr")));
      }
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.call(intPrefix + "_add", c.getLocal("x"), c.getLocal("y"), c.getLocal("r")),
            c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r"))),
            c.if(
              c.call(intPrefix + "_gte", c.getLocal("r"), c.i32_const(pq)),
              c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
            )
          )
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.call(intPrefix + "_sub", c.getLocal("x"), c.getLocal("y"), c.getLocal("r")),
            c.drop(c.call(intPrefix + "_add", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
          )
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(prefix + "_sub", c.i32_const(pZero), c.getLocal("x"), c.getLocal("r"))
        );
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call(prefix + "_fromMontgomery", c.getLocal("x"), AUX),
          c.call(intPrefix + "_gte", AUX, c.i32_const(pePlusOne))
        );
      }
      function buildSign() {
        const f = module3.addFunction(prefix + "_sign");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(intPrefix + "_isZero", c.getLocal("x")),
            c.ret(c.i32_const(0))
          ),
          c.call(prefix + "_fromMontgomery", c.getLocal("x"), AUX),
          c.if(
            c.call(intPrefix + "_gte", AUX, c.i32_const(pePlusOne)),
            c.ret(c.i32_const(-1))
          ),
          c.ret(c.i32_const(1))
        );
      }
      function buildMReduct() {
        const carries = module3.alloc(n32 * n32 * 8);
        const f = module3.addFunction(prefix + "_mReduct");
        f.addParam("t", "i32");
        f.addParam("r", "i32");
        f.addLocal("np32", "i64");
        f.addLocal("c", "i64");
        f.addLocal("m", "i64");
        const c = f.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f.addCode(c.setLocal("np32", c.i64_const(np32)));
        for (let i = 0; i < n32; i++) {
          f.addCode(c.setLocal("c", c.i64_const(0)));
          f.addCode(
            c.setLocal(
              "m",
              c.i64_and(
                c.i64_mul(
                  c.i64_load32_u(c.getLocal("t"), i * 4),
                  c.getLocal("np32")
                ),
                c.i64_const("0xFFFFFFFF")
              )
            )
          );
          for (let j = 0; j < n32; j++) {
            f.addCode(
              c.setLocal(
                "c",
                c.i64_add(
                  c.i64_add(
                    c.i64_load32_u(c.getLocal("t"), (i + j) * 4),
                    c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
                  ),
                  c.i64_mul(
                    c.i64_load32_u(c.i32_const(pq), j * 4),
                    c.getLocal("m")
                  )
                )
              )
            );
            f.addCode(
              c.i64_store32(
                c.getLocal("t"),
                (i + j) * 4,
                c.getLocal("c")
              )
            );
          }
          f.addCode(
            c.i64_store32(
              c.i32_const(carries),
              i * 4,
              c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
            )
          );
        }
        f.addCode(
          c.call(
            prefix + "_add",
            c.i32_const(carries),
            c.i32_add(
              c.getLocal("t"),
              c.i32_const(n32 * 4)
            ),
            c.getLocal("r")
          )
        );
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        f.addLocal("np32", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
          f.addLocal("y" + i, "i64");
          f.addLocal("m" + i, "i64");
          f.addLocal("q" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f.addCode(c.setLocal("np32", c.i64_const(np32)));
        const loadX = [];
        const loadY = [];
        const loadQ = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadY[j]) {
            Y = c.teeLocal("y" + j, c.i64_load32_u(c.getLocal("y"), j * 4));
            loadY[j] = true;
          } else {
            Y = c.getLocal("y" + j);
          }
          return c.i64_mul(X, Y);
        }
        function mulqm(i, j) {
          let Q, M;
          if (!loadQ[i]) {
            Q = c.teeLocal("q" + i, c.i64_load32_u(c.i32_const(0), pq + i * 4));
            loadQ[i] = true;
          } else {
            Q = c.getLocal("q" + i);
          }
          M = c.getLocal("m" + j);
          return c.i64_mul(Q, M);
        }
        let c0 = "c0";
        let c1 = "c1";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          for (let i = Math.max(0, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          for (let i = Math.max(1, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k < n32) {
            f.addCode(
              c.setLocal(
                "m" + k,
                c.i64_and(
                  c.i64_mul(
                    c.i64_and(
                      c.getLocal(c0),
                      c.i64_const(4294967295)
                    ),
                    c.getLocal("np32")
                  ),
                  c.i64_const("0xFFFFFFFF")
                )
              )
            );
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(0, k)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k >= n32) {
            f.addCode(
              c.i64_store32(
                c.getLocal("r"),
                (k - n32) * 4,
                c.getLocal(c0)
              )
            );
          }
          [c0, c1] = [c1, c0];
          f.addCode(
            c.setLocal(
              c1,
              c.i64_shr_u(
                c.getLocal(c0),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 - 4,
            c.getLocal(c0)
          )
        );
        f.addCode(
          c.if(
            c.i32_wrap_i64(c.getLocal(c1)),
            c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r"))),
            c.if(
              c.call(intPrefix + "_gte", c.getLocal("r"), c.i32_const(pq)),
              c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
            )
          )
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        f.addLocal("c0_old", "i64");
        f.addLocal("c1_old", "i64");
        f.addLocal("np32", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
          f.addLocal("m" + i, "i64");
          f.addLocal("q" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f.addCode(c.setLocal("np32", c.i64_const(np32)));
        const loadX = [];
        const loadQ = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadX[j]) {
            Y = c.teeLocal("x" + j, c.i64_load32_u(c.getLocal("x"), j * 4));
            loadX[j] = true;
          } else {
            Y = c.getLocal("x" + j);
          }
          return c.i64_mul(X, Y);
        }
        function mulqm(i, j) {
          let Q, M;
          if (!loadQ[i]) {
            Q = c.teeLocal("q" + i, c.i64_load32_u(c.i32_const(0), pq + i * 4));
            loadQ[i] = true;
          } else {
            Q = c.getLocal("q" + i);
          }
          M = c.getLocal("m" + j);
          return c.i64_mul(Q, M);
        }
        let c0 = "c0";
        let c1 = "c1";
        let c0_old = "c0_old";
        let c1_old = "c1_old";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          f.addCode(
            c.setLocal(c0, c.i64_const(0)),
            c.setLocal(c1, c.i64_const(0))
          );
          for (let i = Math.max(0, k - n32 + 1); i < k + 1 >> 1 && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          f.addCode(
            c.setLocal(
              c0,
              c.i64_shl(
                c.i64_and(
                  c.getLocal(c0),
                  c.i64_const(4294967295)
                ),
                c.i64_const(1)
              )
            )
          );
          f.addCode(
            c.setLocal(
              c1,
              c.i64_add(
                c.i64_shl(
                  c.getLocal(c1),
                  c.i64_const(1)
                ),
                c.i64_shr_u(
                  c.getLocal(c0),
                  c.i64_const(32)
                )
              )
            )
          );
          if (k % 2 == 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(k >> 1, k >> 1)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k > 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  c.i64_and(
                    c.getLocal(c0_old),
                    c.i64_const(4294967295)
                  )
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.i64_add(
                    c.getLocal(c1),
                    c.i64_shr_u(
                      c.getLocal(c0),
                      c.i64_const(32)
                    )
                  ),
                  c.getLocal(c1_old)
                )
              )
            );
          }
          for (let i = Math.max(1, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k < n32) {
            f.addCode(
              c.setLocal(
                "m" + k,
                c.i64_and(
                  c.i64_mul(
                    c.i64_and(
                      c.getLocal(c0),
                      c.i64_const(4294967295)
                    ),
                    c.getLocal("np32")
                  ),
                  c.i64_const("0xFFFFFFFF")
                )
              )
            );
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(0, k)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k >= n32) {
            f.addCode(
              c.i64_store32(
                c.getLocal("r"),
                (k - n32) * 4,
                c.getLocal(c0)
              )
            );
          }
          f.addCode(
            c.setLocal(
              c0_old,
              c.getLocal(c1)
            ),
            c.setLocal(
              c1_old,
              c.i64_shr_u(
                c.getLocal(c0_old),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 - 4,
            c.getLocal(c0_old)
          )
        );
        f.addCode(
          c.if(
            c.i32_wrap_i64(c.getLocal(c1_old)),
            c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r"))),
            c.if(
              c.call(intPrefix + "_gte", c.getLocal("r"), c.i32_const(pq)),
              c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
            )
          )
        );
      }
      function buildSquareOld() {
        const f = module3.addFunction(prefix + "_squareOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.getLocal("x"), c.getLocal("r")));
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.i32_const(pR2), c.getLocal("r")));
      }
      function buildFromMontgomery() {
        const pAux2 = module3.alloc(n8 * 2);
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(intPrefix + "_copy", c.getLocal("x"), c.i32_const(pAux2)));
        f.addCode(c.call(intPrefix + "_zero", c.i32_const(pAux2 + n8)));
        f.addCode(c.call(prefix + "_mReduct", c.i32_const(pAux2), c.getLocal("r")));
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_fromMontgomery", c.getLocal("x"), c.getLocal("r")));
        f.addCode(c.call(intPrefix + "_inverseMod", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")));
        f.addCode(c.call(prefix + "_toMontgomery", c.getLocal("r"), c.getLocal("r")));
      }
      let _nqr = 2n;
      if (isPrime(q)) {
        while (modPow(_nqr, _e, q) !== _minusOne)
          _nqr = _nqr + 1n;
      }
      let s2 = 0;
      let _t = _minusOne;
      while (!isOdd4(_t) && _t !== 0n) {
        s2++;
        _t = _t >> 1n;
      }
      const pt = module3.alloc(n8, utils2.bigInt2BytesLE(_t, n8));
      const _nqrToT = modPow(_nqr, _t, q);
      const pNqrToT = module3.alloc(utils2.bigInt2BytesLE((_nqrToT << BigInt(n64 * 64)) % q, n8));
      const _tPlusOneOver2 = _t + 1n >> 1n;
      const ptPlusOneOver2 = module3.alloc(n8, utils2.bigInt2BytesLE(_tPlusOneOver2, n8));
      function buildSqrt4() {
        const f = module3.addFunction(prefix + "_sqrt");
        f.addParam("n", "i32");
        f.addParam("r", "i32");
        f.addLocal("m", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        const c = f.getCodeBuilder();
        const ONE = c.i32_const(pOne);
        const C = c.i32_const(module3.alloc(n8));
        const T = c.i32_const(module3.alloc(n8));
        const R = c.i32_const(module3.alloc(n8));
        const SQ = c.i32_const(module3.alloc(n8));
        const B = c.i32_const(module3.alloc(n8));
        f.addCode(
          // If (n==0) return 0
          c.if(
            c.call(prefix + "_isZero", c.getLocal("n")),
            c.ret(
              c.call(prefix + "_zero", c.getLocal("r"))
            )
          ),
          c.setLocal("m", c.i32_const(s2)),
          c.call(prefix + "_copy", c.i32_const(pNqrToT), C),
          c.call(prefix + "_exp", c.getLocal("n"), c.i32_const(pt), c.i32_const(n8), T),
          c.call(prefix + "_exp", c.getLocal("n"), c.i32_const(ptPlusOneOver2), c.i32_const(n8), R),
          c.block(c.loop(
            c.br_if(1, c.call(prefix + "_eq", T, ONE)),
            c.call(prefix + "_square", T, SQ),
            c.setLocal("i", c.i32_const(1)),
            c.block(c.loop(
              c.br_if(1, c.call(prefix + "_eq", SQ, ONE)),
              c.call(prefix + "_square", SQ, SQ),
              c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
              c.br(0)
            )),
            c.call(prefix + "_copy", C, B),
            c.setLocal("j", c.i32_sub(c.i32_sub(c.getLocal("m"), c.getLocal("i")), c.i32_const(1))),
            c.block(c.loop(
              c.br_if(1, c.i32_eqz(c.getLocal("j"))),
              c.call(prefix + "_square", B, B),
              c.setLocal("j", c.i32_sub(c.getLocal("j"), c.i32_const(1))),
              c.br(0)
            )),
            c.setLocal("m", c.getLocal("i")),
            c.call(prefix + "_square", B, C),
            c.call(prefix + "_mul", T, C, T),
            c.call(prefix + "_mul", R, B, R),
            c.br(0)
          )),
          c.if(
            c.call(prefix + "_isNegative", R),
            c.call(prefix + "_neg", R, c.getLocal("r")),
            c.call(prefix + "_copy", R, c.getLocal("r"))
          )
        );
      }
      function buildIsSquare() {
        const f = module3.addFunction(prefix + "_isSquare");
        f.addParam("n", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const ONE = c.i32_const(pOne);
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("n")),
            c.ret(c.i32_const(1))
          ),
          c.call(prefix + "_exp", c.getLocal("n"), c.i32_const(pe), c.i32_const(n8), AUX),
          c.call(prefix + "_eq", AUX, ONE)
        );
      }
      function buildLoad() {
        const f = module3.addFunction(prefix + "_load");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        f.addLocal("p", "i32");
        f.addLocal("l", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        const c = f.getCodeBuilder();
        const R = c.i32_const(module3.alloc(n8));
        const pAux = module3.alloc(n8);
        const AUX = c.i32_const(pAux);
        f.addCode(
          c.call(intPrefix + "_zero", c.getLocal("r")),
          c.setLocal("i", c.i32_const(n8)),
          c.setLocal("p", c.getLocal("scalar")),
          c.block(c.loop(
            c.br_if(1, c.i32_gt_u(c.getLocal("i"), c.getLocal("scalarLen"))),
            c.if(
              c.i32_eq(c.getLocal("i"), c.i32_const(n8)),
              c.call(prefix + "_one", R),
              c.call(prefix + "_mul", R, c.i32_const(pR2), R)
            ),
            c.call(prefix + "_mul", c.getLocal("p"), R, AUX),
            c.call(prefix + "_add", c.getLocal("r"), AUX, c.getLocal("r")),
            c.setLocal("p", c.i32_add(c.getLocal("p"), c.i32_const(n8))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(n8))),
            c.br(0)
          )),
          c.setLocal("l", c.i32_rem_u(c.getLocal("scalarLen"), c.i32_const(n8))),
          c.if(c.i32_eqz(c.getLocal("l")), c.ret([])),
          c.call(intPrefix + "_zero", AUX),
          c.setLocal("j", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("j"), c.getLocal("l"))),
            c.i32_store8(
              c.getLocal("j"),
              pAux,
              c.i32_load8_u(c.getLocal("p"))
            ),
            c.setLocal("p", c.i32_add(c.getLocal("p"), c.i32_const(1))),
            c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
            c.br(0)
          )),
          c.if(
            c.i32_eq(c.getLocal("i"), c.i32_const(n8)),
            c.call(prefix + "_one", R),
            c.call(prefix + "_mul", R, c.i32_const(pR2), R)
          ),
          c.call(prefix + "_mul", AUX, R, AUX),
          c.call(prefix + "_add", c.getLocal("r"), AUX, c.getLocal("r"))
        );
      }
      function buildTimesScalar() {
        const f = module3.addFunction(prefix + "_timesScalar");
        f.addParam("x", "i32");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call(prefix + "_load", c.getLocal("scalar"), c.getLocal("scalarLen"), AUX),
          c.call(prefix + "_toMontgomery", AUX, AUX),
          c.call(prefix + "_mul", c.getLocal("x"), AUX, c.getLocal("r"))
        );
      }
      function buildIsOne() {
        const f = module3.addFunction(prefix + "_isOne");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.ret(c.call(intPrefix + "_eq", c.getLocal("x"), c.i32_const(pOne)))
        );
      }
      module3.exportFunction(intPrefix + "_copy", prefix + "_copy");
      module3.exportFunction(intPrefix + "_zero", prefix + "_zero");
      module3.exportFunction(intPrefix + "_isZero", prefix + "_isZero");
      module3.exportFunction(intPrefix + "_eq", prefix + "_eq");
      buildIsOne();
      buildAdd();
      buildSub();
      buildNeg();
      buildMReduct();
      buildMul();
      buildSquare();
      buildSquareOld();
      buildToMontgomery();
      buildFromMontgomery();
      buildIsNegative();
      buildSign();
      buildInverse();
      buildOne();
      buildLoad();
      buildTimesScalar();
      buildBatchInverse(module3, prefix);
      buildBatchConvertion(module3, prefix + "_batchToMontgomery", prefix + "_toMontgomery", n8, n8);
      buildBatchConvertion(module3, prefix + "_batchFromMontgomery", prefix + "_fromMontgomery", n8, n8);
      buildBatchConvertion(module3, prefix + "_batchNeg", prefix + "_neg", n8, n8);
      buildBatchOp(module3, prefix + "_batchAdd", prefix + "_add", n8, n8);
      buildBatchOp(module3, prefix + "_batchSub", prefix + "_sub", n8, n8);
      buildBatchOp(module3, prefix + "_batchMul", prefix + "_mul", n8, n8);
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_isNegative");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_mReduct");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_squareOld");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_inverse");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_load");
      module3.exportFunction(prefix + "_timesScalar");
      buildExp(
        module3,
        prefix + "_exp",
        n8,
        prefix + "_mul",
        prefix + "_square",
        intPrefix + "_copy",
        prefix + "_one"
      );
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_batchInverse");
      if (isPrime(q)) {
        buildSqrt4();
        buildIsSquare();
        module3.exportFunction(prefix + "_sqrt");
        module3.exportFunction(prefix + "_isSquare");
      }
      module3.exportFunction(prefix + "_batchToMontgomery");
      module3.exportFunction(prefix + "_batchFromMontgomery");
      return prefix;
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_f1.js
var require_build_f1 = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_f1.js"(exports, module2) {
    "use strict";
    var buildF1m = require_build_f1m();
    var { bitLength: bitLength5 } = require_bigint();
    module2.exports = function buildF1(module3, _q, _prefix, _f1mPrefix, _intPrefix) {
      const q = BigInt(_q);
      const n64 = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n8 = n64 * 8;
      const prefix = _prefix || "f1";
      if (module3.modules[prefix])
        return prefix;
      module3.modules[prefix] = {
        n64
      };
      const intPrefix = _intPrefix || "int";
      const f1mPrefix = buildF1m(module3, q, _f1mPrefix, intPrefix);
      const pR2 = module3.modules[f1mPrefix].pR2;
      const pq = module3.modules[f1mPrefix].pq;
      const pePlusOne = module3.modules[f1mPrefix].pePlusOne;
      function buildMul() {
        const pAux1 = module3.alloc(n8);
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(f1mPrefix + "_mul", c.getLocal("x"), c.getLocal("y"), c.i32_const(pAux1)));
        f.addCode(c.call(f1mPrefix + "_mul", c.i32_const(pAux1), c.i32_const(pR2), c.getLocal("r")));
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.getLocal("x"), c.getLocal("r")));
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(intPrefix + "_inverseMod", c.getLocal("x"), c.i32_const(pq), c.getLocal("r")));
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(intPrefix + "_gte", c.getLocal("x"), c.i32_const(pePlusOne))
        );
      }
      buildMul();
      buildSquare();
      buildInverse();
      buildIsNegative();
      module3.exportFunction(f1mPrefix + "_add", prefix + "_add");
      module3.exportFunction(f1mPrefix + "_sub", prefix + "_sub");
      module3.exportFunction(f1mPrefix + "_neg", prefix + "_neg");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_inverse");
      module3.exportFunction(prefix + "_isNegative");
      module3.exportFunction(f1mPrefix + "_copy", prefix + "_copy");
      module3.exportFunction(f1mPrefix + "_zero", prefix + "_zero");
      module3.exportFunction(f1mPrefix + "_one", prefix + "_one");
      module3.exportFunction(f1mPrefix + "_isZero", prefix + "_isZero");
      module3.exportFunction(f1mPrefix + "_eq", prefix + "_eq");
      return prefix;
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_f2m.js
var require_build_f2m = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_f2m.js"(exports, module2) {
    "use strict";
    var buildExp = require_build_timesscalar();
    var buildBatchInverse = require_build_batchinverse();
    var utils2 = require_utils();
    module2.exports = function buildF2m(module3, mulNonResidueFn, prefix, f1mPrefix) {
      if (module3.modules[prefix])
        return prefix;
      const f1n8 = module3.modules[f1mPrefix].n64 * 8;
      const q = module3.modules[f1mPrefix].q;
      module3.modules[prefix] = {
        n64: module3.modules[f1mPrefix].n64 * 2
      };
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_add", x0, y0, r0),
          c.call(f1mPrefix + "_add", x1, y1, r1)
        );
      }
      function buildTimesScalar() {
        const f = module3.addFunction(prefix + "_timesScalar");
        f.addParam("x", "i32");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_timesScalar", x0, c.getLocal("scalar"), c.getLocal("scalarLen"), r0),
          c.call(f1mPrefix + "_timesScalar", x1, c.getLocal("scalar"), c.getLocal("scalarLen"), r1)
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_sub", x0, y0, r0),
          c.call(f1mPrefix + "_sub", x1, y1, r1)
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_neg", x0, r0),
          c.call(f1mPrefix + "_neg", x1, r1)
        );
      }
      function buildConjugate() {
        const f = module3.addFunction(prefix + "_conjugate");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, r0),
          c.call(f1mPrefix + "_neg", x1, r1)
        );
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.if(
            c.call(f1mPrefix + "_isZero", x1),
            c.ret(c.call(f1mPrefix + "_isNegative", x0))
          ),
          c.ret(c.call(f1mPrefix + "_isNegative", x1))
        );
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const A = c.i32_const(module3.alloc(f1n8));
        const B = c.i32_const(module3.alloc(f1n8));
        const C = c.i32_const(module3.alloc(f1n8));
        const D = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_mul", x0, y0, A),
          // A = x0*y0
          c.call(f1mPrefix + "_mul", x1, y1, B),
          // B = x1*y1
          c.call(f1mPrefix + "_add", x0, x1, C),
          // C = x0 + x1
          c.call(f1mPrefix + "_add", y0, y1, D),
          // D = y0 + y1
          c.call(f1mPrefix + "_mul", C, D, C),
          // C = (x0 + x1)*(y0 + y1) = x0*y0+x0*y1+x1*y0+x1*y1
          //  c.call(f1mPrefix + "_mul", B, c.i32_const(pNonResidue), r0),  // r0 = nr*(x1*y1)
          c.call(mulNonResidueFn, B, r0),
          // r0 = nr*(x1*y1)
          c.call(f1mPrefix + "_add", A, r0, r0),
          // r0 = x0*y0 + nr*(x1*y1)
          c.call(f1mPrefix + "_add", A, B, r1),
          // r1 = x0*y0+x1*y1
          c.call(f1mPrefix + "_sub", C, r1, r1)
          // r1 = x0*y0+x0*y1+x1*y0+x1*y1 - x0*y0+x1*y1 = x0*y1+x1*y0
        );
      }
      function buildMul1() {
        const f = module3.addFunction(prefix + "_mul1");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y = c.getLocal("y");
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_mul", x0, y, r0),
          // A = x0*y
          c.call(f1mPrefix + "_mul", x1, y, r1)
          // B = x1*y
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const AB = c.i32_const(module3.alloc(f1n8));
        const APB = c.i32_const(module3.alloc(f1n8));
        const APNB = c.i32_const(module3.alloc(f1n8));
        const ABPNAB = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          // AB = x0*y1
          c.call(f1mPrefix + "_mul", x0, x1, AB),
          // APB = x0+y1
          c.call(f1mPrefix + "_add", x0, x1, APB),
          // APBN0 = x0 + nr*x1
          c.call(mulNonResidueFn, x1, APNB),
          c.call(f1mPrefix + "_add", x0, APNB, APNB),
          // ABPNAB = ab + nr*ab
          c.call(mulNonResidueFn, AB, ABPNAB),
          c.call(f1mPrefix + "_add", ABPNAB, AB, ABPNAB),
          // r0 = APB * APNB - ABPNAB
          c.call(f1mPrefix + "_mul", APB, APNB, r0),
          c.call(f1mPrefix + "_sub", r0, ABPNAB, r0),
          // r1 = AB + AB
          c.call(f1mPrefix + "_add", AB, AB, r1)
        );
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_toMontgomery", x0, r0),
          c.call(f1mPrefix + "_toMontgomery", x1, r1)
        );
      }
      function buildFromMontgomery() {
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_fromMontgomery", x0, r0),
          c.call(f1mPrefix + "_fromMontgomery", x1, r1)
        );
      }
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, r0),
          c.call(f1mPrefix + "_copy", x1, r1)
        );
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_zero", x0),
          c.call(f1mPrefix + "_zero", x1)
        );
      }
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_one", x0),
          c.call(f1mPrefix + "_zero", x1)
        );
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        f.addCode(
          c.i32_and(
            c.call(f1mPrefix + "_eq", x0, y0),
            c.call(f1mPrefix + "_eq", x1, y1)
          )
        );
      }
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.i32_and(
            c.call(f1mPrefix + "_isZero", x0),
            c.call(f1mPrefix + "_isZero", x1)
          )
        );
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const t0 = c.i32_const(module3.alloc(f1n8));
        const t1 = c.i32_const(module3.alloc(f1n8));
        const t2 = c.i32_const(module3.alloc(f1n8));
        const t3 = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_square", x0, t0),
          c.call(f1mPrefix + "_square", x1, t1),
          // c.call(f1mPrefix+"_mul", t1, c.i32_const(pNonResidue), t2),
          c.call(mulNonResidueFn, t1, t2),
          c.call(f1mPrefix + "_sub", t0, t2, t2),
          c.call(f1mPrefix + "_inverse", t2, t3),
          c.call(f1mPrefix + "_mul", x0, t3, r0),
          c.call(f1mPrefix + "_mul", x1, t3, r1),
          c.call(f1mPrefix + "_neg", r1, r1)
        );
      }
      function buildSign() {
        const f = module3.addFunction(prefix + "_sign");
        f.addParam("x", "i32");
        f.addLocal("s", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.setLocal("s", c.call(f1mPrefix + "_sign", x1)),
          c.if(
            c.getLocal("s"),
            c.ret(c.getLocal("s"))
          ),
          c.ret(c.call(f1mPrefix + "_sign", x0))
        );
      }
      function buildIsOne() {
        const f = module3.addFunction(prefix + "_isOne");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.ret(c.i32_and(
            c.call(f1mPrefix + "_isOne", x0),
            c.call(f1mPrefix + "_isZero", x1)
          ))
        );
      }
      function buildSqrt4() {
        const f = module3.addFunction(prefix + "_sqrt");
        f.addParam("a", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const e34 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8)));
        const e12 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 1n) / 2n, f1n8)));
        const a = c.getLocal("a");
        const a1 = c.i32_const(module3.alloc(f1n8 * 2));
        const alpha = c.i32_const(module3.alloc(f1n8 * 2));
        const a0 = c.i32_const(module3.alloc(f1n8 * 2));
        const pn1 = module3.alloc(f1n8 * 2);
        const n1 = c.i32_const(pn1);
        const n1a = c.i32_const(pn1);
        const n1b = c.i32_const(pn1 + f1n8);
        const x0 = c.i32_const(module3.alloc(f1n8 * 2));
        const b = c.i32_const(module3.alloc(f1n8 * 2));
        f.addCode(
          c.call(prefix + "_one", n1),
          c.call(prefix + "_neg", n1, n1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_exp", a, e34, c.i32_const(f1n8), a1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_square", a1, alpha),
          c.call(prefix + "_mul", a, alpha, alpha),
          // const a0 = F.mul(F.frobenius(1, alfa), alfa);
          c.call(prefix + "_conjugate", alpha, a0),
          c.call(prefix + "_mul", a0, alpha, a0),
          // if (F.eq(a0, F.negone)) return null;
          c.if(c.call(prefix + "_eq", a0, n1), c.unreachable()),
          // const x0 = F.mul(a1, a);
          c.call(prefix + "_mul", a1, a, x0),
          // if (F.eq(alfa, F.negone)) {
          c.if(
            c.call(prefix + "_eq", alpha, n1),
            [
              // x = F.mul(x0, [F.F.zero, F.F.one]);
              ...c.call(f1mPrefix + "_zero", n1a),
              ...c.call(f1mPrefix + "_one", n1b),
              ...c.call(prefix + "_mul", n1, x0, c.getLocal("pr"))
            ],
            [
              // const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);
              ...c.call(prefix + "_one", b),
              ...c.call(prefix + "_add", b, alpha, b),
              ...c.call(prefix + "_exp", b, e12, c.i32_const(f1n8), b),
              // x = F.mul(b, x0);
              ...c.call(prefix + "_mul", b, x0, c.getLocal("pr"))
            ]
          )
        );
      }
      function buildIsSquare() {
        const f = module3.addFunction(prefix + "_isSquare");
        f.addParam("a", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const e34 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8)));
        const a = c.getLocal("a");
        const a1 = c.i32_const(module3.alloc(f1n8 * 2));
        const alpha = c.i32_const(module3.alloc(f1n8 * 2));
        const a0 = c.i32_const(module3.alloc(f1n8 * 2));
        const pn1 = module3.alloc(f1n8 * 2);
        const n1 = c.i32_const(pn1);
        f.addCode(
          c.call(prefix + "_one", n1),
          c.call(prefix + "_neg", n1, n1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_exp", a, e34, c.i32_const(f1n8), a1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_square", a1, alpha),
          c.call(prefix + "_mul", a, alpha, alpha),
          // const a0 = F.mul(F.frobenius(1, alfa), alfa);
          c.call(prefix + "_conjugate", alpha, a0),
          c.call(prefix + "_mul", a0, alpha, a0),
          // if (F.eq(a0, F.negone)) return null;
          c.if(
            c.call(
              prefix + "_eq",
              a0,
              n1
            ),
            c.ret(c.i32_const(0))
          ),
          c.ret(c.i32_const(1))
        );
      }
      buildIsZero();
      buildIsOne();
      buildZero();
      buildOne();
      buildCopy();
      buildMul();
      buildMul1();
      buildSquare();
      buildAdd();
      buildSub();
      buildNeg();
      buildConjugate();
      buildToMontgomery();
      buildFromMontgomery();
      buildEq();
      buildInverse();
      buildTimesScalar();
      buildSign();
      buildIsNegative();
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_mul1");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_conjugate");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_inverse");
      buildBatchInverse(module3, prefix);
      buildExp(
        module3,
        prefix + "_exp",
        f1n8 * 2,
        prefix + "_mul",
        prefix + "_square",
        prefix + "_copy",
        prefix + "_one"
      );
      buildSqrt4();
      buildIsSquare();
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_batchInverse");
      module3.exportFunction(prefix + "_sqrt");
      module3.exportFunction(prefix + "_isSquare");
      module3.exportFunction(prefix + "_isNegative");
      return prefix;
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_f3m.js
var require_build_f3m = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_f3m.js"(exports, module2) {
    "use strict";
    var buildExp = require_build_timesscalar();
    var buildBatchInverse = require_build_batchinverse();
    module2.exports = function buildF3m(module3, mulNonResidueFn, prefix, f1mPrefix) {
      if (module3.modules[prefix])
        return prefix;
      const f1n8 = module3.modules[f1mPrefix].n64 * 8;
      module3.modules[prefix] = {
        n64: module3.modules[f1mPrefix].n64 * 3
      };
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const y2 = c.i32_add(c.getLocal("y"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_add", x0, y0, r0),
          c.call(f1mPrefix + "_add", x1, y1, r1),
          c.call(f1mPrefix + "_add", x2, y2, r2)
        );
      }
      function buildTimesScalar() {
        const f = module3.addFunction(prefix + "_timesScalar");
        f.addParam("x", "i32");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_timesScalar", x0, c.getLocal("scalar"), c.getLocal("scalarLen"), r0),
          c.call(f1mPrefix + "_timesScalar", x1, c.getLocal("scalar"), c.getLocal("scalarLen"), r1),
          c.call(f1mPrefix + "_timesScalar", x2, c.getLocal("scalar"), c.getLocal("scalarLen"), r2)
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const y2 = c.i32_add(c.getLocal("y"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_sub", x0, y0, r0),
          c.call(f1mPrefix + "_sub", x1, y1, r1),
          c.call(f1mPrefix + "_sub", x2, y2, r2)
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_neg", x0, r0),
          c.call(f1mPrefix + "_neg", x1, r1),
          c.call(f1mPrefix + "_neg", x2, r2)
        );
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.if(
            c.call(f1mPrefix + "_isZero", x2),
            c.if(
              c.call(f1mPrefix + "_isZero", x1),
              c.ret(c.call(f1mPrefix + "_isNegative", x0)),
              c.ret(c.call(f1mPrefix + "_isNegative", x1))
            )
          ),
          c.ret(c.call(f1mPrefix + "_isNegative", x2))
        );
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const cd = f.getCodeBuilder();
        const a = cd.getLocal("x");
        const b = cd.i32_add(cd.getLocal("x"), cd.i32_const(f1n8));
        const c = cd.i32_add(cd.getLocal("x"), cd.i32_const(2 * f1n8));
        const A = cd.getLocal("y");
        const B = cd.i32_add(cd.getLocal("y"), cd.i32_const(f1n8));
        const C = cd.i32_add(cd.getLocal("y"), cd.i32_const(2 * f1n8));
        const r0 = cd.getLocal("r");
        const r1 = cd.i32_add(cd.getLocal("r"), cd.i32_const(f1n8));
        const r2 = cd.i32_add(cd.getLocal("r"), cd.i32_const(2 * f1n8));
        const aA = cd.i32_const(module3.alloc(f1n8));
        const bB = cd.i32_const(module3.alloc(f1n8));
        const cC = cd.i32_const(module3.alloc(f1n8));
        const a_b = cd.i32_const(module3.alloc(f1n8));
        const A_B = cd.i32_const(module3.alloc(f1n8));
        const a_c = cd.i32_const(module3.alloc(f1n8));
        const A_C = cd.i32_const(module3.alloc(f1n8));
        const b_c = cd.i32_const(module3.alloc(f1n8));
        const B_C = cd.i32_const(module3.alloc(f1n8));
        const aA_bB = cd.i32_const(module3.alloc(f1n8));
        const aA_cC = cd.i32_const(module3.alloc(f1n8));
        const bB_cC = cd.i32_const(module3.alloc(f1n8));
        const AUX = cd.i32_const(module3.alloc(f1n8));
        f.addCode(
          cd.call(f1mPrefix + "_mul", a, A, aA),
          cd.call(f1mPrefix + "_mul", b, B, bB),
          cd.call(f1mPrefix + "_mul", c, C, cC),
          cd.call(f1mPrefix + "_add", a, b, a_b),
          cd.call(f1mPrefix + "_add", A, B, A_B),
          cd.call(f1mPrefix + "_add", a, c, a_c),
          cd.call(f1mPrefix + "_add", A, C, A_C),
          cd.call(f1mPrefix + "_add", b, c, b_c),
          cd.call(f1mPrefix + "_add", B, C, B_C),
          cd.call(f1mPrefix + "_add", aA, bB, aA_bB),
          cd.call(f1mPrefix + "_add", aA, cC, aA_cC),
          cd.call(f1mPrefix + "_add", bB, cC, bB_cC),
          cd.call(f1mPrefix + "_mul", b_c, B_C, r0),
          cd.call(f1mPrefix + "_sub", r0, bB_cC, r0),
          cd.call(mulNonResidueFn, r0, r0),
          cd.call(f1mPrefix + "_add", aA, r0, r0),
          cd.call(f1mPrefix + "_mul", a_b, A_B, r1),
          cd.call(f1mPrefix + "_sub", r1, aA_bB, r1),
          cd.call(mulNonResidueFn, cC, AUX),
          cd.call(f1mPrefix + "_add", r1, AUX, r1),
          cd.call(f1mPrefix + "_mul", a_c, A_C, r2),
          cd.call(f1mPrefix + "_sub", r2, aA_cC, r2),
          cd.call(f1mPrefix + "_add", r2, bB, r2)
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const A = c.getLocal("x");
        const B = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const C = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        const s0 = c.i32_const(module3.alloc(f1n8));
        const ab = c.i32_const(module3.alloc(f1n8));
        const s1 = c.i32_const(module3.alloc(f1n8));
        const s2 = c.i32_const(module3.alloc(f1n8));
        const bc = c.i32_const(module3.alloc(f1n8));
        const s3 = c.i32_const(module3.alloc(f1n8));
        const s4 = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_square", A, s0),
          c.call(f1mPrefix + "_mul", A, B, ab),
          c.call(f1mPrefix + "_add", ab, ab, s1),
          c.call(f1mPrefix + "_sub", A, B, s2),
          c.call(f1mPrefix + "_add", s2, C, s2),
          c.call(f1mPrefix + "_square", s2, s2),
          c.call(f1mPrefix + "_mul", B, C, bc),
          c.call(f1mPrefix + "_add", bc, bc, s3),
          c.call(f1mPrefix + "_square", C, s4),
          c.call(mulNonResidueFn, s3, r0),
          c.call(f1mPrefix + "_add", s0, r0, r0),
          c.call(mulNonResidueFn, s4, r1),
          c.call(f1mPrefix + "_add", s1, r1, r1),
          c.call(f1mPrefix + "_add", s0, s4, r2),
          c.call(f1mPrefix + "_sub", s3, r2, r2),
          c.call(f1mPrefix + "_add", s2, r2, r2),
          c.call(f1mPrefix + "_add", s1, r2, r2)
        );
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_toMontgomery", x0, r0),
          c.call(f1mPrefix + "_toMontgomery", x1, r1),
          c.call(f1mPrefix + "_toMontgomery", x2, r2)
        );
      }
      function buildFromMontgomery() {
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_fromMontgomery", x0, r0),
          c.call(f1mPrefix + "_fromMontgomery", x1, r1),
          c.call(f1mPrefix + "_fromMontgomery", x2, r2)
        );
      }
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, r0),
          c.call(f1mPrefix + "_copy", x1, r1),
          c.call(f1mPrefix + "_copy", x2, r2)
        );
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_zero", x0),
          c.call(f1mPrefix + "_zero", x1),
          c.call(f1mPrefix + "_zero", x2)
        );
      }
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_one", x0),
          c.call(f1mPrefix + "_zero", x1),
          c.call(f1mPrefix + "_zero", x2)
        );
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const y2 = c.i32_add(c.getLocal("y"), c.i32_const(2 * f1n8));
        f.addCode(
          c.i32_and(
            c.i32_and(
              c.call(f1mPrefix + "_eq", x0, y0),
              c.call(f1mPrefix + "_eq", x1, y1)
            ),
            c.call(f1mPrefix + "_eq", x2, y2)
          )
        );
      }
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.i32_and(
            c.i32_and(
              c.call(f1mPrefix + "_isZero", x0),
              c.call(f1mPrefix + "_isZero", x1)
            ),
            c.call(f1mPrefix + "_isZero", x2)
          )
        );
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        const t0 = c.i32_const(module3.alloc(f1n8));
        const t1 = c.i32_const(module3.alloc(f1n8));
        const t2 = c.i32_const(module3.alloc(f1n8));
        const t3 = c.i32_const(module3.alloc(f1n8));
        const t4 = c.i32_const(module3.alloc(f1n8));
        const t5 = c.i32_const(module3.alloc(f1n8));
        const c0 = c.i32_const(module3.alloc(f1n8));
        const c1 = c.i32_const(module3.alloc(f1n8));
        const c2 = c.i32_const(module3.alloc(f1n8));
        const t6 = c.i32_const(module3.alloc(f1n8));
        const AUX = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_square", x0, t0),
          c.call(f1mPrefix + "_square", x1, t1),
          c.call(f1mPrefix + "_square", x2, t2),
          c.call(f1mPrefix + "_mul", x0, x1, t3),
          c.call(f1mPrefix + "_mul", x0, x2, t4),
          c.call(f1mPrefix + "_mul", x1, x2, t5),
          c.call(mulNonResidueFn, t5, c0),
          c.call(f1mPrefix + "_sub", t0, c0, c0),
          c.call(mulNonResidueFn, t2, c1),
          c.call(f1mPrefix + "_sub", c1, t3, c1),
          c.call(f1mPrefix + "_sub", t1, t4, c2),
          c.call(f1mPrefix + "_mul", x2, c1, t6),
          c.call(f1mPrefix + "_mul", x1, c2, AUX),
          c.call(f1mPrefix + "_add", t6, AUX, t6),
          c.call(mulNonResidueFn, t6, t6),
          c.call(f1mPrefix + "_mul", x0, c0, AUX),
          c.call(f1mPrefix + "_add", AUX, t6, t6),
          c.call(f1mPrefix + "_inverse", t6, t6),
          c.call(f1mPrefix + "_mul", t6, c0, r0),
          c.call(f1mPrefix + "_mul", t6, c1, r1),
          c.call(f1mPrefix + "_mul", t6, c2, r2)
        );
      }
      function buildSign() {
        const f = module3.addFunction(prefix + "_sign");
        f.addParam("x", "i32");
        f.addLocal("s", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.setLocal("s", c.call(f1mPrefix + "_sign", x2)),
          c.if(
            c.getLocal("s"),
            c.ret(c.getLocal("s"))
          ),
          c.setLocal("s", c.call(f1mPrefix + "_sign", x1)),
          c.if(
            c.getLocal("s"),
            c.ret(c.getLocal("s"))
          ),
          c.ret(c.call(f1mPrefix + "_sign", x0))
        );
      }
      function buildIsOne() {
        const f = module3.addFunction(prefix + "_isOne");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8 * 2));
        f.addCode(
          c.ret(
            c.i32_and(
              c.i32_and(
                c.call(f1mPrefix + "_isOne", x0),
                c.call(f1mPrefix + "_isZero", x1)
              ),
              c.call(f1mPrefix + "_isZero", x2)
            )
          )
        );
      }
      buildIsZero();
      buildIsOne();
      buildZero();
      buildOne();
      buildCopy();
      buildMul();
      buildSquare();
      buildAdd();
      buildSub();
      buildNeg();
      buildSign();
      buildToMontgomery();
      buildFromMontgomery();
      buildEq();
      buildInverse();
      buildTimesScalar();
      buildIsNegative();
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_inverse");
      buildBatchInverse(module3, prefix);
      buildExp(
        module3,
        prefix + "_exp",
        f1n8 * 3,
        prefix + "_mul",
        prefix + "_square",
        prefix + "_copy",
        prefix + "_one"
      );
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_batchInverse");
      module3.exportFunction(prefix + "_isNegative");
      return prefix;
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_timesscalarnaf.js
var require_build_timesscalarnaf = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_timesscalarnaf.js"(exports, module2) {
    "use strict";
    module2.exports = function buildTimesScalarNAF(module3, fnName, elementLen, opAB, opAA, opAmB, opCopy, opInit) {
      const f = module3.addFunction(fnName);
      f.addParam("base", "i32");
      f.addParam("scalar", "i32");
      f.addParam("scalarLength", "i32");
      f.addParam("r", "i32");
      f.addLocal("old0", "i32");
      f.addLocal("nbits", "i32");
      f.addLocal("i", "i32");
      f.addLocal("last", "i32");
      f.addLocal("cur", "i32");
      f.addLocal("carry", "i32");
      f.addLocal("p", "i32");
      const c = f.getCodeBuilder();
      const aux = c.i32_const(module3.alloc(elementLen));
      function getBit(IDX) {
        return c.i32_and(
          c.i32_shr_u(
            c.i32_load(
              c.i32_add(
                c.getLocal("scalar"),
                c.i32_and(
                  c.i32_shr_u(
                    IDX,
                    c.i32_const(3)
                  ),
                  c.i32_const(4294967292)
                )
              )
            ),
            c.i32_and(
              IDX,
              c.i32_const(31)
            )
          ),
          c.i32_const(1)
        );
      }
      function pushBit(b) {
        return [
          ...c.i32_store8(
            c.getLocal("p"),
            c.i32_const(b)
          ),
          ...c.setLocal(
            "p",
            c.i32_add(
              c.getLocal("p"),
              c.i32_const(1)
            )
          )
        ];
      }
      f.addCode(
        c.if(
          c.i32_eqz(c.getLocal("scalarLength")),
          [
            ...c.call(opInit, c.getLocal("r")),
            ...c.ret([])
          ]
        ),
        c.setLocal("nbits", c.i32_shl(c.getLocal("scalarLength"), c.i32_const(3))),
        c.setLocal("old0", c.i32_load(c.i32_const(0))),
        c.setLocal("p", c.getLocal("old0")),
        c.i32_store(
          c.i32_const(0),
          c.i32_and(
            c.i32_add(
              c.i32_add(
                c.getLocal("old0"),
                c.i32_const(32)
              ),
              c.getLocal("nbits")
            ),
            c.i32_const(4294967288)
          )
        ),
        c.setLocal("i", c.i32_const(1)),
        c.setLocal("last", getBit(c.i32_const(0))),
        c.setLocal("carry", c.i32_const(0)),
        c.block(c.loop(
          c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("nbits"))),
          c.setLocal("cur", getBit(c.getLocal("i"))),
          c.if(
            c.getLocal("last"),
            c.if(
              c.getLocal("cur"),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(1)
                ],
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(255)
                ]
              ),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(255)
                ],
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(1)
                ]
              )
            ),
            c.if(
              c.getLocal("cur"),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(0)
                ],
                [
                  ...c.setLocal("last", c.i32_const(1)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(0)
                ]
              ),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(1)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(0)
                ],
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(0)
                ]
              )
            )
          ),
          c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        )),
        c.if(
          c.getLocal("last"),
          c.if(
            c.getLocal("carry"),
            [
              ...pushBit(255),
              ...pushBit(0),
              ...pushBit(1)
            ],
            [
              ...pushBit(1)
            ]
          ),
          c.if(
            c.getLocal("carry"),
            [
              ...pushBit(0),
              ...pushBit(1)
            ]
          )
        ),
        c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
        // p already points to the last bit
        c.call(opCopy, c.getLocal("base"), aux),
        c.call(opInit, c.getLocal("r")),
        c.block(c.loop(
          c.call(opAA, c.getLocal("r"), c.getLocal("r")),
          c.setLocal(
            "cur",
            c.i32_load8_u(
              c.getLocal("p")
            )
          ),
          c.if(
            c.getLocal("cur"),
            c.if(
              c.i32_eq(c.getLocal("cur"), c.i32_const(1)),
              c.call(opAB, c.getLocal("r"), aux, c.getLocal("r")),
              c.call(opAmB, c.getLocal("r"), aux, c.getLocal("r"))
            )
          ),
          c.br_if(1, c.i32_eq(c.getLocal("old0"), c.getLocal("p"))),
          c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
          c.br(0)
        )),
        c.i32_store(c.i32_const(0), c.getLocal("old0"))
      );
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_multiexp.js
var require_build_multiexp = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_multiexp.js"(exports, module2) {
    "use strict";
    module2.exports = function buildMultiexp4(module3, prefix, fnName, opAdd, n8b) {
      const n64g = module3.modules[prefix].n64;
      const n8g = n64g * 8;
      function buildGetChunk() {
        const f = module3.addFunction(fnName + "_getChunk");
        f.addParam("pScalar", "i32");
        f.addParam("scalarSize", "i32");
        f.addParam("startBit", "i32");
        f.addParam("chunkSize", "i32");
        f.addLocal("bitsToEnd", "i32");
        f.addLocal("mask", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "bitsToEnd",
            c.i32_sub(
              c.i32_mul(
                c.getLocal("scalarSize"),
                c.i32_const(8)
              ),
              c.getLocal("startBit")
            )
          ),
          c.if(
            c.i32_gt_s(
              c.getLocal("chunkSize"),
              c.getLocal("bitsToEnd")
            ),
            c.setLocal(
              "mask",
              c.i32_sub(
                c.i32_shl(
                  c.i32_const(1),
                  c.getLocal("bitsToEnd")
                ),
                c.i32_const(1)
              )
            ),
            c.setLocal(
              "mask",
              c.i32_sub(
                c.i32_shl(
                  c.i32_const(1),
                  c.getLocal("chunkSize")
                ),
                c.i32_const(1)
              )
            )
          ),
          c.i32_and(
            c.i32_shr_u(
              c.i32_load(
                c.i32_add(
                  c.getLocal("pScalar"),
                  c.i32_shr_u(
                    c.getLocal("startBit"),
                    c.i32_const(3)
                  )
                ),
                0,
                // offset
                0
                // align to byte.
              ),
              c.i32_and(
                c.getLocal("startBit"),
                c.i32_const(7)
              )
            ),
            c.getLocal("mask")
          )
        );
      }
      function buildMutiexpChunk() {
        const f = module3.addFunction(fnName + "_chunk");
        f.addParam("pBases", "i32");
        f.addParam("pScalars", "i32");
        f.addParam("scalarSize", "i32");
        f.addParam("n", "i32");
        f.addParam("startBit", "i32");
        f.addParam("chunkSize", "i32");
        f.addParam("pr", "i32");
        f.addLocal("nChunks", "i32");
        f.addLocal("itScalar", "i32");
        f.addLocal("endScalar", "i32");
        f.addLocal("itBase", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("nTable", "i32");
        f.addLocal("pTable", "i32");
        f.addLocal("idx", "i32");
        f.addLocal("pIdxTable", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.i32_eqz(c.getLocal("n")),
            [
              ...c.call(prefix + "_zero", c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          // Allocate memory
          c.setLocal(
            "nTable",
            c.i32_shl(
              c.i32_const(1),
              c.getLocal("chunkSize")
            )
          ),
          c.setLocal("pTable", c.i32_load(c.i32_const(0))),
          c.i32_store(
            c.i32_const(0),
            c.i32_add(
              c.getLocal("pTable"),
              c.i32_mul(
                c.getLocal("nTable"),
                c.i32_const(n8g)
              )
            )
          ),
          // Reset Table
          c.setLocal("j", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("j"),
                c.getLocal("nTable")
              )
            ),
            c.call(
              prefix + "_zero",
              c.i32_add(
                c.getLocal("pTable"),
                c.i32_mul(
                  c.getLocal("j"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
            c.br(0)
          )),
          // Distribute elements
          c.setLocal("itBase", c.getLocal("pBases")),
          c.setLocal("itScalar", c.getLocal("pScalars")),
          c.setLocal(
            "endScalar",
            c.i32_add(
              c.getLocal("pScalars"),
              c.i32_mul(
                c.getLocal("n"),
                c.getLocal("scalarSize")
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("itScalar"),
                c.getLocal("endScalar")
              )
            ),
            c.setLocal(
              "idx",
              c.call(
                fnName + "_getChunk",
                c.getLocal("itScalar"),
                c.getLocal("scalarSize"),
                c.getLocal("startBit"),
                c.getLocal("chunkSize")
              )
            ),
            c.if(
              c.getLocal("idx"),
              [
                ...c.setLocal(
                  "pIdxTable",
                  c.i32_add(
                    c.getLocal("pTable"),
                    c.i32_mul(
                      c.i32_sub(
                        c.getLocal("idx"),
                        c.i32_const(1)
                      ),
                      c.i32_const(n8g)
                    )
                  )
                ),
                ...c.call(
                  opAdd,
                  c.getLocal("pIdxTable"),
                  c.getLocal("itBase"),
                  c.getLocal("pIdxTable")
                )
              ]
            ),
            c.setLocal("itScalar", c.i32_add(c.getLocal("itScalar"), c.getLocal("scalarSize"))),
            c.setLocal("itBase", c.i32_add(c.getLocal("itBase"), c.i32_const(n8b))),
            c.br(0)
          )),
          c.call(fnName + "_reduceTable", c.getLocal("pTable"), c.getLocal("chunkSize")),
          c.call(
            prefix + "_copy",
            c.getLocal("pTable"),
            c.getLocal("pr")
          ),
          c.i32_store(
            c.i32_const(0),
            c.getLocal("pTable")
          )
        );
      }
      function buildMultiexp5() {
        const f = module3.addFunction(fnName);
        f.addParam("pBases", "i32");
        f.addParam("pScalars", "i32");
        f.addParam("scalarSize", "i32");
        f.addParam("n", "i32");
        f.addParam("pr", "i32");
        f.addLocal("chunkSize", "i32");
        f.addLocal("nChunks", "i32");
        f.addLocal("itScalar", "i32");
        f.addLocal("endScalar", "i32");
        f.addLocal("itBase", "i32");
        f.addLocal("itBit", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("nTable", "i32");
        f.addLocal("pTable", "i32");
        f.addLocal("idx", "i32");
        f.addLocal("pIdxTable", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8g));
        const pTSizes2 = module3.alloc([
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          16,
          16,
          15,
          14,
          13,
          13,
          12,
          11,
          10,
          9,
          8,
          7,
          7,
          6,
          5,
          4,
          3,
          2,
          1,
          1,
          1,
          1
        ]);
        f.addCode(
          c.call(prefix + "_zero", c.getLocal("pr")),
          c.if(
            c.i32_eqz(c.getLocal("n")),
            c.ret([])
          ),
          c.setLocal("chunkSize", c.i32_load8_u(c.i32_clz(c.getLocal("n")), pTSizes2)),
          c.setLocal(
            "nChunks",
            c.i32_add(
              c.i32_div_u(
                c.i32_sub(
                  c.i32_shl(
                    c.getLocal("scalarSize"),
                    c.i32_const(3)
                  ),
                  c.i32_const(1)
                ),
                c.getLocal("chunkSize")
              ),
              c.i32_const(1)
            )
          ),
          // Allocate memory
          c.setLocal(
            "itBit",
            c.i32_mul(
              c.i32_sub(
                c.getLocal("nChunks"),
                c.i32_const(1)
              ),
              c.getLocal("chunkSize")
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_lt_s(
                c.getLocal("itBit"),
                c.i32_const(0)
              )
            ),
            // Double nChunk times
            c.if(
              c.i32_eqz(c.call(prefix + "_isZero", c.getLocal("pr"))),
              [
                ...c.setLocal("j", c.i32_const(0)),
                ...c.block(c.loop(
                  c.br_if(
                    1,
                    c.i32_eq(
                      c.getLocal("j"),
                      c.getLocal("chunkSize")
                    )
                  ),
                  c.call(prefix + "_double", c.getLocal("pr"), c.getLocal("pr")),
                  c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
                  c.br(0)
                ))
              ]
            ),
            c.call(
              fnName + "_chunk",
              c.getLocal("pBases"),
              c.getLocal("pScalars"),
              c.getLocal("scalarSize"),
              c.getLocal("n"),
              c.getLocal("itBit"),
              c.getLocal("chunkSize"),
              aux
            ),
            c.call(
              prefix + "_add",
              c.getLocal("pr"),
              aux,
              c.getLocal("pr")
            ),
            c.setLocal("itBit", c.i32_sub(c.getLocal("itBit"), c.getLocal("chunkSize"))),
            c.br(0)
          ))
        );
      }
      function buildReduceTable() {
        const f = module3.addFunction(fnName + "_reduceTable");
        f.addParam("pTable", "i32");
        f.addParam("p", "i32");
        f.addLocal("half", "i32");
        f.addLocal("it1", "i32");
        f.addLocal("it2", "i32");
        f.addLocal("pAcc", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.i32_eq(c.getLocal("p"), c.i32_const(1)),
            c.ret([])
          ),
          c.setLocal(
            "half",
            c.i32_shl(
              c.i32_const(1),
              c.i32_sub(
                c.getLocal("p"),
                c.i32_const(1)
              )
            )
          ),
          c.setLocal("it1", c.getLocal("pTable")),
          c.setLocal(
            "it2",
            c.i32_add(
              c.getLocal("pTable"),
              c.i32_mul(
                c.getLocal("half"),
                c.i32_const(n8g)
              )
            )
          ),
          c.setLocal(
            "pAcc",
            c.i32_sub(
              c.getLocal("it2"),
              c.i32_const(n8g)
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("it1"),
                c.getLocal("pAcc")
              )
            ),
            c.call(
              prefix + "_add",
              c.getLocal("it1"),
              c.getLocal("it2"),
              c.getLocal("it1")
            ),
            c.call(
              prefix + "_add",
              c.getLocal("pAcc"),
              c.getLocal("it2"),
              c.getLocal("pAcc")
            ),
            c.setLocal("it1", c.i32_add(c.getLocal("it1"), c.i32_const(n8g))),
            c.setLocal("it2", c.i32_add(c.getLocal("it2"), c.i32_const(n8g))),
            c.br(0)
          )),
          c.call(
            fnName + "_reduceTable",
            c.getLocal("pTable"),
            c.i32_sub(
              c.getLocal("p"),
              c.i32_const(1)
            )
          ),
          c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
          c.block(c.loop(
            c.br_if(1, c.i32_eqz(c.getLocal("p"))),
            c.call(prefix + "_double", c.getLocal("pAcc"), c.getLocal("pAcc")),
            c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
            c.br(0)
          )),
          c.call(prefix + "_add", c.getLocal("pTable"), c.getLocal("pAcc"), c.getLocal("pTable"))
        );
      }
      buildGetChunk();
      buildReduceTable();
      buildMutiexpChunk();
      buildMultiexp5();
      module3.exportFunction(fnName);
      module3.exportFunction(fnName + "_chunk");
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_curve_jacobian_a0.js
var require_build_curve_jacobian_a0 = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_curve_jacobian_a0.js"(exports, module2) {
    "use strict";
    var buildTimesScalarNAF = require_build_timesscalarnaf();
    var buildBatchConvertion = require_build_batchconvertion();
    var buildMultiexp4 = require_build_multiexp();
    module2.exports = function buildCurve(module3, prefix, prefixField, pB) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      if (module3.modules[prefix])
        return prefix;
      module3.modules[prefix] = {
        n64: n64 * 3
      };
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("p1", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_isZero",
          c.i32_add(
            c.getLocal("p1"),
            c.i32_const(n8 * 2)
          )
        ));
      }
      function buildIsZeroAffine() {
        const f = module3.addFunction(prefix + "_isZeroAffine");
        f.addParam("p1", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.i32_and(
            c.call(
              prefixField + "_isZero",
              c.getLocal("p1")
            ),
            c.call(
              prefixField + "_isZero",
              c.i32_add(
                c.getLocal("p1"),
                c.i32_const(n8)
              )
            )
          )
        );
      }
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("ps", "i32");
        f.addParam("pd", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64 * 3; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pd"),
              i * 8,
              c.i64_load(
                c.getLocal("ps"),
                i * 8
              )
            )
          );
        }
      }
      function buildCopyAffine() {
        const f = module3.addFunction(prefix + "_copyAffine");
        f.addParam("ps", "i32");
        f.addParam("pd", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64 * 2; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pd"),
              i * 8,
              c.i64_load(
                c.getLocal("ps"),
                i * 8
              )
            )
          );
        }
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_zero",
          c.getLocal("pr")
        ));
        f.addCode(c.call(
          prefixField + "_one",
          c.i32_add(
            c.getLocal("pr"),
            c.i32_const(n8)
          )
        ));
        f.addCode(c.call(
          prefixField + "_zero",
          c.i32_add(
            c.getLocal("pr"),
            c.i32_const(n8 * 2)
          )
        ));
      }
      function buildZeroAffine() {
        const f = module3.addFunction(prefix + "_zeroAffine");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_zero",
          c.getLocal("pr")
        ));
        f.addCode(c.call(
          prefixField + "_zero",
          c.i32_add(
            c.getLocal("pr"),
            c.i32_const(n8)
          )
        ));
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");
        f.addLocal("z2", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        f.addCode(c.setLocal("z2", c.i32_add(c.getLocal("p2"), c.i32_const(n8 * 2))));
        const z2 = c.getLocal("z2");
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const Z2Z2 = c.i32_const(module3.alloc(n8));
        const U1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const Z2_cubed = c.i32_const(module3.alloc(n8));
        const S1 = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            c.ret(c.call(prefix + "_isZero", c.getLocal("p2")))
          ),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p2")),
            c.ret(c.i32_const(0))
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            c.ret(c.call(prefix + "_eqMixed", c.getLocal("p2"), c.getLocal("p1")))
          ),
          c.if(
            c.call(prefixField + "_isOne", z2),
            c.ret(c.call(prefix + "_eqMixed", c.getLocal("p1"), c.getLocal("p2")))
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_square", z2, Z2Z2),
          c.call(prefixField + "_mul", x1, Z2Z2, U1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
          c.call(prefixField + "_mul", y1, Z2_cubed, S1),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", U1, U2),
            c.if(
              c.call(prefixField + "_eq", S1, S2),
              c.ret(c.i32_const(1))
            )
          ),
          c.ret(c.i32_const(0))
        );
      }
      function buildEqMixed() {
        const f = module3.addFunction(prefix + "_eqMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            c.ret(c.call(prefix + "_isZeroAffine", c.getLocal("p2")))
          ),
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
            c.ret(c.i32_const(0))
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            c.ret(c.call(prefix + "_eqAffine", c.getLocal("p1"), c.getLocal("p2")))
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", x1, U2),
            c.if(
              c.call(prefixField + "_eq", y1, S2),
              c.ret(c.i32_const(1))
            )
          ),
          c.ret(c.i32_const(0))
        );
      }
      function buildDouble() {
        const f = module3.addFunction(prefix + "_double");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const A = c.i32_const(module3.alloc(n8));
        const B = c.i32_const(module3.alloc(n8));
        const C = c.i32_const(module3.alloc(n8));
        const D = c.i32_const(module3.alloc(n8));
        const E = c.i32_const(module3.alloc(n8));
        const F = c.i32_const(module3.alloc(n8));
        const G = c.i32_const(module3.alloc(n8));
        const eightC = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z),
            [
              ...c.ret(c.call(prefix + "_doubleAffine", c.getLocal("p1"), c.getLocal("pr"))),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_square", x, A),
          c.call(prefixField + "_square", y, B),
          c.call(prefixField + "_square", B, C),
          c.call(prefixField + "_add", x, B, D),
          c.call(prefixField + "_square", D, D),
          c.call(prefixField + "_sub", D, A, D),
          c.call(prefixField + "_sub", D, C, D),
          c.call(prefixField + "_add", D, D, D),
          c.call(prefixField + "_add", A, A, E),
          c.call(prefixField + "_add", E, A, E),
          c.call(prefixField + "_square", E, F),
          c.call(prefixField + "_mul", y, z, G),
          c.call(prefixField + "_add", D, D, x3),
          c.call(prefixField + "_sub", F, x3, x3),
          c.call(prefixField + "_add", C, C, eightC),
          c.call(prefixField + "_add", eightC, eightC, eightC),
          c.call(prefixField + "_add", eightC, eightC, eightC),
          c.call(prefixField + "_sub", D, x3, y3),
          c.call(prefixField + "_mul", y3, E, y3),
          c.call(prefixField + "_sub", y3, eightC, y3),
          c.call(prefixField + "_add", G, G, z3)
        );
      }
      function buildDoubleAffine() {
        const f = module3.addFunction(prefix + "_doubleAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const XX = c.i32_const(module3.alloc(n8));
        const YY = c.i32_const(module3.alloc(n8));
        const YYYY = c.i32_const(module3.alloc(n8));
        const S = c.i32_const(module3.alloc(n8));
        const M = c.i32_const(module3.alloc(n8));
        const eightYYYY = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p1")),
            [
              ...c.call(prefix + "_toJacobian", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          // XX = X1^2
          c.call(prefixField + "_square", x, XX),
          // YY = Y1^2
          c.call(prefixField + "_square", y, YY),
          // YYYY = YY^2
          c.call(prefixField + "_square", YY, YYYY),
          // S = 2*((X1+YY)^2-XX-YYYY)
          c.call(prefixField + "_add", x, YY, S),
          c.call(prefixField + "_square", S, S),
          c.call(prefixField + "_sub", S, XX, S),
          c.call(prefixField + "_sub", S, YYYY, S),
          c.call(prefixField + "_add", S, S, S),
          // M = 3*XX+a  (Hera a=0)
          c.call(prefixField + "_add", XX, XX, M),
          c.call(prefixField + "_add", M, XX, M),
          // Z3 = 2*Y1
          c.call(prefixField + "_add", y, y, z3),
          // T = M^2-2*S
          // X3 = T
          c.call(prefixField + "_square", M, x3),
          c.call(prefixField + "_sub", x3, S, x3),
          c.call(prefixField + "_sub", x3, S, x3),
          // Y3 = M*(S-T)-8*YYYY
          c.call(prefixField + "_add", YYYY, YYYY, eightYYYY),
          c.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
          c.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
          c.call(prefixField + "_sub", S, x3, y3),
          c.call(prefixField + "_mul", y3, M, y3),
          c.call(prefixField + "_sub", y3, eightYYYY, y3)
        );
      }
      function buildEqAffine() {
        const f = module3.addFunction(prefix + "_eqAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.ret(c.i32_and(
            c.call(
              prefixField + "_eq",
              c.getLocal("p1"),
              c.getLocal("p2")
            ),
            c.call(
              prefixField + "_eq",
              c.i32_add(c.getLocal("p1"), c.i32_const(n8)),
              c.i32_add(c.getLocal("p2"), c.i32_const(n8))
            )
          ))
        );
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_toMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 3; i++) {
          f.addCode(c.call(
            prefixField + "_toMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildToMontgomeryAffine() {
        const f = module3.addFunction(prefix + "_toMontgomeryAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_toMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 2; i++) {
          f.addCode(c.call(
            prefixField + "_toMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildFromMontgomery() {
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_fromMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 3; i++) {
          f.addCode(c.call(
            prefixField + "_fromMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildFromMontgomeryAffine() {
        const f = module3.addFunction(prefix + "_fromMontgomeryAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_fromMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 2; i++) {
          f.addCode(c.call(
            prefixField + "_fromMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");
        f.addLocal("z2", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        f.addCode(c.setLocal("z2", c.i32_add(c.getLocal("p2"), c.i32_const(n8 * 2))));
        const z2 = c.getLocal("z2");
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const Z2Z2 = c.i32_const(module3.alloc(n8));
        const U1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const Z2_cubed = c.i32_const(module3.alloc(n8));
        const S1 = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        const H = c.i32_const(module3.alloc(n8));
        const S2_minus_S1 = c.i32_const(module3.alloc(n8));
        const I = c.i32_const(module3.alloc(n8));
        const J = c.i32_const(module3.alloc(n8));
        const r = c.i32_const(module3.alloc(n8));
        const r2 = c.i32_const(module3.alloc(n8));
        const V = c.i32_const(module3.alloc(n8));
        const V2 = c.i32_const(module3.alloc(n8));
        const S1_J2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p2"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p2")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            [
              ...c.call(prefix + "_addMixed", x2, x1, x3),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z2),
            [
              ...c.call(prefix + "_addMixed", x1, x2, x3),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_square", z2, Z2Z2),
          c.call(prefixField + "_mul", x1, Z2Z2, U1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
          c.call(prefixField + "_mul", y1, Z2_cubed, S1),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", U1, U2),
            c.if(
              c.call(prefixField + "_eq", S1, S2),
              [
                ...c.call(prefix + "_double", c.getLocal("p1"), c.getLocal("pr")),
                ...c.ret([])
              ]
            )
          ),
          c.call(prefixField + "_sub", U2, U1, H),
          c.call(prefixField + "_sub", S2, S1, S2_minus_S1),
          c.call(prefixField + "_add", H, H, I),
          c.call(prefixField + "_square", I, I),
          c.call(prefixField + "_mul", H, I, J),
          c.call(prefixField + "_add", S2_minus_S1, S2_minus_S1, r),
          c.call(prefixField + "_mul", U1, I, V),
          c.call(prefixField + "_square", r, r2),
          c.call(prefixField + "_add", V, V, V2),
          c.call(prefixField + "_sub", r2, J, x3),
          c.call(prefixField + "_sub", x3, V2, x3),
          c.call(prefixField + "_mul", S1, J, S1_J2),
          c.call(prefixField + "_add", S1_J2, S1_J2, S1_J2),
          c.call(prefixField + "_sub", V, x3, y3),
          c.call(prefixField + "_mul", y3, r, y3),
          c.call(prefixField + "_sub", y3, S1_J2, y3),
          c.call(prefixField + "_add", z1, z2, z3),
          c.call(prefixField + "_square", z3, z3),
          c.call(prefixField + "_sub", z3, Z1Z1, z3),
          c.call(prefixField + "_sub", z3, Z2Z2, z3),
          c.call(prefixField + "_mul", z3, H, z3)
        );
      }
      function buildAddMixed() {
        const f = module3.addFunction(prefix + "_addMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        const H = c.i32_const(module3.alloc(n8));
        const HH = c.i32_const(module3.alloc(n8));
        const S2_minus_y1 = c.i32_const(module3.alloc(n8));
        const I = c.i32_const(module3.alloc(n8));
        const J = c.i32_const(module3.alloc(n8));
        const r = c.i32_const(module3.alloc(n8));
        const r2 = c.i32_const(module3.alloc(n8));
        const V = c.i32_const(module3.alloc(n8));
        const V2 = c.i32_const(module3.alloc(n8));
        const y1_J2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copyAffine", c.getLocal("p2"), c.getLocal("pr")),
              ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            [
              ...c.call(prefix + "_addAffine", x1, x2, x3),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", x1, U2),
            c.if(
              c.call(prefixField + "_eq", y1, S2),
              [
                ...c.call(prefix + "_doubleAffine", c.getLocal("p2"), c.getLocal("pr")),
                ...c.ret([])
              ]
            )
          ),
          c.call(prefixField + "_sub", U2, x1, H),
          c.call(prefixField + "_sub", S2, y1, S2_minus_y1),
          c.call(prefixField + "_square", H, HH),
          c.call(prefixField + "_add", HH, HH, I),
          c.call(prefixField + "_add", I, I, I),
          c.call(prefixField + "_mul", H, I, J),
          c.call(prefixField + "_add", S2_minus_y1, S2_minus_y1, r),
          c.call(prefixField + "_mul", x1, I, V),
          c.call(prefixField + "_square", r, r2),
          c.call(prefixField + "_add", V, V, V2),
          c.call(prefixField + "_sub", r2, J, x3),
          c.call(prefixField + "_sub", x3, V2, x3),
          c.call(prefixField + "_mul", y1, J, y1_J2),
          c.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
          c.call(prefixField + "_sub", V, x3, y3),
          c.call(prefixField + "_mul", y3, r, y3),
          c.call(prefixField + "_sub", y3, y1_J2, y3),
          c.call(prefixField + "_add", z1, H, z3),
          c.call(prefixField + "_square", z3, z3),
          c.call(prefixField + "_sub", z3, Z1Z1, z3),
          c.call(prefixField + "_sub", z3, HH, z3)
        );
      }
      function buildAddAffine() {
        const f = module3.addFunction(prefix + "_addAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const H = c.i32_const(module3.alloc(n8));
        const HH = c.i32_const(module3.alloc(n8));
        const y2_minus_y1 = c.i32_const(module3.alloc(n8));
        const I = c.i32_const(module3.alloc(n8));
        const J = c.i32_const(module3.alloc(n8));
        const r = c.i32_const(module3.alloc(n8));
        const r2 = c.i32_const(module3.alloc(n8));
        const V = c.i32_const(module3.alloc(n8));
        const V2 = c.i32_const(module3.alloc(n8));
        const y1_J2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copyAffine", c.getLocal("p2"), c.getLocal("pr")),
              ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
            [
              ...c.call(prefix + "_copyAffine", c.getLocal("p1"), c.getLocal("pr")),
              ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_eq", x1, x2),
            c.if(
              c.call(prefixField + "_eq", y1, y2),
              [
                ...c.call(prefix + "_doubleAffine", c.getLocal("p2"), c.getLocal("pr")),
                ...c.ret([])
              ]
            )
          ),
          c.call(prefixField + "_sub", x2, x1, H),
          c.call(prefixField + "_sub", y2, y1, y2_minus_y1),
          c.call(prefixField + "_square", H, HH),
          c.call(prefixField + "_add", HH, HH, I),
          c.call(prefixField + "_add", I, I, I),
          c.call(prefixField + "_mul", H, I, J),
          c.call(prefixField + "_add", y2_minus_y1, y2_minus_y1, r),
          c.call(prefixField + "_mul", x1, I, V),
          c.call(prefixField + "_square", r, r2),
          c.call(prefixField + "_add", V, V, V2),
          c.call(prefixField + "_sub", r2, J, x3),
          c.call(prefixField + "_sub", x3, V2, x3),
          c.call(prefixField + "_mul", y1, J, y1_J2),
          c.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
          c.call(prefixField + "_sub", V, x3, y3),
          c.call(prefixField + "_mul", y3, r, y3),
          c.call(prefixField + "_sub", y3, y1_J2, y3),
          c.call(prefixField + "_add", H, H, z3)
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        f.addCode(
          c.call(prefixField + "_copy", x, x3),
          c.call(prefixField + "_neg", y, y3),
          c.call(prefixField + "_copy", z, z3)
        );
      }
      function buildNegAffine() {
        const f = module3.addFunction(prefix + "_negAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        f.addCode(
          c.call(prefixField + "_copy", x, x3),
          c.call(prefixField + "_neg", y, y3)
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8 * 3));
        f.addCode(
          c.call(prefix + "_neg", c.getLocal("p2"), AUX),
          c.call(prefix + "_add", c.getLocal("p1"), AUX, c.getLocal("pr"))
        );
      }
      function buildSubMixed() {
        const f = module3.addFunction(prefix + "_subMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8 * 3));
        f.addCode(
          c.call(prefix + "_negAffine", c.getLocal("p2"), AUX),
          c.call(prefix + "_addMixed", c.getLocal("p1"), AUX, c.getLocal("pr"))
        );
      }
      function buildSubAffine() {
        const f = module3.addFunction(prefix + "_subAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8 * 3));
        f.addCode(
          c.call(prefix + "_negAffine", c.getLocal("p2"), AUX),
          c.call(prefix + "_addAffine", c.getLocal("p1"), AUX, c.getLocal("pr"))
        );
      }
      function buildNormalize() {
        const f = module3.addFunction(prefix + "_normalize");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const Z_inv = c.i32_const(module3.alloc(n8));
        const Z2_inv = c.i32_const(module3.alloc(n8));
        const Z3_inv = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            c.call(prefix + "_zero", c.getLocal("pr")),
            [
              ...c.call(prefixField + "_inverse", z, Z_inv),
              ...c.call(prefixField + "_square", Z_inv, Z2_inv),
              ...c.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
              ...c.call(prefixField + "_mul", x, Z2_inv, x3),
              ...c.call(prefixField + "_mul", y, Z3_inv, y3),
              ...c.call(prefixField + "_one", z3)
            ]
          )
        );
      }
      function buildToAffine() {
        const f = module3.addFunction(prefix + "_toAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const Z_inv = c.i32_const(module3.alloc(n8));
        const Z2_inv = c.i32_const(module3.alloc(n8));
        const Z3_inv = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefixField + "_zero", x3),
              ...c.call(prefixField + "_zero", y3)
            ],
            [
              ...c.call(prefixField + "_inverse", z, Z_inv),
              ...c.call(prefixField + "_square", Z_inv, Z2_inv),
              ...c.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
              ...c.call(prefixField + "_mul", x, Z2_inv, x3),
              ...c.call(prefixField + "_mul", y, Z3_inv, y3)
            ]
          )
        );
      }
      function buildToJacobian() {
        const f = module3.addFunction(prefix + "_toJacobian");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p1")),
            c.call(prefix + "_zero", c.getLocal("pr")),
            [
              ...c.call(prefixField + "_one", z3),
              ...c.call(prefixField + "_copy", y, y3),
              ...c.call(prefixField + "_copy", x, x3)
            ]
          )
        );
      }
      function buildBatchToAffine() {
        const f = module3.addFunction(prefix + "_batchToAffine");
        f.addParam("pIn", "i32");
        f.addParam("n", "i32");
        f.addParam("pOut", "i32");
        f.addLocal("pAux", "i32");
        f.addLocal("itIn", "i32");
        f.addLocal("itAux", "i32");
        f.addLocal("itOut", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const tmp = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("pAux", c.i32_load(c.i32_const(0))),
          c.i32_store(
            c.i32_const(0),
            c.i32_add(
              c.getLocal("pAux"),
              c.i32_mul(c.getLocal("n"), c.i32_const(n8))
            )
          ),
          c.call(
            prefixField + "_batchInverse",
            c.i32_add(c.getLocal("pIn"), c.i32_const(n8 * 2)),
            c.i32_const(n8 * 3),
            c.getLocal("n"),
            c.getLocal("pAux"),
            c.i32_const(n8)
          ),
          c.setLocal("itIn", c.getLocal("pIn")),
          c.setLocal("itAux", c.getLocal("pAux")),
          c.setLocal("itOut", c.getLocal("pOut")),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.if(
              c.call(prefixField + "_isZero", c.getLocal("itAux")),
              [
                ...c.call(prefixField + "_zero", c.getLocal("itOut")),
                ...c.call(prefixField + "_zero", c.i32_add(c.getLocal("itOut"), c.i32_const(n8)))
              ],
              [
                ...c.call(
                  prefixField + "_mul",
                  c.getLocal("itAux"),
                  c.i32_add(c.getLocal("itIn"), c.i32_const(n8)),
                  tmp
                ),
                ...c.call(
                  prefixField + "_square",
                  c.getLocal("itAux"),
                  c.getLocal("itAux")
                ),
                ...c.call(
                  prefixField + "_mul",
                  c.getLocal("itAux"),
                  c.getLocal("itIn"),
                  c.getLocal("itOut")
                ),
                ...c.call(
                  prefixField + "_mul",
                  c.getLocal("itAux"),
                  tmp,
                  c.i32_add(c.getLocal("itOut"), c.i32_const(n8))
                )
              ]
            ),
            c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.i32_const(n8 * 3))),
            c.setLocal("itOut", c.i32_add(c.getLocal("itOut"), c.i32_const(n8 * 2))),
            c.setLocal("itAux", c.i32_add(c.getLocal("itAux"), c.i32_const(n8))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          )),
          c.i32_store(
            c.i32_const(0),
            c.getLocal("pAux")
          )
        );
      }
      function buildReverseBytes() {
        const f = module3.addFunction(prefix + "__reverseBytes");
        f.addParam("pIn", "i32");
        f.addParam("n", "i32");
        f.addParam("pOut", "i32");
        f.addLocal("itOut", "i32");
        f.addLocal("itIn", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "itOut",
            c.i32_sub(
              c.i32_add(
                c.getLocal("pOut"),
                c.getLocal("n")
              ),
              c.i32_const(1)
            )
          ),
          c.setLocal(
            "itIn",
            c.getLocal("pIn")
          ),
          c.block(c.loop(
            c.br_if(1, c.i32_lt_s(c.getLocal("itOut"), c.getLocal("pOut"))),
            c.i32_store8(
              c.getLocal("itOut"),
              c.i32_load8_u(c.getLocal("itIn"))
            ),
            c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.i32_const(1))),
            c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildLEMtoC() {
        const f = module3.addFunction(prefix + "_LEMtoC");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        const c = f.getCodeBuilder();
        const tmp = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("pIn")),
            [
              ...c.call(prefixField + "_zero", c.getLocal("pOut")),
              ...c.i32_store8(
                c.getLocal("pOut"),
                c.i32_const(64)
              ),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_fromMontgomery", c.getLocal("pIn"), tmp),
          c.call(prefix + "__reverseBytes", tmp, c.i32_const(n8), c.getLocal("pOut")),
          c.if(
            c.i32_eq(
              c.call(prefixField + "_sign", c.i32_add(c.getLocal("pIn"), c.i32_const(n8))),
              c.i32_const(-1)
            ),
            c.i32_store8(
              c.getLocal("pOut"),
              c.i32_or(
                c.i32_load8_u(c.getLocal("pOut")),
                c.i32_const(128)
              )
            )
          )
        );
      }
      function buildLEMtoU() {
        const f = module3.addFunction(prefix + "_LEMtoU");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        const c = f.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmp = c.i32_const(pTmp);
        const tmpX = c.i32_const(pTmp);
        const tmpY = c.i32_const(pTmp + n8);
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("pIn")),
            [
              ...c.call(prefix + "_zeroAffine", c.getLocal("pOut")),
              ...c.ret([])
            ]
          ),
          c.call(prefix + "_fromMontgomeryAffine", c.getLocal("pIn"), tmp),
          c.call(prefix + "__reverseBytes", tmpX, c.i32_const(n8), c.getLocal("pOut")),
          c.call(prefix + "__reverseBytes", tmpY, c.i32_const(n8), c.i32_add(c.getLocal("pOut"), c.i32_const(n8)))
        );
      }
      function buildUtoLEM() {
        const f = module3.addFunction(prefix + "_UtoLEM");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        const c = f.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmp = c.i32_const(pTmp);
        const tmpX = c.i32_const(pTmp);
        const tmpY = c.i32_const(pTmp + n8);
        f.addCode(
          c.if(
            c.i32_and(c.i32_load8_u(c.getLocal("pIn")), c.i32_const(64)),
            [
              ...c.call(prefix + "_zeroAffine", c.getLocal("pOut")),
              ...c.ret([])
            ]
          ),
          c.call(prefix + "__reverseBytes", c.getLocal("pIn"), c.i32_const(n8), tmpX),
          c.call(prefix + "__reverseBytes", c.i32_add(c.getLocal("pIn"), c.i32_const(n8)), c.i32_const(n8), tmpY),
          c.call(prefix + "_toMontgomeryAffine", tmp, c.getLocal("pOut"))
        );
      }
      function buildCtoLEM() {
        const f = module3.addFunction(prefix + "_CtoLEM");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        f.addLocal("firstByte", "i32");
        f.addLocal("greatest", "i32");
        const c = f.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmpX = c.i32_const(pTmp);
        const tmpY = c.i32_const(pTmp + n8);
        f.addCode(
          c.setLocal("firstByte", c.i32_load8_u(c.getLocal("pIn"))),
          c.if(
            c.i32_and(
              c.getLocal("firstByte"),
              c.i32_const(64)
            ),
            [
              ...c.call(prefix + "_zeroAffine", c.getLocal("pOut")),
              ...c.ret([])
            ]
          ),
          c.setLocal(
            "greatest",
            c.i32_and(
              c.getLocal("firstByte"),
              c.i32_const(128)
            )
          ),
          c.call(prefixField + "_copy", c.getLocal("pIn"), tmpY),
          c.i32_store8(tmpY, c.i32_and(c.getLocal("firstByte"), c.i32_const(63))),
          c.call(prefix + "__reverseBytes", tmpY, c.i32_const(n8), tmpX),
          c.call(prefixField + "_toMontgomery", tmpX, c.getLocal("pOut")),
          c.call(prefixField + "_square", c.getLocal("pOut"), tmpY),
          c.call(prefixField + "_mul", c.getLocal("pOut"), tmpY, tmpY),
          c.call(prefixField + "_add", tmpY, c.i32_const(pB), tmpY),
          c.call(prefixField + "_sqrt", tmpY, tmpY),
          c.call(prefixField + "_neg", tmpY, tmpX),
          c.if(
            c.i32_eq(
              c.call(prefixField + "_sign", tmpY),
              c.i32_const(-1)
            ),
            c.if(
              c.getLocal("greatest"),
              c.call(prefixField + "_copy", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8))),
              c.call(prefixField + "_neg", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8)))
            ),
            c.if(
              c.getLocal("greatest"),
              c.call(prefixField + "_neg", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8))),
              c.call(prefixField + "_copy", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8)))
            )
          )
        );
      }
      function buildInCurveAffine() {
        const f = module3.addFunction(prefix + "_inCurveAffine");
        f.addParam("pIn", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("pIn");
        const y = c.i32_add(c.getLocal("pIn"), c.i32_const(n8));
        const y2 = c.i32_const(module3.alloc(n8));
        const x3b = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call(prefixField + "_square", y, y2),
          c.call(prefixField + "_square", x, x3b),
          c.call(prefixField + "_mul", x, x3b, x3b),
          c.call(prefixField + "_add", x3b, c.i32_const(pB), x3b),
          c.ret(
            c.call(prefixField + "_eq", y2, x3b)
          )
        );
      }
      function buildInCurve() {
        const f = module3.addFunction(prefix + "_inCurve");
        f.addParam("pIn", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8 * 2));
        f.addCode(
          c.call(prefix + "_toAffine", c.getLocal("pIn"), aux),
          c.ret(
            c.call(prefix + "_inCurveAffine", aux)
          )
        );
      }
      buildIsZeroAffine();
      buildIsZero();
      buildZeroAffine();
      buildZero();
      buildCopyAffine();
      buildCopy();
      buildToJacobian();
      buildEqAffine();
      buildEqMixed();
      buildEq();
      buildDoubleAffine();
      buildDouble();
      buildAddAffine();
      buildAddMixed();
      buildAdd();
      buildNegAffine();
      buildNeg();
      buildSubAffine();
      buildSubMixed();
      buildSub();
      buildFromMontgomeryAffine();
      buildFromMontgomery();
      buildToMontgomeryAffine();
      buildToMontgomery();
      buildToAffine();
      buildInCurveAffine();
      buildInCurve();
      buildBatchToAffine();
      buildNormalize();
      buildReverseBytes();
      buildLEMtoU();
      buildLEMtoC();
      buildUtoLEM();
      buildCtoLEM();
      buildBatchConvertion(module3, prefix + "_batchLEMtoU", prefix + "_LEMtoU", n8 * 2, n8 * 2);
      buildBatchConvertion(module3, prefix + "_batchLEMtoC", prefix + "_LEMtoC", n8 * 2, n8);
      buildBatchConvertion(module3, prefix + "_batchUtoLEM", prefix + "_UtoLEM", n8 * 2, n8 * 2);
      buildBatchConvertion(module3, prefix + "_batchCtoLEM", prefix + "_CtoLEM", n8, n8 * 2, true);
      buildBatchConvertion(module3, prefix + "_batchToJacobian", prefix + "_toJacobian", n8 * 2, n8 * 3, true);
      buildMultiexp4(module3, prefix, prefix + "_multiexp", prefix + "_add", n8 * 3);
      buildMultiexp4(module3, prefix, prefix + "_multiexpAffine", prefix + "_addMixed", n8 * 2);
      buildTimesScalarNAF(
        module3,
        prefix + "_timesScalar",
        n8 * 3,
        prefix + "_add",
        prefix + "_double",
        prefix + "_sub",
        prefix + "_copy",
        prefix + "_zero"
      );
      buildTimesScalarNAF(
        module3,
        prefix + "_timesScalarAffine",
        n8 * 2,
        prefix + "_addMixed",
        prefix + "_double",
        prefix + "_subMixed",
        prefix + "_copyAffine",
        prefix + "_zero"
      );
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isZeroAffine");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_eqMixed");
      module3.exportFunction(prefix + "_eqAffine");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_copyAffine");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_zeroAffine");
      module3.exportFunction(prefix + "_double");
      module3.exportFunction(prefix + "_doubleAffine");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_addMixed");
      module3.exportFunction(prefix + "_addAffine");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_negAffine");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_subMixed");
      module3.exportFunction(prefix + "_subAffine");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_fromMontgomeryAffine");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_toMontgomeryAffine");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_timesScalarAffine");
      module3.exportFunction(prefix + "_normalize");
      module3.exportFunction(prefix + "_LEMtoU");
      module3.exportFunction(prefix + "_LEMtoC");
      module3.exportFunction(prefix + "_UtoLEM");
      module3.exportFunction(prefix + "_CtoLEM");
      module3.exportFunction(prefix + "_batchLEMtoU");
      module3.exportFunction(prefix + "_batchLEMtoC");
      module3.exportFunction(prefix + "_batchUtoLEM");
      module3.exportFunction(prefix + "_batchCtoLEM");
      module3.exportFunction(prefix + "_toAffine");
      module3.exportFunction(prefix + "_toJacobian");
      module3.exportFunction(prefix + "_batchToAffine");
      module3.exportFunction(prefix + "_batchToJacobian");
      module3.exportFunction(prefix + "_inCurve");
      module3.exportFunction(prefix + "_inCurveAffine");
      return prefix;
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_fft.js
var require_build_fft = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_fft.js"(exports, module2) {
    "use strict";
    var { isOdd: isOdd4, modInv, modPow } = require_bigint();
    var utils2 = require_utils();
    module2.exports = function buildFFT4(module3, prefix, gPrefix, fPrefix, opGtimesF) {
      const n64f = module3.modules[fPrefix].n64;
      const n8f = n64f * 8;
      const n64g = module3.modules[gPrefix].n64;
      const n8g = n64g * 8;
      const q = module3.modules[fPrefix].q;
      let rem = q - 1n;
      let maxBits = 0;
      while (!isOdd4(rem)) {
        maxBits++;
        rem = rem >> 1n;
      }
      let nr = 2n;
      while (modPow(nr, q >> 1n, q) === 1n)
        nr = nr + 1n;
      const w = new Array(maxBits + 1);
      w[maxBits] = modPow(nr, rem, q);
      let n = maxBits - 1;
      while (n >= 0) {
        w[n] = modPow(w[n + 1], 2n, q);
        n--;
      }
      const bytes = [];
      const R = (1n << BigInt(n8f * 8)) % q;
      for (let i = 0; i < w.length; i++) {
        const m = w[i] * R % q;
        bytes.push(...utils2.bigInt2BytesLE(m, n8f));
      }
      const ROOTs = module3.alloc(bytes);
      const i2 = new Array(maxBits + 1);
      i2[0] = 1n;
      for (let i = 1; i <= maxBits; i++) {
        i2[i] = i2[i - 1] * 2n;
      }
      const bytesi2 = [];
      for (let i = 0; i <= maxBits; i++) {
        const m = modInv(i2[i], q) * R % q;
        bytesi2.push(...utils2.bigInt2BytesLE(m, n8f));
      }
      const INV2 = module3.alloc(bytesi2);
      const shift = modPow(nr, 2n, q);
      const bytesShiftToSmallM = [];
      const bytesSConst = [];
      for (let i = 0; i <= maxBits; i++) {
        const shiftToSmallM = modPow(shift, 2n ** BigInt(i), q);
        const sConst = modInv(q + 1n - shiftToSmallM, q);
        bytesShiftToSmallM.push(...utils2.bigInt2BytesLE(shiftToSmallM * R % q, n8f));
        bytesSConst.push(...utils2.bigInt2BytesLE(sConst * R % q, n8f));
      }
      const SHIFT_TO_M = module3.alloc(bytesShiftToSmallM);
      const SCONST = module3.alloc(bytesSConst);
      function rev(x) {
        let r = 0;
        for (let i = 0; i < 8; i++) {
          if (x & 1 << i) {
            r = r | 128 >> i;
          }
        }
        return r;
      }
      const rtable = Array(256);
      for (let i = 0; i < 256; i++) {
        rtable[i] = rev(i);
      }
      const REVTABLE = module3.alloc(rtable);
      function buildLog2() {
        const f = module3.addFunction(prefix + "__log2");
        f.addParam("n", "i32");
        f.setReturnType("i32");
        f.addLocal("bits", "i32");
        f.addLocal("aux", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "aux",
            c.i32_shr_u(
              c.getLocal("n"),
              c.i32_const(1)
            )
          )
        );
        f.addCode(c.setLocal("bits", c.i32_const(0)));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.i32_eqz(c.getLocal("aux"))
          ),
          c.setLocal(
            "aux",
            c.i32_shr_u(
              c.getLocal("aux"),
              c.i32_const(1)
            )
          ),
          c.setLocal(
            "bits",
            c.i32_add(
              c.getLocal("bits"),
              c.i32_const(1)
            )
          ),
          c.br(0)
        )));
        f.addCode(c.if(
          c.i32_ne(
            c.getLocal("n"),
            c.i32_shl(
              c.i32_const(1),
              c.getLocal("bits")
            )
          ),
          c.unreachable()
        ));
        f.addCode(c.if(
          c.i32_gt_u(
            c.getLocal("bits"),
            c.i32_const(maxBits)
          ),
          c.unreachable()
        ));
        f.addCode(c.getLocal("bits"));
      }
      function buildFFT5() {
        const f = module3.addFunction(prefix + "_fft");
        f.addParam("px", "i32");
        f.addParam("n", "i32");
        f.addLocal("bits", "i32");
        const c = f.getCodeBuilder();
        const One = c.i32_const(module3.alloc(n8f));
        f.addCode(
          c.setLocal(
            "bits",
            c.call(
              prefix + "__log2",
              c.getLocal("n")
            )
          ),
          c.call(fPrefix + "_one", One),
          c.call(
            prefix + "_rawfft",
            c.getLocal("px"),
            c.getLocal("bits"),
            c.i32_const(0),
            One
          )
        );
      }
      function buildIFFT() {
        const f = module3.addFunction(prefix + "_ifft");
        f.addParam("px", "i32");
        f.addParam("n", "i32");
        f.addLocal("bits", "i32");
        f.addLocal("pInv2", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "bits",
            c.call(
              prefix + "__log2",
              c.getLocal("n")
            )
          ),
          c.setLocal(
            "pInv2",
            c.i32_add(
              c.i32_const(INV2),
              c.i32_mul(
                c.getLocal("bits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(
            prefix + "_rawfft",
            c.getLocal("px"),
            c.getLocal("bits"),
            c.i32_const(1),
            c.getLocal("pInv2")
          )
        );
      }
      function buildRawFFT() {
        const f = module3.addFunction(prefix + "_rawfft");
        f.addParam("px", "i32");
        f.addParam("bits", "i32");
        f.addParam("reverse", "i32");
        f.addParam("mulFactor", "i32");
        f.addLocal("s", "i32");
        f.addLocal("k", "i32");
        f.addLocal("j", "i32");
        f.addLocal("m", "i32");
        f.addLocal("mdiv2", "i32");
        f.addLocal("n", "i32");
        f.addLocal("pwm", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const T = c.i32_const(module3.alloc(n8g));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.call(prefix + "__reversePermutation", c.getLocal("px"), c.getLocal("bits")),
          c.setLocal("n", c.i32_shl(c.i32_const(1), c.getLocal("bits"))),
          c.setLocal("s", c.i32_const(1)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_gt_u(
                c.getLocal("s"),
                c.getLocal("bits")
              )
            ),
            c.setLocal("m", c.i32_shl(c.i32_const(1), c.getLocal("s"))),
            c.setLocal(
              "pwm",
              c.i32_add(
                c.i32_const(ROOTs),
                c.i32_mul(
                  c.getLocal("s"),
                  c.i32_const(n8f)
                )
              )
            ),
            c.setLocal("k", c.i32_const(0)),
            c.block(c.loop(
              c.br_if(
                1,
                c.i32_ge_u(
                  c.getLocal("k"),
                  c.getLocal("n")
                )
              ),
              c.call(fPrefix + "_one", W),
              c.setLocal("mdiv2", c.i32_shr_u(c.getLocal("m"), c.i32_const(1))),
              c.setLocal("j", c.i32_const(0)),
              c.block(c.loop(
                c.br_if(
                  1,
                  c.i32_ge_u(
                    c.getLocal("j"),
                    c.getLocal("mdiv2")
                  )
                ),
                c.setLocal(
                  "idx1",
                  c.i32_add(
                    c.getLocal("px"),
                    c.i32_mul(
                      c.i32_add(
                        c.getLocal("k"),
                        c.getLocal("j")
                      ),
                      c.i32_const(n8g)
                    )
                  )
                ),
                c.setLocal(
                  "idx2",
                  c.i32_add(
                    c.getLocal("idx1"),
                    c.i32_mul(
                      c.getLocal("mdiv2"),
                      c.i32_const(n8g)
                    )
                  )
                ),
                c.call(
                  opGtimesF,
                  c.getLocal("idx2"),
                  W,
                  T
                ),
                c.call(
                  gPrefix + "_copy",
                  c.getLocal("idx1"),
                  U
                ),
                c.call(
                  gPrefix + "_add",
                  U,
                  T,
                  c.getLocal("idx1")
                ),
                c.call(
                  gPrefix + "_sub",
                  U,
                  T,
                  c.getLocal("idx2")
                ),
                c.call(
                  fPrefix + "_mul",
                  W,
                  c.getLocal("pwm"),
                  W
                ),
                c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
                c.br(0)
              )),
              c.setLocal("k", c.i32_add(c.getLocal("k"), c.getLocal("m"))),
              c.br(0)
            )),
            c.setLocal("s", c.i32_add(c.getLocal("s"), c.i32_const(1))),
            c.br(0)
          )),
          c.call(
            prefix + "__fftFinal",
            c.getLocal("px"),
            c.getLocal("bits"),
            c.getLocal("reverse"),
            c.getLocal("mulFactor")
          )
        );
      }
      function buildFinalInverse() {
        const f = module3.addFunction(prefix + "__fftFinal");
        f.addParam("px", "i32");
        f.addParam("bits", "i32");
        f.addParam("reverse", "i32");
        f.addParam("mulFactor", "i32");
        f.addLocal("n", "i32");
        f.addLocal("ndiv2", "i32");
        f.addLocal("pInv2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("mask", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        const c = f.getCodeBuilder();
        const T = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.if(
            c.i32_and(
              c.i32_eqz(c.getLocal("reverse")),
              c.call(fPrefix + "_isOne", c.getLocal("mulFactor"))
            ),
            c.ret([])
          ),
          c.setLocal("n", c.i32_shl(c.i32_const(1), c.getLocal("bits"))),
          c.setLocal("mask", c.i32_sub(c.getLocal("n"), c.i32_const(1))),
          c.setLocal("i", c.i32_const(1)),
          c.setLocal(
            "ndiv2",
            c.i32_shr_u(
              c.getLocal("n"),
              c.i32_const(1)
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_ge_u(
                c.getLocal("i"),
                c.getLocal("ndiv2")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.i32_sub(
                    c.getLocal("n"),
                    c.getLocal("i")
                  ),
                  c.i32_const(n8g)
                )
              )
            ),
            c.if(
              c.getLocal("reverse"),
              c.if(
                c.call(fPrefix + "_isOne", c.getLocal("mulFactor")),
                [
                  ...c.call(gPrefix + "_copy", c.getLocal("idx1"), T),
                  ...c.call(gPrefix + "_copy", c.getLocal("idx2"), c.getLocal("idx1")),
                  ...c.call(gPrefix + "_copy", T, c.getLocal("idx2"))
                ],
                [
                  ...c.call(gPrefix + "_copy", c.getLocal("idx1"), T),
                  ...c.call(opGtimesF, c.getLocal("idx2"), c.getLocal("mulFactor"), c.getLocal("idx1")),
                  ...c.call(opGtimesF, T, c.getLocal("mulFactor"), c.getLocal("idx2"))
                ]
              ),
              c.if(
                c.call(fPrefix + "_isOne", c.getLocal("mulFactor")),
                [
                  // Do nothing (It should not be here)
                ],
                [
                  ...c.call(opGtimesF, c.getLocal("idx1"), c.getLocal("mulFactor"), c.getLocal("idx1")),
                  ...c.call(opGtimesF, c.getLocal("idx2"), c.getLocal("mulFactor"), c.getLocal("idx2"))
                ]
              )
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          )),
          c.if(
            c.call(fPrefix + "_isOne", c.getLocal("mulFactor")),
            [
              // Do nothing (It should not be here)
            ],
            [
              ...c.call(opGtimesF, c.getLocal("px"), c.getLocal("mulFactor"), c.getLocal("px")),
              ...c.setLocal(
                "idx2",
                c.i32_add(
                  c.getLocal("px"),
                  c.i32_mul(
                    c.getLocal("ndiv2"),
                    c.i32_const(n8g)
                  )
                )
              ),
              ...c.call(opGtimesF, c.getLocal("idx2"), c.getLocal("mulFactor"), c.getLocal("idx2"))
            ]
          )
        );
      }
      function buildReversePermutation() {
        const f = module3.addFunction(prefix + "__reversePermutation");
        f.addParam("px", "i32");
        f.addParam("bits", "i32");
        f.addLocal("n", "i32");
        f.addLocal("i", "i32");
        f.addLocal("ri", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        const c = f.getCodeBuilder();
        const T = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal("n", c.i32_shl(c.i32_const(1), c.getLocal("bits"))),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal("ri", c.call(prefix + "__rev", c.getLocal("i"), c.getLocal("bits"))),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.getLocal("ri"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.if(
              c.i32_lt_u(
                c.getLocal("i"),
                c.getLocal("ri")
              ),
              [
                ...c.call(gPrefix + "_copy", c.getLocal("idx1"), T),
                ...c.call(gPrefix + "_copy", c.getLocal("idx2"), c.getLocal("idx1")),
                ...c.call(gPrefix + "_copy", T, c.getLocal("idx2"))
              ]
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildRev() {
        const f = module3.addFunction(prefix + "__rev");
        f.addParam("x", "i32");
        f.addParam("bits", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.i32_rotl(
            c.i32_add(
              c.i32_add(
                c.i32_shl(
                  c.i32_load8_u(
                    c.i32_and(
                      c.getLocal("x"),
                      c.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c.i32_const(24)
                ),
                c.i32_shl(
                  c.i32_load8_u(
                    c.i32_and(
                      c.i32_shr_u(
                        c.getLocal("x"),
                        c.i32_const(8)
                      ),
                      c.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c.i32_const(16)
                )
              ),
              c.i32_add(
                c.i32_shl(
                  c.i32_load8_u(
                    c.i32_and(
                      c.i32_shr_u(
                        c.getLocal("x"),
                        c.i32_const(16)
                      ),
                      c.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c.i32_const(8)
                ),
                c.i32_load8_u(
                  c.i32_and(
                    c.i32_shr_u(
                      c.getLocal("x"),
                      c.i32_const(24)
                    ),
                    c.i32_const(255)
                  ),
                  REVTABLE,
                  0
                )
              )
            ),
            c.getLocal("bits")
          )
        );
      }
      function buildFFTJoin() {
        const f = module3.addFunction(prefix + "_fftJoin");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const T = c.i32_const(module3.alloc(n8g));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              T
            ),
            c.call(
              gPrefix + "_copy",
              c.getLocal("idx1"),
              U
            ),
            c.call(
              gPrefix + "_add",
              U,
              T,
              c.getLocal("idx1")
            ),
            c.call(
              gPrefix + "_sub",
              U,
              T,
              c.getLocal("idx2")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTJoinExt() {
        const f = module3.addFunction(prefix + "_fftJoinExt");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addParam("totalBits", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("pShiftToM", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal(
            "pShiftToM",
            c.i32_add(
              c.i32_const(SHIFT_TO_M),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              gPrefix + "_add",
              c.getLocal("idx1"),
              c.getLocal("idx2"),
              U
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              c.getLocal("pShiftToM"),
              c.getLocal("idx2")
            ),
            c.call(
              gPrefix + "_add",
              c.getLocal("idx1"),
              c.getLocal("idx2"),
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              c.getLocal("idx2")
            ),
            c.call(
              gPrefix + "_copy",
              U,
              c.getLocal("idx1")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTJoinExtInv() {
        const f = module3.addFunction(prefix + "_fftJoinExtInv");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addParam("totalBits", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("pShiftToM", "i32");
        f.addLocal("pSConst", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal(
            "pShiftToM",
            c.i32_add(
              c.i32_const(SHIFT_TO_M),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.setLocal(
            "pSConst",
            c.i32_add(
              c.i32_const(SCONST),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              U
            ),
            c.call(
              gPrefix + "_sub",
              c.getLocal("idx1"),
              U,
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              c.getLocal("pSConst"),
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("pShiftToM"),
              c.getLocal("idx1")
            ),
            c.call(
              gPrefix + "_sub",
              U,
              c.getLocal("idx1"),
              c.getLocal("idx1")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("pSConst"),
              c.getLocal("idx1")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildPrepareLagrangeEvaluation() {
        const f = module3.addFunction(prefix + "_prepareLagrangeEvaluation");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addParam("totalBits", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("pShiftToM", "i32");
        f.addLocal("pSConst", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal(
            "pShiftToM",
            c.i32_add(
              c.i32_const(SHIFT_TO_M),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.setLocal(
            "pSConst",
            c.i32_add(
              c.i32_const(SCONST),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("pShiftToM"),
              U
            ),
            c.call(
              gPrefix + "_sub",
              c.getLocal("idx2"),
              U,
              U
            ),
            c.call(
              gPrefix + "_sub",
              c.getLocal("idx1"),
              c.getLocal("idx2"),
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              U,
              c.getLocal("pSConst"),
              c.getLocal("idx1")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              c.getLocal("idx2")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTMix() {
        const f = module3.addFunction(prefix + "_fftMix");
        f.addParam("pBuff", "i32");
        f.addParam("n", "i32");
        f.addParam("exp", "i32");
        f.addLocal("nGroups", "i32");
        f.addLocal("nPerGroup", "i32");
        f.addLocal("nPerGroupDiv2", "i32");
        f.addLocal("pairOffset", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("pwm", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const T = c.i32_const(module3.alloc(n8g));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal("nPerGroup", c.i32_shl(c.i32_const(1), c.getLocal("exp"))),
          c.setLocal("nPerGroupDiv2", c.i32_shr_u(c.getLocal("nPerGroup"), c.i32_const(1))),
          c.setLocal("nGroups", c.i32_shr_u(c.getLocal("n"), c.getLocal("exp"))),
          c.setLocal("pairOffset", c.i32_mul(c.getLocal("nPerGroupDiv2"), c.i32_const(n8g))),
          c.setLocal(
            "pwm",
            c.i32_add(
              c.i32_const(ROOTs),
              c.i32_mul(
                c.getLocal("exp"),
                c.i32_const(n8f)
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("nGroups")
              )
            ),
            c.call(fPrefix + "_one", W),
            c.setLocal("j", c.i32_const(0)),
            c.block(c.loop(
              c.br_if(
                1,
                c.i32_eq(
                  c.getLocal("j"),
                  c.getLocal("nPerGroupDiv2")
                )
              ),
              c.setLocal(
                "idx1",
                c.i32_add(
                  c.getLocal("pBuff"),
                  c.i32_mul(
                    c.i32_add(
                      c.i32_mul(
                        c.getLocal("i"),
                        c.getLocal("nPerGroup")
                      ),
                      c.getLocal("j")
                    ),
                    c.i32_const(n8g)
                  )
                )
              ),
              c.setLocal(
                "idx2",
                c.i32_add(
                  c.getLocal("idx1"),
                  c.getLocal("pairOffset")
                )
              ),
              c.call(
                opGtimesF,
                c.getLocal("idx2"),
                W,
                T
              ),
              c.call(
                gPrefix + "_copy",
                c.getLocal("idx1"),
                U
              ),
              c.call(
                gPrefix + "_add",
                U,
                T,
                c.getLocal("idx1")
              ),
              c.call(
                gPrefix + "_sub",
                U,
                T,
                c.getLocal("idx2")
              ),
              c.call(
                fPrefix + "_mul",
                W,
                c.getLocal("pwm"),
                W
              ),
              c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
              c.br(0)
            )),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTFinal() {
        const f = module3.addFunction(prefix + "_fftFinal");
        f.addParam("pBuff", "i32");
        f.addParam("n", "i32");
        f.addParam("factor", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("ndiv2", "i32");
        const c = f.getCodeBuilder();
        const T = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal("ndiv2", c.i32_shr_u(c.getLocal("n"), c.i32_const(1))),
          c.if(
            c.i32_and(
              c.getLocal("n"),
              c.i32_const(1)
            ),
            c.call(
              opGtimesF,
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.getLocal("ndiv2"),
                  c.i32_const(n8g)
                )
              ),
              c.getLocal("factor"),
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.getLocal("ndiv2"),
                  c.i32_const(n8g)
                )
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_ge_u(
                c.getLocal("i"),
                c.getLocal("ndiv2")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.i32_sub(
                    c.i32_sub(
                      c.getLocal("n"),
                      c.i32_const(1)
                    ),
                    c.getLocal("i")
                  ),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              c.getLocal("factor"),
              T
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("factor"),
              c.getLocal("idx2")
            ),
            c.call(
              gPrefix + "_copy",
              T,
              c.getLocal("idx1")
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      buildRev();
      buildReversePermutation();
      buildFinalInverse();
      buildRawFFT();
      buildLog2();
      buildFFT5();
      buildIFFT();
      buildFFTJoin();
      buildFFTJoinExt();
      buildFFTJoinExtInv();
      buildFFTMix();
      buildFFTFinal();
      buildPrepareLagrangeEvaluation();
      module3.exportFunction(prefix + "_fft");
      module3.exportFunction(prefix + "_ifft");
      module3.exportFunction(prefix + "_rawfft");
      module3.exportFunction(prefix + "_fftJoin");
      module3.exportFunction(prefix + "_fftJoinExt");
      module3.exportFunction(prefix + "_fftJoinExtInv");
      module3.exportFunction(prefix + "_fftMix");
      module3.exportFunction(prefix + "_fftFinal");
      module3.exportFunction(prefix + "_prepareLagrangeEvaluation");
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_pol.js
var require_build_pol = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_pol.js"(exports, module2) {
    "use strict";
    module2.exports = function buildPol(module3, prefix, prefixField) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("px", "i32");
        f.addParam("n", "i32");
        f.addLocal("lastp", "i32");
        f.addLocal("p", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal("p", c.getLocal("px")),
          c.setLocal(
            "lastp",
            c.i32_add(
              c.getLocal("px"),
              c.i32_mul(
                c.getLocal("n"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("p"),
                c.getLocal("lastp")
              )
            ),
            c.call(prefixField + "_zero", c.getLocal("p")),
            c.setLocal("p", c.i32_add(c.getLocal("p"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      function buildConstructLC() {
        const f = module3.addFunction(prefix + "_constructLC");
        f.addParam("ppolynomials", "i32");
        f.addParam("psignals", "i32");
        f.addParam("nSignals", "i32");
        f.addParam("pres", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("pp", "i32");
        f.addLocal("ps", "i32");
        f.addLocal("pd", "i32");
        f.addLocal("ncoefs", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("i", c.i32_const(0)),
          c.setLocal("pp", c.getLocal("ppolynomials")),
          c.setLocal("ps", c.getLocal("psignals")),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("nSignals")
              )
            ),
            c.setLocal("ncoefs", c.i32_load(c.getLocal("pp"))),
            c.setLocal("pp", c.i32_add(c.getLocal("pp"), c.i32_const(4))),
            c.setLocal("j", c.i32_const(0)),
            c.block(c.loop(
              c.br_if(
                1,
                c.i32_eq(
                  c.getLocal("j"),
                  c.getLocal("ncoefs")
                )
              ),
              c.setLocal(
                "pd",
                c.i32_add(
                  c.getLocal("pres"),
                  c.i32_mul(
                    c.i32_load(c.getLocal("pp")),
                    c.i32_const(n8)
                  )
                )
              ),
              c.setLocal("pp", c.i32_add(c.getLocal("pp"), c.i32_const(4))),
              c.call(
                prefixField + "_mul",
                c.getLocal("ps"),
                c.getLocal("pp"),
                aux
              ),
              c.call(
                prefixField + "_add",
                aux,
                c.getLocal("pd"),
                c.getLocal("pd")
              ),
              c.setLocal("pp", c.i32_add(c.getLocal("pp"), c.i32_const(n8))),
              c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
              c.br(0)
            )),
            c.setLocal("ps", c.i32_add(c.getLocal("ps"), c.i32_const(n8))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      buildZero();
      buildConstructLC();
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_constructLC");
      return prefix;
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_qap.js
var require_build_qap = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_qap.js"(exports, module2) {
    "use strict";
    module2.exports = function buildQAP(module3, prefix, prefixField) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      function buildBuildABC() {
        const f = module3.addFunction(prefix + "_buildABC");
        f.addParam("pCoefs", "i32");
        f.addParam("nCoefs", "i32");
        f.addParam("pWitness", "i32");
        f.addParam("pA", "i32");
        f.addParam("pB", "i32");
        f.addParam("pC", "i32");
        f.addParam("offsetOut", "i32");
        f.addParam("nOut", "i32");
        f.addParam("offsetWitness", "i32");
        f.addParam("nWitness", "i32");
        f.addLocal("it", "i32");
        f.addLocal("ita", "i32");
        f.addLocal("itb", "i32");
        f.addLocal("last", "i32");
        f.addLocal("m", "i32");
        f.addLocal("c", "i32");
        f.addLocal("s", "i32");
        f.addLocal("pOut", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8));
        f.addCode(
          // Set output a and b to 0
          c.setLocal("ita", c.getLocal("pA")),
          c.setLocal("itb", c.getLocal("pB")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pA"),
              c.i32_mul(
                c.getLocal("nOut"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(prefixField + "_zero", c.getLocal("ita")),
            c.call(prefixField + "_zero", c.getLocal("itb")),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.br(0)
          )),
          c.setLocal("it", c.getLocal("pCoefs")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pCoefs"),
              c.i32_mul(
                c.getLocal("nCoefs"),
                c.i32_const(n8 + 12)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("it"),
                c.getLocal("last")
              )
            ),
            c.setLocal(
              "s",
              c.i32_load(c.getLocal("it"), 8)
            ),
            c.if(
              c.i32_or(
                c.i32_lt_u(
                  c.getLocal("s"),
                  c.getLocal("offsetWitness")
                ),
                c.i32_ge_u(
                  c.getLocal("s"),
                  c.i32_add(
                    c.getLocal("offsetWitness"),
                    c.getLocal("nWitness")
                  )
                )
              ),
              [
                ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
                ...c.br(1)
              ]
            ),
            c.setLocal(
              "m",
              c.i32_load(c.getLocal("it"))
            ),
            c.if(
              c.i32_eq(c.getLocal("m"), c.i32_const(0)),
              c.setLocal("pOut", c.getLocal("pA")),
              c.if(
                c.i32_eq(c.getLocal("m"), c.i32_const(1)),
                c.setLocal("pOut", c.getLocal("pB")),
                [
                  ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
                  ...c.br(1)
                ]
              )
            ),
            c.setLocal(
              "c",
              c.i32_load(c.getLocal("it"), 4)
            ),
            c.if(
              c.i32_or(
                c.i32_lt_u(
                  c.getLocal("c"),
                  c.getLocal("offsetOut")
                ),
                c.i32_ge_u(
                  c.getLocal("c"),
                  c.i32_add(
                    c.getLocal("offsetOut"),
                    c.getLocal("nOut")
                  )
                )
              ),
              [
                ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
                ...c.br(1)
              ]
            ),
            c.setLocal(
              "pOut",
              c.i32_add(
                c.getLocal("pOut"),
                c.i32_mul(
                  c.i32_sub(
                    c.getLocal("c"),
                    c.getLocal("offsetOut")
                  ),
                  c.i32_const(n8)
                )
              )
            ),
            c.call(
              prefixField + "_mul",
              c.i32_add(
                c.getLocal("pWitness"),
                c.i32_mul(
                  c.i32_sub(c.getLocal("s"), c.getLocal("offsetWitness")),
                  c.i32_const(n8)
                )
              ),
              c.i32_add(c.getLocal("it"), c.i32_const(12)),
              aux
            ),
            c.call(
              prefixField + "_add",
              c.getLocal("pOut"),
              aux,
              c.getLocal("pOut")
            ),
            c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
            c.br(0)
          )),
          c.setLocal("ita", c.getLocal("pA")),
          c.setLocal("itb", c.getLocal("pB")),
          c.setLocal("it", c.getLocal("pC")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pA"),
              c.i32_mul(
                c.getLocal("nOut"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(
              prefixField + "_mul",
              c.getLocal("ita"),
              c.getLocal("itb"),
              c.getLocal("it")
            ),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      function buildJoinABC() {
        const f = module3.addFunction(prefix + "_joinABC");
        f.addParam("pA", "i32");
        f.addParam("pB", "i32");
        f.addParam("pC", "i32");
        f.addParam("n", "i32");
        f.addParam("pP", "i32");
        f.addLocal("ita", "i32");
        f.addLocal("itb", "i32");
        f.addLocal("itc", "i32");
        f.addLocal("itp", "i32");
        f.addLocal("last", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("ita", c.getLocal("pA")),
          c.setLocal("itb", c.getLocal("pB")),
          c.setLocal("itc", c.getLocal("pC")),
          c.setLocal("itp", c.getLocal("pP")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pA"),
              c.i32_mul(
                c.getLocal("n"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(
              prefixField + "_mul",
              c.getLocal("ita"),
              c.getLocal("itb"),
              aux
            ),
            c.call(
              prefixField + "_sub",
              aux,
              c.getLocal("itc"),
              c.getLocal("itp")
            ),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.setLocal("itc", c.i32_add(c.getLocal("itc"), c.i32_const(n8))),
            c.setLocal("itp", c.i32_add(c.getLocal("itp"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      function buildBatchAdd() {
        const f = module3.addFunction(prefix + "_batchAdd");
        f.addParam("pa", "i32");
        f.addParam("pb", "i32");
        f.addParam("n", "i32");
        f.addParam("pr", "i32");
        f.addLocal("ita", "i32");
        f.addLocal("itb", "i32");
        f.addLocal("itr", "i32");
        f.addLocal("last", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal("ita", c.getLocal("pa")),
          c.setLocal("itb", c.getLocal("pb")),
          c.setLocal("itr", c.getLocal("pr")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pa"),
              c.i32_mul(
                c.getLocal("n"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(
              prefixField + "_add",
              c.getLocal("ita"),
              c.getLocal("itb"),
              c.getLocal("itr")
            ),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.setLocal("itr", c.i32_add(c.getLocal("itr"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      buildBuildABC();
      buildJoinABC();
      buildBatchAdd();
      module3.exportFunction(prefix + "_buildABC");
      module3.exportFunction(prefix + "_joinABC");
      module3.exportFunction(prefix + "_batchAdd");
      return prefix;
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_applykey.js
var require_build_applykey = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/build_applykey.js"(exports, module2) {
    "use strict";
    module2.exports = function buildApplyKey(module3, fnName, gPrefix, frPrefix, sizeGIn, sizeGOut, sizeF, opGtimesF) {
      const f = module3.addFunction(fnName);
      f.addParam("pIn", "i32");
      f.addParam("n", "i32");
      f.addParam("pFirst", "i32");
      f.addParam("pInc", "i32");
      f.addParam("pOut", "i32");
      f.addLocal("pOldFree", "i32");
      f.addLocal("i", "i32");
      f.addLocal("pFrom", "i32");
      f.addLocal("pTo", "i32");
      const c = f.getCodeBuilder();
      const t = c.i32_const(module3.alloc(sizeF));
      f.addCode(
        c.setLocal("pFrom", c.getLocal("pIn")),
        c.setLocal("pTo", c.getLocal("pOut"))
      );
      f.addCode(
        c.call(
          frPrefix + "_copy",
          c.getLocal("pFirst"),
          t
        )
      );
      f.addCode(
        c.setLocal("i", c.i32_const(0)),
        c.block(c.loop(
          c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
          c.call(
            opGtimesF,
            c.getLocal("pFrom"),
            t,
            c.getLocal("pTo")
          ),
          c.setLocal("pFrom", c.i32_add(c.getLocal("pFrom"), c.i32_const(sizeGIn))),
          c.setLocal("pTo", c.i32_add(c.getLocal("pTo"), c.i32_const(sizeGOut))),
          // t = t* inc
          c.call(
            frPrefix + "_mul",
            t,
            c.getLocal("pInc"),
            t
          ),
          c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        ))
      );
      module3.exportFunction(fnName);
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/bn128/build_bn128.js
var require_build_bn128 = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/bn128/build_bn128.js"(exports, module2) {
    "use strict";
    var utils2 = require_utils();
    var buildF1m = require_build_f1m();
    var buildF1 = require_build_f1();
    var buildF2m = require_build_f2m();
    var buildF3m = require_build_f3m();
    var buildCurve = require_build_curve_jacobian_a0();
    var buildFFT4 = require_build_fft();
    var buildPol = require_build_pol();
    var buildQAP = require_build_qap();
    var buildApplyKey = require_build_applykey();
    var { bitLength: bitLength5, modInv, isOdd: isOdd4, isNegative: isNegative5 } = require_bigint();
    module2.exports = function buildBN128(module3, _prefix) {
      const prefix = _prefix || "bn128";
      if (module3.modules[prefix])
        return prefix;
      const q = 21888242871839275222246405745257275088696311157297823662689037894645226208583n;
      const r = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;
      const n64 = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n8 = n64 * 8;
      const frsize = n8;
      const f1size = n8;
      const f2size = f1size * 2;
      const ftsize = f1size * 12;
      const pr = module3.alloc(utils2.bigInt2BytesLE(r, frsize));
      const f1mPrefix = buildF1m(module3, q, "f1m");
      buildF1(module3, r, "fr", "frm");
      const pG1b = module3.alloc(utils2.bigInt2BytesLE(toMontgomery(3n), f1size));
      const g1mPrefix = buildCurve(module3, "g1m", "f1m", pG1b);
      buildFFT4(module3, "frm", "frm", "frm", "frm_mul");
      buildPol(module3, "pol", "frm");
      buildQAP(module3, "qap", "frm");
      const f2mPrefix = buildF2m(module3, "f1m_neg", "f2m", "f1m");
      const pG2b = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
      ]);
      const g2mPrefix = buildCurve(module3, "g2m", "f2m", pG2b);
      function buildGTimesFr(fnName, opMul) {
        const f = module3.addFunction(fnName);
        f.addParam("pG", "i32");
        f.addParam("pFr", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call("frm_fromMontgomery", c.getLocal("pFr"), AUX),
          c.call(
            opMul,
            c.getLocal("pG"),
            AUX,
            c.i32_const(n8),
            c.getLocal("pr")
          )
        );
        module3.exportFunction(fnName);
      }
      buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
      buildFFT4(module3, "g1m", "g1m", "frm", "g1m_timesFr");
      buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
      buildFFT4(module3, "g2m", "g2m", "frm", "g2m_timesFr");
      buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
      buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
      buildApplyKey(module3, "frm_batchApplyKey", "fmr", "frm", n8, n8, n8, "frm_mul");
      buildApplyKey(module3, "g1m_batchApplyKey", "g1m", "frm", n8 * 3, n8 * 3, n8, "g1m_timesFr");
      buildApplyKey(module3, "g1m_batchApplyKeyMixed", "g1m", "frm", n8 * 2, n8 * 3, n8, "g1m_timesFrAffine");
      buildApplyKey(module3, "g2m_batchApplyKey", "g2m", "frm", n8 * 2 * 3, n8 * 3 * 2, n8, "g2m_timesFr");
      buildApplyKey(module3, "g2m_batchApplyKeyMixed", "g2m", "frm", n8 * 2 * 2, n8 * 3 * 2, n8, "g2m_timesFrAffine");
      function toMontgomery(a) {
        return BigInt(a) * (1n << BigInt(f1size * 8)) % q;
      }
      const G1gen = [
        1n,
        2n,
        1n
      ];
      const pG1gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
        ]
      );
      const G1zero = [
        0n,
        1n,
        0n
      ];
      const pG1zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
        ]
      );
      const G2gen = [
        [
          10857046999023057135944570762232829481370756359578518086990519993285655852781n,
          11559732032986387107991004021392285783925812861821192530917403151452391805634n
        ],
        [
          8495653923123431417604973247489272438418190587263600148770280649306958101930n,
          4082367875863433681332203403145435568316851327593401208105741076214120093531n
        ],
        [
          1n,
          0n
        ]
      ];
      const pG2gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
        ]
      );
      const G2zero = [
        [
          0n,
          0n
        ],
        [
          1n,
          0n
        ],
        [
          0n,
          0n
        ]
      ];
      const pG2zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
        ]
      );
      const pOneT = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size)
      ]);
      const pNonResidueF6 = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(9), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(1), f1size)
      ]);
      const pTwoInv = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(modInv(2n, q)), f1size),
        ...utils2.bigInt2BytesLE(0n, f1size)
      ]);
      const pAltBn128Twist = pNonResidueF6;
      const pTwistCoefB = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
      ]);
      function build_mulNR6() {
        const f = module3.addFunction(prefix + "_mulNR6");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(
            f2mPrefix + "_mul",
            c.i32_const(pNonResidueF6),
            c.getLocal("x"),
            c.getLocal("pr")
          )
        );
      }
      build_mulNR6();
      const f6mPrefix = buildF3m(module3, prefix + "_mulNR6", "f6m", "f2m");
      function build_mulNR12() {
        const f = module3.addFunction(prefix + "_mulNR12");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(
            f2mPrefix + "_mul",
            c.i32_const(pNonResidueF6),
            c.i32_add(c.getLocal("x"), c.i32_const(n8 * 4)),
            c.getLocal("pr")
          ),
          c.call(
            f2mPrefix + "_copy",
            c.getLocal("x"),
            c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))
          ),
          c.call(
            f2mPrefix + "_copy",
            c.i32_add(c.getLocal("x"), c.i32_const(n8 * 2)),
            c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 4))
          )
        );
      }
      build_mulNR12();
      const ftmPrefix = buildF2m(module3, prefix + "_mulNR12", "ftm", f6mPrefix);
      const ateLoopCount = 29793968203157093288n;
      const ateLoopBitBytes = bits4(ateLoopCount);
      const pAteLoopBitBytes = module3.alloc(ateLoopBitBytes);
      const isLoopNegative = false;
      const ateCoefSize = 3 * f2size;
      const ateNDblCoefs = ateLoopBitBytes.length - 1;
      const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) => acc + (b != 0 ? 1 : 0), 0);
      const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
      const prePSize = 3 * 2 * n8;
      const preQSize = 3 * n8 * 2 + ateNCoefs * ateCoefSize;
      const finalExpIsNegative = false;
      module3.modules[prefix] = {
        n64,
        pG1gen,
        pG1zero,
        pG1b,
        pG2gen,
        pG2zero,
        pG2b,
        pq: module3.modules["f1m"].pq,
        pr,
        pOneT,
        prePSize,
        preQSize,
        r: r.toString(),
        q: q.toString()
      };
      const finalExpZ = 4965661367192848881n;
      function naf4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            const z = 2 - Number(E % 4n);
            res.push(z);
            E = E - BigInt(z);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function bits4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            res.push(1);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function buildPrepareG1() {
        const f = module3.addFunction(prefix + "_prepareG1");
        f.addParam("pP", "i32");
        f.addParam("ppreP", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(g1mPrefix + "_normalize", c.getLocal("pP"), c.getLocal("ppreP"))
          // TODO Remove if already in affine
        );
      }
      function buildPrepAddStep() {
        const f = module3.addFunction(prefix + "_prepAddStep");
        f.addParam("pQ", "i32");
        f.addParam("pR", "i32");
        f.addParam("pCoef", "i32");
        const c = f.getCodeBuilder();
        const X2 = c.getLocal("pQ");
        const Y2 = c.i32_add(c.getLocal("pQ"), c.i32_const(f2size));
        const X1 = c.getLocal("pR");
        const Y1 = c.i32_add(c.getLocal("pR"), c.i32_const(f2size));
        const Z1 = c.i32_add(c.getLocal("pR"), c.i32_const(2 * f2size));
        const ELL_0 = c.getLocal("pCoef");
        const ELL_VW = c.i32_add(c.getLocal("pCoef"), c.i32_const(f2size));
        const ELL_VV = c.i32_add(c.getLocal("pCoef"), c.i32_const(2 * f2size));
        const D = ELL_VW;
        const E = c.i32_const(module3.alloc(f2size));
        const F = c.i32_const(module3.alloc(f2size));
        const G = c.i32_const(module3.alloc(f2size));
        const H = c.i32_const(module3.alloc(f2size));
        const I = c.i32_const(module3.alloc(f2size));
        const J = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // D = X1 - X2*Z1
          c.call(f2mPrefix + "_mul", X2, Z1, D),
          c.call(f2mPrefix + "_sub", X1, D, D),
          // E = Y1 - Y2*Z1
          c.call(f2mPrefix + "_mul", Y2, Z1, E),
          c.call(f2mPrefix + "_sub", Y1, E, E),
          // F = D^2
          c.call(f2mPrefix + "_square", D, F),
          // G = E^2
          c.call(f2mPrefix + "_square", E, G),
          // H = D*F
          c.call(f2mPrefix + "_mul", D, F, H),
          // I = X1 * F
          c.call(f2mPrefix + "_mul", X1, F, I),
          // J = H + Z1*G - (I+I)
          c.call(f2mPrefix + "_add", I, I, AUX),
          c.call(f2mPrefix + "_mul", Z1, G, J),
          c.call(f2mPrefix + "_add", H, J, J),
          c.call(f2mPrefix + "_sub", J, AUX, J),
          // X3 (X1) = D*J
          c.call(f2mPrefix + "_mul", D, J, X1),
          // Y3 (Y1) = E*(I-J)-(H*Y1)
          c.call(f2mPrefix + "_mul", H, Y1, Y1),
          c.call(f2mPrefix + "_sub", I, J, AUX),
          c.call(f2mPrefix + "_mul", E, AUX, AUX),
          c.call(f2mPrefix + "_sub", AUX, Y1, Y1),
          // Z3 (Z1) = Z1*H
          c.call(f2mPrefix + "_mul", Z1, H, Z1),
          // ell_0 = xi * (E * X2 - D * Y2)
          c.call(f2mPrefix + "_mul", D, Y2, AUX),
          c.call(f2mPrefix + "_mul", E, X2, ELL_0),
          c.call(f2mPrefix + "_sub", ELL_0, AUX, ELL_0),
          c.call(f2mPrefix + "_mul", ELL_0, c.i32_const(pAltBn128Twist), ELL_0),
          // ell_VV = - E (later: * xP)
          c.call(f2mPrefix + "_neg", E, ELL_VV)
          // ell_VW = D (later: * yP    )
          // Already assigned
        );
      }
      function buildPrepDoubleStep() {
        const f = module3.addFunction(prefix + "_prepDblStep");
        f.addParam("pR", "i32");
        f.addParam("pCoef", "i32");
        const c = f.getCodeBuilder();
        const X1 = c.getLocal("pR");
        const Y1 = c.i32_add(c.getLocal("pR"), c.i32_const(f2size));
        const Z1 = c.i32_add(c.getLocal("pR"), c.i32_const(2 * f2size));
        const ELL_0 = c.getLocal("pCoef");
        const ELL_VW = c.i32_add(c.getLocal("pCoef"), c.i32_const(f2size));
        const ELL_VV = c.i32_add(c.getLocal("pCoef"), c.i32_const(2 * f2size));
        const A = c.i32_const(module3.alloc(f2size));
        const B = c.i32_const(module3.alloc(f2size));
        const C = c.i32_const(module3.alloc(f2size));
        const D = c.i32_const(module3.alloc(f2size));
        const E = c.i32_const(module3.alloc(f2size));
        const F = c.i32_const(module3.alloc(f2size));
        const G = c.i32_const(module3.alloc(f2size));
        const H = c.i32_const(module3.alloc(f2size));
        const I = c.i32_const(module3.alloc(f2size));
        const J = c.i32_const(module3.alloc(f2size));
        const E2 = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // A = X1 * Y1 / 2
          c.call(f2mPrefix + "_mul", Y1, c.i32_const(pTwoInv), A),
          c.call(f2mPrefix + "_mul", X1, A, A),
          // B = Y1^2
          c.call(f2mPrefix + "_square", Y1, B),
          // C = Z1^2
          c.call(f2mPrefix + "_square", Z1, C),
          // D = 3 * C
          c.call(f2mPrefix + "_add", C, C, D),
          c.call(f2mPrefix + "_add", D, C, D),
          // E = twist_b * D
          c.call(f2mPrefix + "_mul", c.i32_const(pTwistCoefB), D, E),
          // F = 3 * E
          c.call(f2mPrefix + "_add", E, E, F),
          c.call(f2mPrefix + "_add", E, F, F),
          // G = (B+F)/2
          c.call(f2mPrefix + "_add", B, F, G),
          c.call(f2mPrefix + "_mul", G, c.i32_const(pTwoInv), G),
          // H = (Y1+Z1)^2-(B+C)
          c.call(f2mPrefix + "_add", B, C, AUX),
          c.call(f2mPrefix + "_add", Y1, Z1, H),
          c.call(f2mPrefix + "_square", H, H),
          c.call(f2mPrefix + "_sub", H, AUX, H),
          // I = E-B
          c.call(f2mPrefix + "_sub", E, B, I),
          // J = X1^2
          c.call(f2mPrefix + "_square", X1, J),
          // E_squared = E^2
          c.call(f2mPrefix + "_square", E, E2),
          // X3 (X1) = A * (B-F)
          c.call(f2mPrefix + "_sub", B, F, AUX),
          c.call(f2mPrefix + "_mul", A, AUX, X1),
          // Y3 (Y1) = G^2 - 3*E^2
          c.call(f2mPrefix + "_add", E2, E2, AUX),
          c.call(f2mPrefix + "_add", E2, AUX, AUX),
          c.call(f2mPrefix + "_square", G, Y1),
          c.call(f2mPrefix + "_sub", Y1, AUX, Y1),
          // Z3 (Z1) = B * H
          c.call(f2mPrefix + "_mul", B, H, Z1),
          // ell_0 = xi * I
          c.call(f2mPrefix + "_mul", c.i32_const(pAltBn128Twist), I, ELL_0),
          // ell_VW = - H (later: * yP)
          c.call(f2mPrefix + "_neg", H, ELL_VW),
          // ell_VV = 3*J (later: * xP)
          c.call(f2mPrefix + "_add", J, J, ELL_VV),
          c.call(f2mPrefix + "_add", J, ELL_VV, ELL_VV)
        );
      }
      function buildMulByQ() {
        const f = module3.addFunction(prefix + "_mulByQ");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(f2size));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(f2size * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(f2size));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(f2size * 2));
        const MulByQX = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery("21575463638280843010398324269430826099269044274347216827212613867836435027261"), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery("10307601595873709700152284273816112264069230130616436755625194854815875713954"), f1size)
        ]));
        const MulByQY = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery("2821565182194536844548159561693502659359617185244120367078079554186484126554"), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery("3505843767911556378687030309984248845540243509899259641013678093033130930403"), f1size)
        ]));
        f.addCode(
          // The frobeniusMap(1) in this field, is the conjugate
          c.call(f2mPrefix + "_conjugate", x, x3),
          c.call(f2mPrefix + "_mul", MulByQX, x3, x3),
          c.call(f2mPrefix + "_conjugate", y, y3),
          c.call(f2mPrefix + "_mul", MulByQY, y3, y3),
          c.call(f2mPrefix + "_conjugate", z, z3)
        );
      }
      function buildPrepareG2() {
        buildMulByQ();
        const f = module3.addFunction(prefix + "_prepareG2");
        f.addParam("pQ", "i32");
        f.addParam("ppreQ", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const QX = c.getLocal("pQ");
        const pR = module3.alloc(f2size * 3);
        const R = c.i32_const(pR);
        const RX = c.i32_const(pR);
        const RY = c.i32_const(pR + f2size);
        const RZ = c.i32_const(pR + 2 * f2size);
        const cQX = c.i32_add(c.getLocal("ppreQ"), c.i32_const(0));
        const cQY = c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size));
        const pQ1 = module3.alloc(f2size * 3);
        const Q1 = c.i32_const(pQ1);
        const pQ2 = module3.alloc(f2size * 3);
        const Q2 = c.i32_const(pQ2);
        const Q2Y = c.i32_const(pQ2 + f2size);
        f.addCode(
          c.call(g2mPrefix + "_normalize", QX, cQX),
          // TODO Remove if already in affine
          c.call(f2mPrefix + "_copy", cQX, RX),
          c.call(f2mPrefix + "_copy", cQY, RY),
          c.call(f2mPrefix + "_one", RZ)
        );
        f.addCode(
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3))),
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "_prepDblStep", R, c.getLocal("pCoef")),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(prefix + "_prepAddStep", cQX, R, c.getLocal("pCoef")),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
        f.addCode(
          c.call(prefix + "_mulByQ", cQX, Q1),
          c.call(prefix + "_mulByQ", Q1, Q2)
        );
        if (isLoopNegative) {
          f.addCode(
            c.call(f2mPrefix + "_neg", RY, RY)
          );
        }
        f.addCode(
          c.call(f2mPrefix + "_neg", Q2Y, Q2Y),
          c.call(prefix + "_prepAddStep", Q1, R, c.getLocal("pCoef")),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
          c.call(prefix + "_prepAddStep", Q2, R, c.getLocal("pCoef")),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
        );
      }
      function buildMulBy024Old() {
        const f = module3.addFunction(prefix + "__mulBy024Old");
        f.addParam("pEll0", "i32");
        f.addParam("pEllVW", "i32");
        f.addParam("pEllVV", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("pEll0");
        const x2 = c.getLocal("pEllVV");
        const x4 = c.getLocal("pEllVW");
        const z0 = c.getLocal("pR");
        const pAUX12 = module3.alloc(ftsize);
        const AUX12 = c.i32_const(pAUX12);
        const AUX12_0 = c.i32_const(pAUX12);
        const AUX12_2 = c.i32_const(pAUX12 + f2size);
        const AUX12_4 = c.i32_const(pAUX12 + f2size * 2);
        const AUX12_6 = c.i32_const(pAUX12 + f2size * 3);
        const AUX12_8 = c.i32_const(pAUX12 + f2size * 4);
        const AUX12_10 = c.i32_const(pAUX12 + f2size * 5);
        f.addCode(
          c.call(f2mPrefix + "_copy", x0, AUX12_0),
          c.call(f2mPrefix + "_zero", AUX12_2),
          c.call(f2mPrefix + "_copy", x2, AUX12_4),
          c.call(f2mPrefix + "_zero", AUX12_6),
          c.call(f2mPrefix + "_copy", x4, AUX12_8),
          c.call(f2mPrefix + "_zero", AUX12_10),
          c.call(ftmPrefix + "_mul", AUX12, z0, z0)
        );
      }
      function buildMulBy024() {
        const f = module3.addFunction(prefix + "__mulBy024");
        f.addParam("pEll0", "i32");
        f.addParam("pEllVW", "i32");
        f.addParam("pEllVV", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("pEll0");
        const x2 = c.getLocal("pEllVV");
        const x4 = c.getLocal("pEllVW");
        const z0 = c.getLocal("pR");
        const z1 = c.i32_add(c.getLocal("pR"), c.i32_const(2 * n8));
        const z2 = c.i32_add(c.getLocal("pR"), c.i32_const(4 * n8));
        const z3 = c.i32_add(c.getLocal("pR"), c.i32_const(6 * n8));
        const z4 = c.i32_add(c.getLocal("pR"), c.i32_const(8 * n8));
        const z5 = c.i32_add(c.getLocal("pR"), c.i32_const(10 * n8));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const s0 = c.i32_const(module3.alloc(f2size));
        const T3 = c.i32_const(module3.alloc(f2size));
        const T4 = c.i32_const(module3.alloc(f2size));
        const D0 = c.i32_const(module3.alloc(f2size));
        const D2 = c.i32_const(module3.alloc(f2size));
        const D4 = c.i32_const(module3.alloc(f2size));
        const S1 = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // D0 = z0 * x0;
          c.call(f2mPrefix + "_mul", z0, x0, D0),
          // D2 = z2 * x2;
          c.call(f2mPrefix + "_mul", z2, x2, D2),
          // D4 = z4 * x4;
          c.call(f2mPrefix + "_mul", z4, x4, D4),
          // t2 = z0 + z4;
          c.call(f2mPrefix + "_add", z0, z4, t2),
          // t1 = z0 + z2;
          c.call(f2mPrefix + "_add", z0, z2, t1),
          // s0 = z1 + z3 + z5;
          c.call(f2mPrefix + "_add", z1, z3, s0),
          c.call(f2mPrefix + "_add", s0, z5, s0),
          // For z.a_.a_ = z0.
          // S1 = z1 * x2;
          c.call(f2mPrefix + "_mul", z1, x2, S1),
          // T3 = S1 + D4;
          c.call(f2mPrefix + "_add", S1, D4, T3),
          // T4 = my_Fp6::non_residue * T3 + D0;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          c.call(f2mPrefix + "_add", T4, D0, z0),
          // z0 = T4;
          // For z.a_.b_ = z1
          // T3 = z5 * x4;
          c.call(f2mPrefix + "_mul", z5, x4, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T3 = T3 + D2;
          c.call(f2mPrefix + "_add", T3, D2, T3),
          // T4 = my_Fp6::non_residue * T3;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          // T3 = z1 * x0;
          c.call(f2mPrefix + "_mul", z1, x0, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = T4 + T3;
          c.call(f2mPrefix + "_add", T4, T3, z1),
          // z1 = T4;
          // For z.a_.c_ = z2
          // t0 = x0 + x2;
          c.call(f2mPrefix + "_add", x0, x2, t0),
          // T3 = t1 * t0 - D0 - D2;
          c.call(f2mPrefix + "_mul", t1, t0, T3),
          c.call(f2mPrefix + "_add", D0, D2, AUX),
          c.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = z3 * x4;
          c.call(f2mPrefix + "_mul", z3, x4, T4),
          // S1 = S1 + T4;
          c.call(f2mPrefix + "_add", S1, T4, S1),
          // For z.b_.a_ = z3 (z3 needs z2)
          // t0 = z2 + z4;
          c.call(f2mPrefix + "_add", z2, z4, t0),
          // T3 = T3 + T4;
          // z2 = T3;
          c.call(f2mPrefix + "_add", T3, T4, z2),
          // t1 = x2 + x4;
          c.call(f2mPrefix + "_add", x2, x4, t1),
          // T3 = t0 * t1 - D2 - D4;
          c.call(f2mPrefix + "_mul", t1, t0, T3),
          c.call(f2mPrefix + "_add", D2, D4, AUX),
          c.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = my_Fp6::non_residue * T3;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          // T3 = z3 * x0;
          c.call(f2mPrefix + "_mul", z3, x0, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = T4 + T3;
          c.call(f2mPrefix + "_add", T4, T3, z3),
          // z3 = T4;
          // For z.b_.b_ = z4
          // T3 = z5 * x2;
          c.call(f2mPrefix + "_mul", z5, x2, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = my_Fp6::non_residue * T3;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          // t0 = x0 + x4;
          c.call(f2mPrefix + "_add", x0, x4, t0),
          // T3 = t2 * t0 - D0 - D4;
          c.call(f2mPrefix + "_mul", t2, t0, T3),
          c.call(f2mPrefix + "_add", D0, D4, AUX),
          c.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = T4 + T3;
          c.call(f2mPrefix + "_add", T4, T3, z4),
          // z4 = T4;
          // For z.b_.c_ = z5.
          // t0 = x0 + x2 + x4;
          c.call(f2mPrefix + "_add", x0, x2, t0),
          c.call(f2mPrefix + "_add", t0, x4, t0),
          // T3 = s0 * t0 - S1;
          c.call(f2mPrefix + "_mul", s0, t0, T3),
          c.call(f2mPrefix + "_sub", T3, S1, z5)
          // z5 = T3;
        );
      }
      function buildMillerLoop() {
        const f = module3.addFunction(prefix + "_millerLoop");
        f.addParam("ppreP", "i32");
        f.addParam("ppreQ", "i32");
        f.addParam("r", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const preP_PX = c.getLocal("ppreP");
        const preP_PY = c.i32_add(c.getLocal("ppreP"), c.i32_const(f1size));
        const ELL_0 = c.getLocal("pCoef");
        const ELL_VW = c.i32_add(c.getLocal("pCoef"), c.i32_const(f2size));
        const ELL_VV = c.i32_add(c.getLocal("pCoef"), c.i32_const(2 * f2size));
        const pVW = module3.alloc(f2size);
        const VW = c.i32_const(pVW);
        const pVV = module3.alloc(f2size);
        const VV = c.i32_const(pVV);
        const F = c.getLocal("r");
        f.addCode(
          c.call(ftmPrefix + "_one", F),
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3))),
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(ftmPrefix + "_square", F, F),
            c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
            c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
            c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
                ...c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
                ...c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
        if (isLoopNegative) {
          f.addCode(
            c.call(ftmPrefix + "_inverse", F, F)
          );
        }
        f.addCode(
          c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
          c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
          c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
          c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
          c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
          c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
        );
      }
      function buildFrobeniusMap(n) {
        const F12 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [8376118865763821496583973867626364092589906065868298776909617916018768340080n, 16469823323077808223889137241176536799009286646108169935659301613961712198316n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556617n, 0n],
            [11697423496358154304825782922584725312912383441159505038794027105778954184319n, 303847389135065887422783454877609941456349188919719272345083954437860409601n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [3321304630594332808241809054958361220322477375291206261884409189760185844239n, 5722266937896532885780051958958348231143373700109372999374820235121374419868n],
            [21888242871839275222246405745257275088696311157297823662689037894645226208582n, 0n],
            [13512124006075453725662431877630910996106405091429524885779419978626457868503n, 5418419548761466998357268504080738289687024511189653727029736280683514010267n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [10190819375481120917420622822672549775783927716138318623895010788866272024264n, 21584395482704209334823622290379665147239961968378104390343953940207365798982n],
            [2203960485148121921418603742825762020974279258880205651967n, 0n],
            [18566938241244942414004596690298913868373833782006617400804628704885040364344n, 16165975933942742336466353786298926857552937457188450663314217659523851788715n]
          ]
        ];
        const F6 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [21575463638280843010398324269430826099269044274347216827212613867836435027261n, 10307601595873709700152284273816112264069230130616436755625194854815875713954n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [3772000881919853776433695186713858239009073593817195771773381919316419345261n, 2236595495967245188281701248203181795121068902605861227855261137820944008926n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [18429021223477853657660792034369865839114504446431234726392080002137598044644n, 9344045779998320333812420223237981029506012124075525679208581902008406485703n]
          ],
          [
            [1n, 0n],
            [2581911344467009335267311115468803099551665605076196740867805258568234346338n, 19937756971775647987995932169929341994314640652964949448313374472400716661030n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [5324479202449903542726783395506214481928257762400643279780343368557297135718n, 16208900380737693084919495127334387981393726419856888799917914180988844123039n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [13981852324922362344252311234282257507216387789820983642040889267519694726527n, 7629828391165209371577384193250820201684255241773809077146787135900891633097n]
          ]
        ];
        const f = module3.addFunction(prefix + "__frobeniusMap" + n);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < 6; i++) {
          const X = i == 0 ? c.getLocal("x") : c.i32_add(c.getLocal("x"), c.i32_const(i * f2size));
          const Xc0 = X;
          const Xc1 = c.i32_add(c.getLocal("x"), c.i32_const(i * f2size + f1size));
          const R = i == 0 ? c.getLocal("r") : c.i32_add(c.getLocal("r"), c.i32_const(i * f2size));
          const Rc0 = R;
          const Rc1 = c.i32_add(c.getLocal("r"), c.i32_const(i * f2size + f1size));
          const coef = mul22(F12[Math.floor(i / 3)][n % 12], F6[i % 3][n % 6]);
          const pCoef = module3.alloc([
            ...utils2.bigInt2BytesLE(toMontgomery(coef[0]), 32),
            ...utils2.bigInt2BytesLE(toMontgomery(coef[1]), 32)
          ]);
          if (n % 2 == 1) {
            f.addCode(
              c.call(f1mPrefix + "_copy", Xc0, Rc0),
              c.call(f1mPrefix + "_neg", Xc1, Rc1),
              c.call(f2mPrefix + "_mul", R, c.i32_const(pCoef), R)
            );
          } else {
            f.addCode(c.call(f2mPrefix + "_mul", X, c.i32_const(pCoef), R));
          }
        }
        function mul22(a, b) {
          const ac0 = BigInt(a[0]);
          const ac1 = BigInt(a[1]);
          const bc0 = BigInt(b[0]);
          const bc1 = BigInt(b[1]);
          const res = [
            (ac0 * bc0 - ac1 * bc1) % q,
            (ac0 * bc1 + ac1 * bc0) % q
          ];
          if (isNegative5(res[0]))
            res[0] = res[0] + q;
          return res;
        }
      }
      function buildFinalExponentiationFirstChunk() {
        const f = module3.addFunction(prefix + "__finalExponentiationFirstChunk");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const eltC0 = elt;
        const eltC1 = c.i32_add(elt, c.i32_const(n8 * 6));
        const r2 = c.getLocal("r");
        const pA = module3.alloc(ftsize);
        const A = c.i32_const(pA);
        const Ac0 = A;
        const Ac1 = c.i32_const(pA + n8 * 6);
        const B = c.i32_const(module3.alloc(ftsize));
        const C = c.i32_const(module3.alloc(ftsize));
        const D = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          // const alt_bn128_Fq12 A = alt_bn128_Fq12(elt.c0,-elt.c1);
          c.call(f6mPrefix + "_copy", eltC0, Ac0),
          c.call(f6mPrefix + "_neg", eltC1, Ac1),
          // const alt_bn128_Fq12 B = elt.inverse();
          c.call(ftmPrefix + "_inverse", elt, B),
          // const alt_bn128_Fq12 C = A * B;
          c.call(ftmPrefix + "_mul", A, B, C),
          // const alt_bn128_Fq12 D = C.Frobenius_map(2);
          c.call(prefix + "__frobeniusMap2", C, D),
          // const alt_bn128_Fq12 result = D * C;
          c.call(ftmPrefix + "_mul", C, D, r2)
        );
      }
      function buildCyclotomicSquare() {
        const f = module3.addFunction(prefix + "__cyclotomicSquare");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x4 = c.i32_add(c.getLocal("x"), c.i32_const(f2size));
        const x3 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f2size));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(3 * f2size));
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(4 * f2size));
        const x5 = c.i32_add(c.getLocal("x"), c.i32_const(5 * f2size));
        const r0 = c.getLocal("r");
        const r4 = c.i32_add(c.getLocal("r"), c.i32_const(f2size));
        const r3 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f2size));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(3 * f2size));
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(4 * f2size));
        const r5 = c.i32_add(c.getLocal("r"), c.i32_const(5 * f2size));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t3 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        const tmp = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          //    // t0 + t1*y = (z0 + z1*y)^2 = a^2
          //    tmp = z0 * z1;
          //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;
          //    t1 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x0, x1, tmp),
          c.call(f2mPrefix + "_mul", x1, c.i32_const(pNonResidueF6), t0),
          c.call(f2mPrefix + "_add", x0, t0, t0),
          c.call(f2mPrefix + "_add", x0, x1, AUX),
          c.call(f2mPrefix + "_mul", AUX, t0, t0),
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t0, AUX, t0),
          c.call(f2mPrefix + "_add", tmp, tmp, t1),
          //  // t2 + t3*y = (z2 + z3*y)^2 = b^2
          //  tmp = z2 * z3;
          //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;
          //  t3 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x2, x3, tmp),
          c.call(f2mPrefix + "_mul", x3, c.i32_const(pNonResidueF6), t2),
          c.call(f2mPrefix + "_add", x2, t2, t2),
          c.call(f2mPrefix + "_add", x2, x3, AUX),
          c.call(f2mPrefix + "_mul", AUX, t2, t2),
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t2, AUX, t2),
          c.call(f2mPrefix + "_add", tmp, tmp, t3),
          //  // t4 + t5*y = (z4 + z5*y)^2 = c^2
          //  tmp = z4 * z5;
          //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;
          //  t5 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x4, x5, tmp),
          c.call(f2mPrefix + "_mul", x5, c.i32_const(pNonResidueF6), t4),
          c.call(f2mPrefix + "_add", x4, t4, t4),
          c.call(f2mPrefix + "_add", x4, x5, AUX),
          c.call(f2mPrefix + "_mul", AUX, t4, t4),
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t4, AUX, t4),
          c.call(f2mPrefix + "_add", tmp, tmp, t5),
          // For A
          // z0 = 3 * t0 - 2 * z0
          c.call(f2mPrefix + "_sub", t0, x0, r0),
          c.call(f2mPrefix + "_add", r0, r0, r0),
          c.call(f2mPrefix + "_add", t0, r0, r0),
          // z1 = 3 * t1 + 2 * z1
          c.call(f2mPrefix + "_add", t1, x1, r1),
          c.call(f2mPrefix + "_add", r1, r1, r1),
          c.call(f2mPrefix + "_add", t1, r1, r1),
          // For B
          // z2 = 3 * (xi * t5) + 2 * z2
          c.call(f2mPrefix + "_mul", t5, c.i32_const(pAltBn128Twist), AUX),
          c.call(f2mPrefix + "_add", AUX, x2, r2),
          c.call(f2mPrefix + "_add", r2, r2, r2),
          c.call(f2mPrefix + "_add", AUX, r2, r2),
          // z3 = 3 * t4 - 2 * z3
          c.call(f2mPrefix + "_sub", t4, x3, r3),
          c.call(f2mPrefix + "_add", r3, r3, r3),
          c.call(f2mPrefix + "_add", t4, r3, r3),
          // For C
          // z4 = 3 * t2 - 2 * z4
          c.call(f2mPrefix + "_sub", t2, x4, r4),
          c.call(f2mPrefix + "_add", r4, r4, r4),
          c.call(f2mPrefix + "_add", t2, r4, r4),
          // z5 = 3 * t3 + 2 * z5
          c.call(f2mPrefix + "_add", t3, x5, r5),
          c.call(f2mPrefix + "_add", r5, r5, r5),
          c.call(f2mPrefix + "_add", t3, r5, r5)
        );
      }
      function buildCyclotomicExp(exponent, fnName) {
        const exponentNafBytes = naf4(exponent).map((b) => b == -1 ? 255 : b);
        const pExponentNafBytes = module3.alloc(exponentNafBytes);
        const f = module3.addFunction(prefix + "__cyclotomicExp_" + fnName);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("bit", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("x");
        const res = c.getLocal("r");
        const inverse = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          c.call(ftmPrefix + "_conjugate", x, inverse),
          c.call(ftmPrefix + "_one", res),
          c.if(
            c.teeLocal("bit", c.i32_load8_s(c.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
            c.if(
              c.i32_eq(
                c.getLocal("bit"),
                c.i32_const(1)
              ),
              c.call(ftmPrefix + "_mul", res, x, res),
              c.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c.setLocal("i", c.i32_const(exponentNafBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "__cyclotomicSquare", res, res),
            c.if(
              c.teeLocal("bit", c.i32_load8_s(c.getLocal("i"), pExponentNafBytes)),
              c.if(
                c.i32_eq(
                  c.getLocal("bit"),
                  c.i32_const(1)
                ),
                c.call(ftmPrefix + "_mul", res, x, res),
                c.call(ftmPrefix + "_mul", res, inverse, res)
              )
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFinalExponentiationLastChunk() {
        buildCyclotomicSquare();
        buildCyclotomicExp(finalExpZ, "w0");
        const f = module3.addFunction(prefix + "__finalExponentiationLastChunk");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const result = c.getLocal("r");
        const A = c.i32_const(module3.alloc(ftsize));
        const B = c.i32_const(module3.alloc(ftsize));
        const C = c.i32_const(module3.alloc(ftsize));
        const D = c.i32_const(module3.alloc(ftsize));
        const E = c.i32_const(module3.alloc(ftsize));
        const F = c.i32_const(module3.alloc(ftsize));
        const G = c.i32_const(module3.alloc(ftsize));
        const H = c.i32_const(module3.alloc(ftsize));
        const I = c.i32_const(module3.alloc(ftsize));
        const J = c.i32_const(module3.alloc(ftsize));
        const K = c.i32_const(module3.alloc(ftsize));
        const L = c.i32_const(module3.alloc(ftsize));
        const M = c.i32_const(module3.alloc(ftsize));
        const N = c.i32_const(module3.alloc(ftsize));
        const O = c.i32_const(module3.alloc(ftsize));
        const P = c.i32_const(module3.alloc(ftsize));
        const Q = c.i32_const(module3.alloc(ftsize));
        const R = c.i32_const(module3.alloc(ftsize));
        const S = c.i32_const(module3.alloc(ftsize));
        const T = c.i32_const(module3.alloc(ftsize));
        const U = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          // A = exp_by_neg_z(elt)  // = elt^(-z)
          c.call(prefix + "__cyclotomicExp_w0", elt, A),
          finalExpIsNegative ? [] : c.call(ftmPrefix + "_conjugate", A, A),
          // B = A^2                // = elt^(-2*z)
          c.call(prefix + "__cyclotomicSquare", A, B),
          // C = B^2                // = elt^(-4*z)
          c.call(prefix + "__cyclotomicSquare", B, C),
          // D = C * B              // = elt^(-6*z)
          c.call(ftmPrefix + "_mul", C, B, D),
          // E = exp_by_neg_z(D)    // = elt^(6*z^2)
          c.call(prefix + "__cyclotomicExp_w0", D, E),
          finalExpIsNegative ? [] : c.call(ftmPrefix + "_conjugate", E, E),
          // F = E^2                // = elt^(12*z^2)
          c.call(prefix + "__cyclotomicSquare", E, F),
          // G = epx_by_neg_z(F)    // = elt^(-12*z^3)
          c.call(prefix + "__cyclotomicExp_w0", F, G),
          finalExpIsNegative ? [] : c.call(ftmPrefix + "_conjugate", G, G),
          // H = conj(D)            // = elt^(6*z)
          c.call(ftmPrefix + "_conjugate", D, H),
          // I = conj(G)            // = elt^(12*z^3)
          c.call(ftmPrefix + "_conjugate", G, I),
          // J = I * E              // = elt^(12*z^3 + 6*z^2)
          c.call(ftmPrefix + "_mul", I, E, J),
          // K = J * H              // = elt^(12*z^3 + 6*z^2 + 6*z)
          c.call(ftmPrefix + "_mul", J, H, K),
          // L = K * B              // = elt^(12*z^3 + 6*z^2 + 4*z)
          c.call(ftmPrefix + "_mul", K, B, L),
          // M = K * E              // = elt^(12*z^3 + 12*z^2 + 6*z)
          c.call(ftmPrefix + "_mul", K, E, M),
          // N = M * elt            // = elt^(12*z^3 + 12*z^2 + 6*z + 1)
          c.call(ftmPrefix + "_mul", M, elt, N),
          // O = L.Frobenius_map(1) // = elt^(q*(12*z^3 + 6*z^2 + 4*z))
          c.call(prefix + "__frobeniusMap1", L, O),
          // P = O * N              // = elt^(q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c.call(ftmPrefix + "_mul", O, N, P),
          // Q = K.Frobenius_map(2) // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z))
          c.call(prefix + "__frobeniusMap2", K, Q),
          // R = Q * P              // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c.call(ftmPrefix + "_mul", Q, P, R),
          // S = conj(elt)          // = elt^(-1)
          c.call(ftmPrefix + "_conjugate", elt, S),
          // T = S * L              // = elt^(12*z^3 + 6*z^2 + 4*z - 1)
          c.call(ftmPrefix + "_mul", S, L, T),
          // U = T.Frobenius_map(3) // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1))
          c.call(prefix + "__frobeniusMap3", T, U),
          // V = U * R              // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1) + q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c.call(ftmPrefix + "_mul", U, R, result)
          // result = V
        );
      }
      function buildFinalExponentiation() {
        buildFinalExponentiationFirstChunk();
        buildFinalExponentiationLastChunk();
        const f = module3.addFunction(prefix + "_finalExponentiation");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const result = c.getLocal("r");
        const eltToFirstChunk = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          c.call(prefix + "__finalExponentiationFirstChunk", elt, eltToFirstChunk),
          c.call(prefix + "__finalExponentiationLastChunk", eltToFirstChunk, result)
        );
      }
      function buildFinalExponentiationOld() {
        const f = module3.addFunction(prefix + "_finalExponentiationOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const exponent = 552484233613224096312617126783173147097382103762957654188882734314196910839907541213974502761540629817009608548654680343627701153829446747810907373256841551006201639677726139946029199968412598804882391702273019083653272047566316584365559776493027495458238373902875937659943504873220554161550525926302303331747463515644711876653177129578303191095900909191624817826566688241804408081892785725967931714097716709526092261278071952560171111444072049229123565057483750161460024353346284167282452756217662335528813519139808291170539072125381230815729071544861602750936964829313608137325426383735122175229541155376346436093930287402089517426973178917569713384748081827255472576937471496195752727188261435633271238710131736096299798168852925540549342330775279877006784354801422249722573783561685179618816480037695005515426162362431072245638324744480n;
        const pExponent = module3.alloc(utils2.bigInt2BytesLE(exponent, 352));
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(ftmPrefix + "_exp", c.getLocal("x"), c.i32_const(pExponent), c.i32_const(352), c.getLocal("r"))
        );
      }
      const pPreP = module3.alloc(prePSize);
      const pPreQ = module3.alloc(preQSize);
      function buildPairingEquation(nPairings) {
        const f = module3.addFunction(prefix + "_pairingEq" + nPairings);
        for (let i = 0; i < nPairings; i++) {
          f.addParam("p_" + i, "i32");
          f.addParam("q_" + i, "i32");
        }
        f.addParam("c", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        const auxT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(ftmPrefix + "_one", resT));
        for (let i = 0; i < nPairings; i++) {
          f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p_" + i), c.i32_const(pPreP)));
          f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q_" + i), c.i32_const(pPreQ)));
          f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), auxT));
          f.addCode(c.call(ftmPrefix + "_mul", resT, auxT, resT));
        }
        f.addCode(c.call(prefix + "_finalExponentiation", resT, resT));
        f.addCode(c.call(ftmPrefix + "_eq", resT, c.getLocal("c")));
      }
      function buildPairing4() {
        const f = module3.addFunction(prefix + "_pairing");
        f.addParam("p", "i32");
        f.addParam("q", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p"), c.i32_const(pPreP)));
        f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q"), c.i32_const(pPreQ)));
        f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), resT));
        f.addCode(c.call(prefix + "_finalExponentiation", resT, c.getLocal("r")));
      }
      buildPrepAddStep();
      buildPrepDoubleStep();
      buildPrepareG1();
      buildPrepareG2();
      buildMulBy024();
      buildMulBy024Old();
      buildMillerLoop();
      for (let i = 0; i < 10; i++) {
        buildFrobeniusMap(i);
        module3.exportFunction(prefix + "__frobeniusMap" + i);
      }
      buildFinalExponentiationOld();
      buildFinalExponentiation();
      for (let i = 1; i <= 5; i++) {
        buildPairingEquation(i);
        module3.exportFunction(prefix + "_pairingEq" + i);
      }
      buildPairing4();
      module3.exportFunction(prefix + "_pairing");
      module3.exportFunction(prefix + "_prepareG1");
      module3.exportFunction(prefix + "_prepareG2");
      module3.exportFunction(prefix + "_millerLoop");
      module3.exportFunction(prefix + "_finalExponentiation");
      module3.exportFunction(prefix + "_finalExponentiationOld");
      module3.exportFunction(prefix + "__mulBy024");
      module3.exportFunction(prefix + "__mulBy024Old");
      module3.exportFunction(prefix + "__cyclotomicSquare");
      module3.exportFunction(prefix + "__cyclotomicExp_w0");
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/bls12381/build_bls12381.js
var require_build_bls12381 = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/src/bls12381/build_bls12381.js"(exports, module2) {
    "use strict";
    var utils2 = require_utils();
    var buildF1m = require_build_f1m();
    var buildF1 = require_build_f1();
    var buildF2m = require_build_f2m();
    var buildF3m = require_build_f3m();
    var buildCurve = require_build_curve_jacobian_a0();
    var buildFFT4 = require_build_fft();
    var buildPol = require_build_pol();
    var buildQAP = require_build_qap();
    var buildApplyKey = require_build_applykey();
    var { bitLength: bitLength5, isOdd: isOdd4, isNegative: isNegative5 } = require_bigint();
    module2.exports = function buildBLS12381(module3, _prefix) {
      const prefix = _prefix || "bls12381";
      if (module3.modules[prefix])
        return prefix;
      const q = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
      const r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;
      const n64q = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n8q = n64q * 8;
      const f1size = n8q;
      const f2size = f1size * 2;
      const ftsize = f1size * 12;
      const n64r = Math.floor((bitLength5(r - 1n) - 1) / 64) + 1;
      const n8r = n64r * 8;
      const frsize = n8r;
      const pr = module3.alloc(utils2.bigInt2BytesLE(r, frsize));
      const f1mPrefix = buildF1m(module3, q, "f1m", "intq");
      buildF1(module3, r, "fr", "frm", "intr");
      const pG1b = module3.alloc(utils2.bigInt2BytesLE(toMontgomery(4n), f1size));
      const g1mPrefix = buildCurve(module3, "g1m", "f1m", pG1b);
      buildFFT4(module3, "frm", "frm", "frm", "frm_mul");
      buildPol(module3, "pol", "frm");
      buildQAP(module3, "qap", "frm");
      const f2mPrefix = buildF2m(module3, "f1m_neg", "f2m", "f1m");
      const pG2b = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(4n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(4n), f1size)
      ]);
      const g2mPrefix = buildCurve(module3, "g2m", "f2m", pG2b);
      function buildGTimesFr(fnName, opMul) {
        const f = module3.addFunction(fnName);
        f.addParam("pG", "i32");
        f.addParam("pFr", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8r));
        f.addCode(
          c.call("frm_fromMontgomery", c.getLocal("pFr"), AUX),
          c.call(
            opMul,
            c.getLocal("pG"),
            AUX,
            c.i32_const(n8r),
            c.getLocal("pr")
          )
        );
        module3.exportFunction(fnName);
      }
      buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
      buildFFT4(module3, "g1m", "g1m", "frm", "g1m_timesFr");
      buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
      buildFFT4(module3, "g2m", "g2m", "frm", "g2m_timesFr");
      buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
      buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
      buildApplyKey(module3, "frm_batchApplyKey", "fmr", "frm", n8r, n8r, n8r, "frm_mul");
      buildApplyKey(module3, "g1m_batchApplyKey", "g1m", "frm", n8q * 3, n8q * 3, n8r, "g1m_timesFr");
      buildApplyKey(module3, "g1m_batchApplyKeyMixed", "g1m", "frm", n8q * 2, n8q * 3, n8r, "g1m_timesFrAffine");
      buildApplyKey(module3, "g2m_batchApplyKey", "g2m", "frm", n8q * 2 * 3, n8q * 3 * 2, n8r, "g2m_timesFr");
      buildApplyKey(module3, "g2m_batchApplyKeyMixed", "g2m", "frm", n8q * 2 * 2, n8q * 3 * 2, n8r, "g2m_timesFrAffine");
      function toMontgomery(a) {
        return BigInt(a) * (1n << BigInt(f1size * 8)) % q;
      }
      const G1gen = [
        3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507n,
        1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569n,
        1n
      ];
      const pG1gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
        ]
      );
      const G1zero = [
        0n,
        1n,
        0n
      ];
      const pG1zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
        ]
      );
      const G2gen = [
        [
          352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160n,
          3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758n
        ],
        [
          1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905n,
          927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582n
        ],
        [
          1n,
          0n
        ]
      ];
      const pG2gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
        ]
      );
      const G2zero = [
        [
          0n,
          0n
        ],
        [
          1n,
          0n
        ],
        [
          0n,
          0n
        ]
      ];
      const pG2zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
        ]
      );
      const pOneT = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size)
      ]);
      const pBls12381Twist = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size)
      ]);
      function build_mulNR2() {
        const f = module3.addFunction(f2mPrefix + "_mulNR");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x0c = c.i32_const(module3.alloc(f1size));
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1size));
        const r0 = c.getLocal("pr");
        const r1 = c.i32_add(c.getLocal("pr"), c.i32_const(f1size));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, x0c),
          c.call(f1mPrefix + "_sub", x0, x1, r0),
          c.call(f1mPrefix + "_add", x0c, x1, r1)
        );
      }
      build_mulNR2();
      const f6mPrefix = buildF3m(module3, f2mPrefix + "_mulNR", "f6m", "f2m");
      function build_mulNR6() {
        const f = module3.addFunction(f6mPrefix + "_mulNR");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const c0copy = c.i32_const(module3.alloc(f1size * 2));
        f.addCode(
          c.call(
            f2mPrefix + "_copy",
            c.getLocal("x"),
            c0copy
          ),
          c.call(
            f2mPrefix + "_mulNR",
            c.i32_add(c.getLocal("x"), c.i32_const(n8q * 4)),
            c.getLocal("pr")
          ),
          c.call(
            f2mPrefix + "_copy",
            c.i32_add(c.getLocal("x"), c.i32_const(n8q * 2)),
            c.i32_add(c.getLocal("pr"), c.i32_const(n8q * 4))
          ),
          c.call(
            f2mPrefix + "_copy",
            c0copy,
            c.i32_add(c.getLocal("pr"), c.i32_const(n8q * 2))
          )
        );
      }
      build_mulNR6();
      const ftmPrefix = buildF2m(module3, f6mPrefix + "_mulNR", "ftm", f6mPrefix);
      const ateLoopCount = 0xd201000000010000n;
      const ateLoopBitBytes = bits4(ateLoopCount);
      const pAteLoopBitBytes = module3.alloc(ateLoopBitBytes);
      const isLoopNegative = true;
      const ateCoefSize = 3 * f2size;
      const ateNDblCoefs = ateLoopBitBytes.length - 1;
      const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) => acc + (b != 0 ? 1 : 0), 0);
      const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
      const prePSize = 3 * 2 * n8q;
      const preQSize = 3 * n8q * 2 + ateNCoefs * ateCoefSize;
      const finalExpIsNegative = true;
      const finalExpZ = 15132376222941642752n;
      module3.modules[prefix] = {
        n64q,
        n64r,
        n8q,
        n8r,
        pG1gen,
        pG1zero,
        pG1b,
        pG2gen,
        pG2zero,
        pG2b,
        pq: module3.modules["f1m"].pq,
        pr,
        pOneT,
        r,
        q,
        prePSize,
        preQSize
      };
      function naf4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            const z = 2 - Number(E % 4n);
            res.push(z);
            E = E - BigInt(z);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function bits4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            res.push(1);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function buildPrepareG1() {
        const f = module3.addFunction(prefix + "_prepareG1");
        f.addParam("pP", "i32");
        f.addParam("ppreP", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(g1mPrefix + "_normalize", c.getLocal("pP"), c.getLocal("ppreP"))
          // TODO Remove if already in affine
        );
      }
      function buildPrepDoubleStep() {
        const f = module3.addFunction(prefix + "_prepDblStep");
        f.addParam("R", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const Rx = c.getLocal("R");
        const Ry = c.i32_add(c.getLocal("R"), c.i32_const(2 * n8q));
        const Rz = c.i32_add(c.getLocal("R"), c.i32_const(4 * n8q));
        const t0 = c.getLocal("r");
        const t3 = c.i32_add(c.getLocal("r"), c.i32_const(2 * n8q));
        const t6 = c.i32_add(c.getLocal("r"), c.i32_const(4 * n8q));
        const zsquared = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // tmp0 = r.x.square();
          c.call(f2mPrefix + "_square", Rx, t0),
          // tmp1 = r.y.square();
          c.call(f2mPrefix + "_square", Ry, t1),
          // tmp2 = tmp1.square();
          c.call(f2mPrefix + "_square", t1, t2),
          // tmp3 = (tmp1 + r.x).square() - tmp0 - tmp2;
          c.call(f2mPrefix + "_add", t1, Rx, t3),
          c.call(f2mPrefix + "_square", t3, t3),
          c.call(f2mPrefix + "_sub", t3, t0, t3),
          c.call(f2mPrefix + "_sub", t3, t2, t3),
          // tmp3 = tmp3 + tmp3;
          c.call(f2mPrefix + "_add", t3, t3, t3),
          // tmp4 = tmp0 + tmp0 + tmp0;
          c.call(f2mPrefix + "_add", t0, t0, t4),
          c.call(f2mPrefix + "_add", t4, t0, t4),
          // tmp6 = r.x + tmp4;
          c.call(f2mPrefix + "_add", Rx, t4, t6),
          // tmp5 = tmp4.square();
          c.call(f2mPrefix + "_square", t4, t5),
          // zsquared = r.z.square();
          c.call(f2mPrefix + "_square", Rz, zsquared),
          // r.x = tmp5 - tmp3 - tmp3;
          c.call(f2mPrefix + "_sub", t5, t3, Rx),
          c.call(f2mPrefix + "_sub", Rx, t3, Rx),
          // r.z = (r.z + r.y).square() - tmp1 - zsquared;
          c.call(f2mPrefix + "_add", Rz, Ry, Rz),
          c.call(f2mPrefix + "_square", Rz, Rz),
          c.call(f2mPrefix + "_sub", Rz, t1, Rz),
          c.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
          // r.y = (tmp3 - r.x) * tmp4;
          c.call(f2mPrefix + "_sub", t3, Rx, Ry),
          c.call(f2mPrefix + "_mul", Ry, t4, Ry),
          // tmp2 = tmp2 + tmp2;
          c.call(f2mPrefix + "_add", t2, t2, t2),
          // tmp2 = tmp2 + tmp2;
          c.call(f2mPrefix + "_add", t2, t2, t2),
          // tmp2 = tmp2 + tmp2;
          c.call(f2mPrefix + "_add", t2, t2, t2),
          // r.y -= tmp2;
          c.call(f2mPrefix + "_sub", Ry, t2, Ry),
          // tmp3 = tmp4 * zsquared;
          c.call(f2mPrefix + "_mul", t4, zsquared, t3),
          // tmp3 = tmp3 + tmp3;
          c.call(f2mPrefix + "_add", t3, t3, t3),
          // tmp3 = -tmp3;
          c.call(f2mPrefix + "_neg", t3, t3),
          // tmp6 = tmp6.square() - tmp0 - tmp5;
          c.call(f2mPrefix + "_square", t6, t6),
          c.call(f2mPrefix + "_sub", t6, t0, t6),
          c.call(f2mPrefix + "_sub", t6, t5, t6),
          // tmp1 = tmp1 + tmp1;
          c.call(f2mPrefix + "_add", t1, t1, t1),
          // tmp1 = tmp1 + tmp1;
          c.call(f2mPrefix + "_add", t1, t1, t1),
          // tmp6 = tmp6 - tmp1;
          c.call(f2mPrefix + "_sub", t6, t1, t6),
          // tmp0 = r.z * zsquared;
          c.call(f2mPrefix + "_mul", Rz, zsquared, t0),
          // tmp0 = tmp0 + tmp0;
          c.call(f2mPrefix + "_add", t0, t0, t0)
        );
      }
      function buildPrepAddStep() {
        const f = module3.addFunction(prefix + "_prepAddStep");
        f.addParam("R", "i32");
        f.addParam("Q", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const Rx = c.getLocal("R");
        const Ry = c.i32_add(c.getLocal("R"), c.i32_const(2 * n8q));
        const Rz = c.i32_add(c.getLocal("R"), c.i32_const(4 * n8q));
        const Qx = c.getLocal("Q");
        const Qy = c.i32_add(c.getLocal("Q"), c.i32_const(2 * n8q));
        const t10 = c.getLocal("r");
        const t1 = c.i32_add(c.getLocal("r"), c.i32_const(2 * n8q));
        const t9 = c.i32_add(c.getLocal("r"), c.i32_const(4 * n8q));
        const zsquared = c.i32_const(module3.alloc(f2size));
        const ysquared = c.i32_const(module3.alloc(f2size));
        const ztsquared = c.i32_const(module3.alloc(f2size));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t3 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        const t6 = c.i32_const(module3.alloc(f2size));
        const t7 = c.i32_const(module3.alloc(f2size));
        const t8 = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // zsquared = r.z.square();
          c.call(f2mPrefix + "_square", Rz, zsquared),
          // ysquared = q.y.square();
          c.call(f2mPrefix + "_square", Qy, ysquared),
          // t0 = zsquared * q.x;
          c.call(f2mPrefix + "_mul", zsquared, Qx, t0),
          // t1 = ((q.y + r.z).square() - ysquared - zsquared) * zsquared;
          c.call(f2mPrefix + "_add", Qy, Rz, t1),
          c.call(f2mPrefix + "_square", t1, t1),
          c.call(f2mPrefix + "_sub", t1, ysquared, t1),
          c.call(f2mPrefix + "_sub", t1, zsquared, t1),
          c.call(f2mPrefix + "_mul", t1, zsquared, t1),
          // t2 = t0 - r.x;
          c.call(f2mPrefix + "_sub", t0, Rx, t2),
          // t3 = t2.square();
          c.call(f2mPrefix + "_square", t2, t3),
          // t4 = t3 + t3;
          c.call(f2mPrefix + "_add", t3, t3, t4),
          // t4 = t4 + t4;
          c.call(f2mPrefix + "_add", t4, t4, t4),
          // t5 = t4 * t2;
          c.call(f2mPrefix + "_mul", t4, t2, t5),
          // t6 = t1 - r.y - r.y;
          c.call(f2mPrefix + "_sub", t1, Ry, t6),
          c.call(f2mPrefix + "_sub", t6, Ry, t6),
          // t9 = t6 * q.x;
          c.call(f2mPrefix + "_mul", t6, Qx, t9),
          // t7 = t4 * r.x;
          c.call(f2mPrefix + "_mul", t4, Rx, t7),
          // r.x = t6.square() - t5 - t7 - t7;
          c.call(f2mPrefix + "_square", t6, Rx),
          c.call(f2mPrefix + "_sub", Rx, t5, Rx),
          c.call(f2mPrefix + "_sub", Rx, t7, Rx),
          c.call(f2mPrefix + "_sub", Rx, t7, Rx),
          // r.z = (r.z + t2).square() - zsquared - t3;
          c.call(f2mPrefix + "_add", Rz, t2, Rz),
          c.call(f2mPrefix + "_square", Rz, Rz),
          c.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
          c.call(f2mPrefix + "_sub", Rz, t3, Rz),
          // t10 = q.y + r.z;
          c.call(f2mPrefix + "_add", Qy, Rz, t10),
          // t8 = (t7 - r.x) * t6;
          c.call(f2mPrefix + "_sub", t7, Rx, t8),
          c.call(f2mPrefix + "_mul", t8, t6, t8),
          // t0 = r.y * t5;
          c.call(f2mPrefix + "_mul", Ry, t5, t0),
          // t0 = t0 + t0;
          c.call(f2mPrefix + "_add", t0, t0, t0),
          // r.y = t8 - t0;
          c.call(f2mPrefix + "_sub", t8, t0, Ry),
          // t10 = t10.square() - ysquared;
          c.call(f2mPrefix + "_square", t10, t10),
          c.call(f2mPrefix + "_sub", t10, ysquared, t10),
          // ztsquared = r.z.square();
          c.call(f2mPrefix + "_square", Rz, ztsquared),
          // t10 = t10 - ztsquared;
          c.call(f2mPrefix + "_sub", t10, ztsquared, t10),
          // t9 = t9 + t9 - t10;
          c.call(f2mPrefix + "_add", t9, t9, t9),
          c.call(f2mPrefix + "_sub", t9, t10, t9),
          // t10 = r.z + r.z;
          c.call(f2mPrefix + "_add", Rz, Rz, t10),
          // t6 = -t6;
          c.call(f2mPrefix + "_neg", t6, t6),
          // t1 = t6 + t6;
          c.call(f2mPrefix + "_add", t6, t6, t1)
        );
      }
      function buildPrepareG2() {
        const f = module3.addFunction(prefix + "_prepareG2");
        f.addParam("pQ", "i32");
        f.addParam("ppreQ", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const Q = c.getLocal("pQ");
        const pR = module3.alloc(f2size * 3);
        const R = c.i32_const(pR);
        const base = c.getLocal("ppreQ");
        f.addCode(
          c.call(g2mPrefix + "_normalize", Q, base),
          c.if(
            c.call(g2mPrefix + "_isZero", base),
            c.ret([])
          ),
          c.call(g2mPrefix + "_copy", base, R),
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3)))
        );
        f.addCode(
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "_prepDblStep", R, c.getLocal("pCoef")),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(prefix + "_prepAddStep", R, base, c.getLocal("pCoef")),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildF6Mul1() {
        const f = module3.addFunction(f6mPrefix + "_mul1");
        f.addParam("pA", "i32");
        f.addParam("pC1", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const A_c0 = c.getLocal("pA");
        const A_c1 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 2));
        const A_c2 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 4));
        const c1 = c.getLocal("pC1");
        const t1 = c.getLocal("pR");
        const t2 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 2));
        const b_b = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 4));
        const Ac0_Ac1 = c.i32_const(module3.alloc(f1size * 2));
        const Ac1_Ac2 = c.i32_const(module3.alloc(f1size * 2));
        f.addCode(
          c.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
          c.call(f2mPrefix + "_add", A_c1, A_c2, Ac1_Ac2),
          // let b_b = self.c1 * c1;
          c.call(f2mPrefix + "_mul", A_c1, c1, b_b),
          // let t1 = (self.c1 + self.c2) * c1 - b_b;
          c.call(f2mPrefix + "_mul", Ac1_Ac2, c1, t1),
          c.call(f2mPrefix + "_sub", t1, b_b, t1),
          // let t1 = t1.mul_by_nonresidue();
          c.call(f2mPrefix + "_mulNR", t1, t1),
          // let t2 = (self.c0 + self.c1) * c1 - b_b;
          c.call(f2mPrefix + "_mul", Ac0_Ac1, c1, t2),
          c.call(f2mPrefix + "_sub", t2, b_b, t2)
        );
      }
      buildF6Mul1();
      function buildF6Mul01() {
        const f = module3.addFunction(f6mPrefix + "_mul01");
        f.addParam("pA", "i32");
        f.addParam("pC0", "i32");
        f.addParam("pC1", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const A_c0 = c.getLocal("pA");
        const A_c1 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 2));
        const A_c2 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 4));
        const c0 = c.getLocal("pC0");
        const c1 = c.getLocal("pC1");
        const t1 = c.getLocal("pR");
        const t2 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 2));
        const t3 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 4));
        const a_a = c.i32_const(module3.alloc(f1size * 2));
        const b_b = c.i32_const(module3.alloc(f1size * 2));
        const Ac0_Ac1 = c.i32_const(module3.alloc(f1size * 2));
        const Ac0_Ac2 = c.i32_const(module3.alloc(f1size * 2));
        f.addCode(
          // let a_a = self.c0 * c0;
          c.call(f2mPrefix + "_mul", A_c0, c0, a_a),
          // let b_b = self.c1 * c1;
          c.call(f2mPrefix + "_mul", A_c1, c1, b_b),
          c.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
          c.call(f2mPrefix + "_add", A_c0, A_c2, Ac0_Ac2),
          // let t1 = (self.c1 + self.c2) * c1 - b_b;
          c.call(f2mPrefix + "_add", A_c1, A_c2, t1),
          c.call(f2mPrefix + "_mul", t1, c1, t1),
          c.call(f2mPrefix + "_sub", t1, b_b, t1),
          // let t1 = t1.mul_by_nonresidue() + a_a;
          c.call(f2mPrefix + "_mulNR", t1, t1),
          c.call(f2mPrefix + "_add", t1, a_a, t1),
          // let t2 = (c0 + c1) * (self.c0 + self.c1) - a_a - b_b;
          c.call(f2mPrefix + "_add", c0, c1, t2),
          c.call(f2mPrefix + "_mul", t2, Ac0_Ac1, t2),
          c.call(f2mPrefix + "_sub", t2, a_a, t2),
          c.call(f2mPrefix + "_sub", t2, b_b, t2),
          // let t3 = (self.c0 + self.c2) * c0 - a_a + b_b;
          c.call(f2mPrefix + "_mul", Ac0_Ac2, c0, t3),
          c.call(f2mPrefix + "_sub", t3, a_a, t3),
          c.call(f2mPrefix + "_add", t3, b_b, t3)
        );
      }
      buildF6Mul01();
      function buildF12Mul014() {
        const f = module3.addFunction(ftmPrefix + "_mul014");
        f.addParam("pA", "i32");
        f.addParam("pC0", "i32");
        f.addParam("pC1", "i32");
        f.addParam("pC4", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const A_c0 = c.getLocal("pA");
        const A_c1 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 6));
        const c0 = c.getLocal("pC0");
        const c1 = c.getLocal("pC1");
        const c4 = c.getLocal("pC4");
        const aa = c.i32_const(module3.alloc(f1size * 6));
        const bb = c.i32_const(module3.alloc(f1size * 6));
        const o = c.i32_const(module3.alloc(f1size * 2));
        const R_c0 = c.getLocal("pR");
        const R_c1 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 6));
        f.addCode(
          // let aa = self.c0.mul_by_01(c0, c1);
          c.call(f6mPrefix + "_mul01", A_c0, c0, c1, aa),
          // let bb = self.c1.mul_by_1(c4);
          c.call(f6mPrefix + "_mul1", A_c1, c4, bb),
          // let o = c1 + c4;
          c.call(f2mPrefix + "_add", c1, c4, o),
          // let c1 = self.c1 + self.c0;
          c.call(f6mPrefix + "_add", A_c1, A_c0, R_c1),
          // let c1 = c1.mul_by_01(c0, &o);
          c.call(f6mPrefix + "_mul01", R_c1, c0, o, R_c1),
          // let c1 = c1 - aa - bb;
          c.call(f6mPrefix + "_sub", R_c1, aa, R_c1),
          c.call(f6mPrefix + "_sub", R_c1, bb, R_c1),
          // let c0 = bb;
          c.call(f6mPrefix + "_copy", bb, R_c0),
          // let c0 = c0.mul_by_nonresidue();
          c.call(f6mPrefix + "_mulNR", R_c0, R_c0),
          // let c0 = c0 + aa;
          c.call(f6mPrefix + "_add", R_c0, aa, R_c0)
        );
      }
      buildF12Mul014();
      function buildELL() {
        const f = module3.addFunction(prefix + "_ell");
        f.addParam("pP", "i32");
        f.addParam("pCoefs", "i32");
        f.addParam("pF", "i32");
        const c = f.getCodeBuilder();
        const Px = c.getLocal("pP");
        const Py = c.i32_add(c.getLocal("pP"), c.i32_const(n8q));
        const F = c.getLocal("pF");
        const coef0_0 = c.getLocal("pCoefs");
        const coef0_1 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size));
        const coef1_0 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size * 2));
        const coef1_1 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size * 3));
        const coef2 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size * 4));
        const pc0 = module3.alloc(f1size * 2);
        const c0 = c.i32_const(pc0);
        const c0_c0 = c.i32_const(pc0);
        const c0_c1 = c.i32_const(pc0 + f1size);
        const pc1 = module3.alloc(f1size * 2);
        const c1 = c.i32_const(pc1);
        const c1_c0 = c.i32_const(pc1);
        const c1_c1 = c.i32_const(pc1 + f1size);
        f.addCode(
          //     let mut c0 = coeffs.0;
          //     let mut c1 = coeffs.1;
          //
          //    c0.c0 *= p.y;
          //    c0.c1 *= p.y;
          //
          //    c1.c0 *= p.x;
          //    c1.c1 *= p.x;
          //
          //     f.mul_by_014(&coeffs.2, &c1, &c0)
          c.call(f1mPrefix + "_mul", coef0_0, Py, c0_c0),
          c.call(f1mPrefix + "_mul", coef0_1, Py, c0_c1),
          c.call(f1mPrefix + "_mul", coef1_0, Px, c1_c0),
          c.call(f1mPrefix + "_mul", coef1_1, Px, c1_c1),
          c.call(ftmPrefix + "_mul014", F, coef2, c1, c0, F)
        );
      }
      buildELL();
      function buildMillerLoop() {
        const f = module3.addFunction(prefix + "_millerLoop");
        f.addParam("ppreP", "i32");
        f.addParam("ppreQ", "i32");
        f.addParam("r", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const preP = c.getLocal("ppreP");
        const coefs = c.getLocal("pCoef");
        const F = c.getLocal("r");
        f.addCode(
          c.call(ftmPrefix + "_one", F),
          c.if(
            c.call(g1mPrefix + "_isZero", preP),
            c.ret([])
          ),
          c.if(
            c.call(g1mPrefix + "_isZero", c.getLocal("ppreQ")),
            c.ret([])
          ),
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3))),
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "_ell", preP, coefs, F),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(prefix + "_ell", preP, coefs, F),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.call(ftmPrefix + "_square", F, F),
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.i32_const(1))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          )),
          c.call(prefix + "_ell", preP, coefs, F)
        );
        if (isLoopNegative) {
          f.addCode(
            c.call(ftmPrefix + "_conjugate", F, F)
          );
        }
      }
      function buildFrobeniusMap(n) {
        const F12 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n, 151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],
            [2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n, 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n, 877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n],
            [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
            [151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n, 3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n, 2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
            [877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n, 3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n]
          ]
        ];
        const F6 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [0n, 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [0n, 1n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [0n, 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n]
          ],
          [
            [1n, 0n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n]
          ]
        ];
        const f = module3.addFunction(ftmPrefix + "_frobeniusMap" + n);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < 6; i++) {
          const X = i == 0 ? c.getLocal("x") : c.i32_add(c.getLocal("x"), c.i32_const(i * f2size));
          const Xc0 = X;
          const Xc1 = c.i32_add(c.getLocal("x"), c.i32_const(i * f2size + f1size));
          const R = i == 0 ? c.getLocal("r") : c.i32_add(c.getLocal("r"), c.i32_const(i * f2size));
          const Rc0 = R;
          const Rc1 = c.i32_add(c.getLocal("r"), c.i32_const(i * f2size + f1size));
          const coef = mul22(F12[Math.floor(i / 3)][n % 12], F6[i % 3][n % 6]);
          const pCoef = module3.alloc([
            ...utils2.bigInt2BytesLE(toMontgomery(coef[0]), n8q),
            ...utils2.bigInt2BytesLE(toMontgomery(coef[1]), n8q)
          ]);
          if (n % 2 == 1) {
            f.addCode(
              c.call(f1mPrefix + "_copy", Xc0, Rc0),
              c.call(f1mPrefix + "_neg", Xc1, Rc1),
              c.call(f2mPrefix + "_mul", R, c.i32_const(pCoef), R)
            );
          } else {
            f.addCode(c.call(f2mPrefix + "_mul", X, c.i32_const(pCoef), R));
          }
        }
        function mul22(a, b) {
          const ac0 = a[0];
          const ac1 = a[1];
          const bc0 = b[0];
          const bc1 = b[1];
          const res = [
            (ac0 * bc0 - ac1 * bc1) % q,
            (ac0 * bc1 + ac1 * bc0) % q
          ];
          if (isNegative5(res[0]))
            res[0] = res[0] + q;
          return res;
        }
      }
      function buildCyclotomicSquare() {
        const f = module3.addFunction(prefix + "__cyclotomicSquare");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x4 = c.i32_add(c.getLocal("x"), c.i32_const(f2size));
        const x3 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f2size));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(3 * f2size));
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(4 * f2size));
        const x5 = c.i32_add(c.getLocal("x"), c.i32_const(5 * f2size));
        const r0 = c.getLocal("r");
        const r4 = c.i32_add(c.getLocal("r"), c.i32_const(f2size));
        const r3 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f2size));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(3 * f2size));
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(4 * f2size));
        const r5 = c.i32_add(c.getLocal("r"), c.i32_const(5 * f2size));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t3 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        const tmp = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          //    // t0 + t1*y = (z0 + z1*y)^2 = a^2
          //    tmp = z0 * z1;
          //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;
          //    t1 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x0, x1, tmp),
          c.call(f2mPrefix + "_mulNR", x1, t0),
          c.call(f2mPrefix + "_add", x0, t0, t0),
          c.call(f2mPrefix + "_add", x0, x1, AUX),
          c.call(f2mPrefix + "_mul", AUX, t0, t0),
          c.call(f2mPrefix + "_mulNR", tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t0, AUX, t0),
          c.call(f2mPrefix + "_add", tmp, tmp, t1),
          //  // t2 + t3*y = (z2 + z3*y)^2 = b^2
          //  tmp = z2 * z3;
          //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;
          //  t3 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x2, x3, tmp),
          c.call(f2mPrefix + "_mulNR", x3, t2),
          c.call(f2mPrefix + "_add", x2, t2, t2),
          c.call(f2mPrefix + "_add", x2, x3, AUX),
          c.call(f2mPrefix + "_mul", AUX, t2, t2),
          c.call(f2mPrefix + "_mulNR", tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t2, AUX, t2),
          c.call(f2mPrefix + "_add", tmp, tmp, t3),
          //  // t4 + t5*y = (z4 + z5*y)^2 = c^2
          //  tmp = z4 * z5;
          //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;
          //  t5 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x4, x5, tmp),
          c.call(f2mPrefix + "_mulNR", x5, t4),
          c.call(f2mPrefix + "_add", x4, t4, t4),
          c.call(f2mPrefix + "_add", x4, x5, AUX),
          c.call(f2mPrefix + "_mul", AUX, t4, t4),
          c.call(f2mPrefix + "_mulNR", tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t4, AUX, t4),
          c.call(f2mPrefix + "_add", tmp, tmp, t5),
          // For A
          // z0 = 3 * t0 - 2 * z0
          c.call(f2mPrefix + "_sub", t0, x0, r0),
          c.call(f2mPrefix + "_add", r0, r0, r0),
          c.call(f2mPrefix + "_add", t0, r0, r0),
          // z1 = 3 * t1 + 2 * z1
          c.call(f2mPrefix + "_add", t1, x1, r1),
          c.call(f2mPrefix + "_add", r1, r1, r1),
          c.call(f2mPrefix + "_add", t1, r1, r1),
          // For B
          // z2 = 3 * (xi * t5) + 2 * z2
          c.call(f2mPrefix + "_mul", t5, c.i32_const(pBls12381Twist), AUX),
          c.call(f2mPrefix + "_add", AUX, x2, r2),
          c.call(f2mPrefix + "_add", r2, r2, r2),
          c.call(f2mPrefix + "_add", AUX, r2, r2),
          // z3 = 3 * t4 - 2 * z3
          c.call(f2mPrefix + "_sub", t4, x3, r3),
          c.call(f2mPrefix + "_add", r3, r3, r3),
          c.call(f2mPrefix + "_add", t4, r3, r3),
          // For C
          // z4 = 3 * t2 - 2 * z4
          c.call(f2mPrefix + "_sub", t2, x4, r4),
          c.call(f2mPrefix + "_add", r4, r4, r4),
          c.call(f2mPrefix + "_add", t2, r4, r4),
          // z5 = 3 * t3 + 2 * z5
          c.call(f2mPrefix + "_add", t3, x5, r5),
          c.call(f2mPrefix + "_add", r5, r5, r5),
          c.call(f2mPrefix + "_add", t3, r5, r5)
        );
      }
      function buildCyclotomicExp(exponent, isExpNegative, fnName) {
        const exponentNafBytes = naf4(exponent).map((b) => b == -1 ? 255 : b);
        const pExponentNafBytes = module3.alloc(exponentNafBytes);
        const f = module3.addFunction(prefix + "__cyclotomicExp_" + fnName);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("bit", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("x");
        const res = c.getLocal("r");
        const inverse = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          c.call(ftmPrefix + "_conjugate", x, inverse),
          c.call(ftmPrefix + "_one", res),
          c.if(
            c.teeLocal("bit", c.i32_load8_s(c.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
            c.if(
              c.i32_eq(
                c.getLocal("bit"),
                c.i32_const(1)
              ),
              c.call(ftmPrefix + "_mul", res, x, res),
              c.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c.setLocal("i", c.i32_const(exponentNafBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "__cyclotomicSquare", res, res),
            c.if(
              c.teeLocal("bit", c.i32_load8_s(c.getLocal("i"), pExponentNafBytes)),
              c.if(
                c.i32_eq(
                  c.getLocal("bit"),
                  c.i32_const(1)
                ),
                c.call(ftmPrefix + "_mul", res, x, res),
                c.call(ftmPrefix + "_mul", res, inverse, res)
              )
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
        if (isExpNegative) {
          f.addCode(
            c.call(ftmPrefix + "_conjugate", res, res)
          );
        }
      }
      function buildFinalExponentiation() {
        buildCyclotomicSquare();
        buildCyclotomicExp(finalExpZ, finalExpIsNegative, "w0");
        const f = module3.addFunction(prefix + "_finalExponentiation");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const res = c.getLocal("r");
        const t0 = c.i32_const(module3.alloc(ftsize));
        const t1 = c.i32_const(module3.alloc(ftsize));
        const t2 = c.i32_const(module3.alloc(ftsize));
        const t3 = c.i32_const(module3.alloc(ftsize));
        const t4 = c.i32_const(module3.alloc(ftsize));
        const t5 = c.i32_const(module3.alloc(ftsize));
        const t6 = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          // let mut t0 = f.frobenius_map(6)
          c.call(ftmPrefix + "_frobeniusMap6", elt, t0),
          // let t1 = f.invert()
          c.call(ftmPrefix + "_inverse", elt, t1),
          // let mut t2 = t0 * t1;
          c.call(ftmPrefix + "_mul", t0, t1, t2),
          // t1 = t2.clone();
          c.call(ftmPrefix + "_copy", t2, t1),
          // t2 = t2.frobenius_map().frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap2", t2, t2),
          // t2 *= t1;
          c.call(ftmPrefix + "_mul", t2, t1, t2),
          // t1 = cyclotomic_square(t2).conjugate();
          c.call(prefix + "__cyclotomicSquare", t2, t1),
          c.call(ftmPrefix + "_conjugate", t1, t1),
          // let mut t3 = cycolotomic_exp(t2);
          c.call(prefix + "__cyclotomicExp_w0", t2, t3),
          // let mut t4 = cyclotomic_square(t3);
          c.call(prefix + "__cyclotomicSquare", t3, t4),
          // let mut t5 = t1 * t3;
          c.call(ftmPrefix + "_mul", t1, t3, t5),
          // t1 = cycolotomic_exp(t5);
          c.call(prefix + "__cyclotomicExp_w0", t5, t1),
          // t0 = cycolotomic_exp(t1);
          c.call(prefix + "__cyclotomicExp_w0", t1, t0),
          // let mut t6 = cycolotomic_exp(t0);
          c.call(prefix + "__cyclotomicExp_w0", t0, t6),
          // t6 *= t4;
          c.call(ftmPrefix + "_mul", t6, t4, t6),
          // t4 = cycolotomic_exp(t6);
          c.call(prefix + "__cyclotomicExp_w0", t6, t4),
          // t5 = t5.conjugate();
          c.call(ftmPrefix + "_conjugate", t5, t5),
          // t4 *= t5 * t2;
          c.call(ftmPrefix + "_mul", t4, t5, t4),
          c.call(ftmPrefix + "_mul", t4, t2, t4),
          // t5 = t2.conjugate();
          c.call(ftmPrefix + "_conjugate", t2, t5),
          // t1 *= t2;
          c.call(ftmPrefix + "_mul", t1, t2, t1),
          // t1 = t1.frobenius_map().frobenius_map().frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap3", t1, t1),
          // t6 *= t5;
          c.call(ftmPrefix + "_mul", t6, t5, t6),
          // t6 = t6.frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap1", t6, t6),
          // t3 *= t0;
          c.call(ftmPrefix + "_mul", t3, t0, t3),
          // t3 = t3.frobenius_map().frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap2", t3, t3),
          // t3 *= t1;
          c.call(ftmPrefix + "_mul", t3, t1, t3),
          // t3 *= t6;
          c.call(ftmPrefix + "_mul", t3, t6, t3),
          // f = t3 * t4;
          c.call(ftmPrefix + "_mul", t3, t4, res)
        );
      }
      function buildFinalExponentiationOld() {
        const f = module3.addFunction(prefix + "_finalExponentiationOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const exponent = 322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n;
        const pExponent = module3.alloc(utils2.bigInt2BytesLE(exponent, 544));
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(ftmPrefix + "_exp", c.getLocal("x"), c.i32_const(pExponent), c.i32_const(544), c.getLocal("r"))
        );
      }
      const pPreP = module3.alloc(prePSize);
      const pPreQ = module3.alloc(preQSize);
      function buildPairingEquation(nPairings) {
        const f = module3.addFunction(prefix + "_pairingEq" + nPairings);
        for (let i = 0; i < nPairings; i++) {
          f.addParam("p_" + i, "i32");
          f.addParam("q_" + i, "i32");
        }
        f.addParam("c", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        const auxT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(ftmPrefix + "_one", resT));
        for (let i = 0; i < nPairings; i++) {
          f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p_" + i), c.i32_const(pPreP)));
          f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q_" + i), c.i32_const(pPreQ)));
          f.addCode(
            c.if(
              c.i32_eqz(c.call(g1mPrefix + "_inGroupAffine", c.i32_const(pPreP))),
              c.ret(c.i32_const(0))
            ),
            c.if(
              c.i32_eqz(c.call(g2mPrefix + "_inGroupAffine", c.i32_const(pPreQ))),
              c.ret(c.i32_const(0))
            )
          );
          f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), auxT));
          f.addCode(c.call(ftmPrefix + "_mul", resT, auxT, resT));
        }
        f.addCode(c.call(prefix + "_finalExponentiation", resT, resT));
        f.addCode(c.call(ftmPrefix + "_eq", resT, c.getLocal("c")));
      }
      function buildPairing4() {
        const f = module3.addFunction(prefix + "_pairing");
        f.addParam("p", "i32");
        f.addParam("q", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p"), c.i32_const(pPreP)));
        f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q"), c.i32_const(pPreQ)));
        f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), resT));
        f.addCode(c.call(prefix + "_finalExponentiation", resT, c.getLocal("r")));
      }
      function buildInGroupG2() {
        const f = module3.addFunction(g2mPrefix + "_inGroupAffine");
        f.addParam("p", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const WINV = [
          2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279894n,
          2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893n
        ];
        const FROB2X = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
        const FROB3Y = [
          2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,
          2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n
        ];
        const wInv = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery(WINV[0]), n8q),
          ...utils2.bigInt2BytesLE(toMontgomery(WINV[1]), n8q)
        ]));
        const frob2X = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(FROB2X), n8q)));
        const frob3Y = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery(FROB3Y[0]), n8q),
          ...utils2.bigInt2BytesLE(toMontgomery(FROB3Y[1]), n8q)
        ]));
        const z = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(finalExpZ, 8)));
        const px = c.getLocal("p");
        const py = c.i32_add(c.getLocal("p"), c.i32_const(f2size));
        const aux = c.i32_const(module3.alloc(f1size));
        const x_winv = c.i32_const(module3.alloc(f2size));
        const y_winv = c.i32_const(module3.alloc(f2size));
        const pf2 = module3.alloc(f2size * 2);
        const f2 = c.i32_const(pf2);
        const f2x = c.i32_const(pf2);
        const f2x_c1 = c.i32_const(pf2);
        const f2x_c2 = c.i32_const(pf2 + f1size);
        const f2y = c.i32_const(pf2 + f2size);
        const f2y_c1 = c.i32_const(pf2 + f2size);
        const f2y_c2 = c.i32_const(pf2 + f2size + f1size);
        const pf3 = module3.alloc(f2size * 3);
        const f3 = c.i32_const(pf3);
        const f3x = c.i32_const(pf3);
        const f3x_c1 = c.i32_const(pf3);
        const f3x_c2 = c.i32_const(pf3 + f1size);
        const f3y = c.i32_const(pf3 + f2size);
        const f3y_c1 = c.i32_const(pf3 + f2size);
        const f3y_c2 = c.i32_const(pf3 + f2size + f1size);
        const f3z = c.i32_const(pf3 + f2size * 2);
        f.addCode(
          c.if(
            c.call(g2mPrefix + "_isZeroAffine", c.getLocal("p")),
            c.ret(c.i32_const(1))
          ),
          c.if(
            c.i32_eqz(c.call(g2mPrefix + "_inCurveAffine", c.getLocal("p"))),
            c.ret(c.i32_const(0))
          ),
          c.call(f2mPrefix + "_mul", px, wInv, x_winv),
          c.call(f2mPrefix + "_mul", py, wInv, y_winv),
          c.call(f2mPrefix + "_mul1", x_winv, frob2X, f2x),
          c.call(f2mPrefix + "_neg", y_winv, f2y),
          c.call(f2mPrefix + "_neg", x_winv, f3x),
          c.call(f2mPrefix + "_mul", y_winv, frob3Y, f3y),
          c.call(f1mPrefix + "_sub", f2x_c1, f2x_c2, aux),
          c.call(f1mPrefix + "_add", f2x_c1, f2x_c2, f2x_c2),
          c.call(f1mPrefix + "_copy", aux, f2x_c1),
          c.call(f1mPrefix + "_sub", f2y_c1, f2y_c2, aux),
          c.call(f1mPrefix + "_add", f2y_c1, f2y_c2, f2y_c2),
          c.call(f1mPrefix + "_copy", aux, f2y_c1),
          c.call(f1mPrefix + "_add", f3x_c1, f3x_c2, aux),
          c.call(f1mPrefix + "_sub", f3x_c1, f3x_c2, f3x_c2),
          c.call(f1mPrefix + "_copy", aux, f3x_c1),
          c.call(f1mPrefix + "_sub", f3y_c2, f3y_c1, aux),
          c.call(f1mPrefix + "_add", f3y_c1, f3y_c2, f3y_c2),
          c.call(f1mPrefix + "_copy", aux, f3y_c1),
          c.call(f2mPrefix + "_one", f3z),
          c.call(g2mPrefix + "_timesScalar", f3, z, c.i32_const(8), f3),
          c.call(g2mPrefix + "_addMixed", f3, f2, f3),
          c.ret(
            c.call(g2mPrefix + "_eqMixed", f3, c.getLocal("p"))
          )
        );
        const fInGroup = module3.addFunction(g2mPrefix + "_inGroup");
        fInGroup.addParam("pIn", "i32");
        fInGroup.setReturnType("i32");
        const c2 = fInGroup.getCodeBuilder();
        const aux2 = c2.i32_const(module3.alloc(f2size * 2));
        fInGroup.addCode(
          c2.call(g2mPrefix + "_toAffine", c2.getLocal("pIn"), aux2),
          c2.ret(
            c2.call(g2mPrefix + "_inGroupAffine", aux2)
          )
        );
      }
      function buildInGroupG1() {
        const f = module3.addFunction(g1mPrefix + "_inGroupAffine");
        f.addParam("p", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const BETA = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
        const BETA2 = 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n;
        const Z2M1D3 = (finalExpZ * finalExpZ - 1n) / 3n;
        const beta = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(BETA), n8q)));
        const beta2 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(BETA2), n8q)));
        const z2m1d3 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(Z2M1D3, 16)));
        const px = c.getLocal("p");
        const py = c.i32_add(c.getLocal("p"), c.i32_const(f1size));
        const psp = module3.alloc(f1size * 3);
        const sp = c.i32_const(psp);
        const spx = c.i32_const(psp);
        const spy = c.i32_const(psp + f1size);
        const ps2p = module3.alloc(f1size * 2);
        const s2p = c.i32_const(ps2p);
        const s2px = c.i32_const(ps2p);
        const s2py = c.i32_const(ps2p + f1size);
        f.addCode(
          c.if(
            c.call(g1mPrefix + "_isZeroAffine", c.getLocal("p")),
            c.ret(c.i32_const(1))
          ),
          c.if(
            c.i32_eqz(c.call(g1mPrefix + "_inCurveAffine", c.getLocal("p"))),
            c.ret(c.i32_const(0))
          ),
          c.call(f1mPrefix + "_mul", px, beta, spx),
          c.call(f1mPrefix + "_copy", py, spy),
          c.call(f1mPrefix + "_mul", px, beta2, s2px),
          c.call(f1mPrefix + "_copy", py, s2py),
          c.call(g1mPrefix + "_doubleAffine", sp, sp),
          c.call(g1mPrefix + "_subMixed", sp, c.getLocal("p"), sp),
          c.call(g1mPrefix + "_subMixed", sp, s2p, sp),
          c.call(g1mPrefix + "_timesScalar", sp, z2m1d3, c.i32_const(16), sp),
          c.ret(
            c.call(g1mPrefix + "_eqMixed", sp, s2p)
          )
        );
        const fInGroup = module3.addFunction(g1mPrefix + "_inGroup");
        fInGroup.addParam("pIn", "i32");
        fInGroup.setReturnType("i32");
        const c2 = fInGroup.getCodeBuilder();
        const aux2 = c2.i32_const(module3.alloc(f1size * 2));
        fInGroup.addCode(
          c2.call(g1mPrefix + "_toAffine", c2.getLocal("pIn"), aux2),
          c2.ret(
            c2.call(g1mPrefix + "_inGroupAffine", aux2)
          )
        );
      }
      for (let i = 0; i < 10; i++) {
        buildFrobeniusMap(i);
        module3.exportFunction(ftmPrefix + "_frobeniusMap" + i);
      }
      buildInGroupG1();
      buildInGroupG2();
      buildPrepAddStep();
      buildPrepDoubleStep();
      buildPrepareG1();
      buildPrepareG2();
      buildMillerLoop();
      buildFinalExponentiationOld();
      buildFinalExponentiation();
      for (let i = 1; i <= 5; i++) {
        buildPairingEquation(i);
        module3.exportFunction(prefix + "_pairingEq" + i);
      }
      buildPairing4();
      module3.exportFunction(prefix + "_pairing");
      module3.exportFunction(prefix + "_prepareG1");
      module3.exportFunction(prefix + "_prepareG2");
      module3.exportFunction(prefix + "_millerLoop");
      module3.exportFunction(prefix + "_finalExponentiation");
      module3.exportFunction(prefix + "_finalExponentiationOld");
      module3.exportFunction(prefix + "__cyclotomicSquare");
      module3.exportFunction(prefix + "__cyclotomicExp_w0");
      module3.exportFunction(f6mPrefix + "_mul1");
      module3.exportFunction(f6mPrefix + "_mul01");
      module3.exportFunction(ftmPrefix + "_mul014");
      module3.exportFunction(g1mPrefix + "_inGroupAffine");
      module3.exportFunction(g1mPrefix + "_inGroup");
      module3.exportFunction(g2mPrefix + "_inGroupAffine");
      module3.exportFunction(g2mPrefix + "_inGroup");
    };
  }
});

// ../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/index.js
var require_wasmcurves = __commonJS({
  "../../node_modules/@iden3/binfileutils/node_modules/wasmcurves/index.js"(exports, module2) {
    "use strict";
    module2.exports.buildBn128 = require_build_bn128();
    module2.exports.buildBls12381 = require_build_bls12381();
    module2.exports.buildF1m = require_build_f1m();
  }
});

// ../../node_modules/web-worker/cjs/node.js
var require_node = __commonJS({
  "../../node_modules/web-worker/cjs/node.js"(exports, module2) {
    "use strict";
    var URL2 = require("url");
    var VM = require("vm");
    var threads = require("worker_threads");
    var WORKER = Symbol.for("worker");
    var EVENTS = Symbol.for("events");
    var EventTarget = class {
      constructor() {
        Object.defineProperty(this, EVENTS, {
          value: /* @__PURE__ */ new Map()
        });
      }
      dispatchEvent(event) {
        event.target = event.currentTarget = this;
        if (this["on" + event.type]) {
          try {
            this["on" + event.type](event);
          } catch (err) {
            console.error(err);
          }
        }
        const list = this[EVENTS].get(event.type);
        if (list == null)
          return;
        list.forEach((handler) => {
          try {
            handler.call(this, event);
          } catch (err) {
            console.error(err);
          }
        });
      }
      addEventListener(type, fn) {
        let events = this[EVENTS].get(type);
        if (!events)
          this[EVENTS].set(type, events = []);
        events.push(fn);
      }
      removeEventListener(type, fn) {
        let events = this[EVENTS].get(type);
        if (events) {
          const index = events.indexOf(fn);
          if (index !== -1)
            events.splice(index, 1);
        }
      }
    };
    function Event(type, target) {
      this.type = type;
      this.timeStamp = Date.now();
      this.target = this.currentTarget = this.data = null;
    }
    module2.exports = threads.isMainThread ? mainThread() : workerThread();
    var baseUrl = URL2.pathToFileURL(process.cwd() + "/");
    function mainThread() {
      class Worker4 extends EventTarget {
        constructor(url2, options) {
          super();
          const {
            name,
            type
          } = options || {};
          url2 += "";
          let mod4;
          if (/^data:/.test(url2)) {
            mod4 = url2;
          } else {
            mod4 = URL2.fileURLToPath(new URL2.URL(url2, baseUrl));
          }
          const worker = new threads.Worker(__filename, {
            workerData: {
              mod: mod4,
              name,
              type
            }
          });
          Object.defineProperty(this, WORKER, {
            value: worker
          });
          worker.on("message", (data) => {
            const event = new Event("message");
            event.data = data;
            this.dispatchEvent(event);
          });
          worker.on("error", (error) => {
            error.type = "error";
            this.dispatchEvent(error);
          });
          worker.on("exit", () => {
            this.dispatchEvent(new Event("close"));
          });
        }
        postMessage(data, transferList) {
          this[WORKER].postMessage(data, transferList);
        }
        terminate() {
          this[WORKER].terminate();
        }
      }
      Worker4.prototype.onmessage = Worker4.prototype.onerror = Worker4.prototype.onclose = null;
      return Worker4;
    }
    function workerThread() {
      let {
        mod: mod4,
        name,
        type
      } = threads.workerData;
      const self2 = global.self = global;
      let q = [];
      function flush() {
        const buffered = q;
        q = null;
        buffered.forEach((event) => {
          self2.dispatchEvent(event);
        });
      }
      threads.parentPort.on("message", (data) => {
        const event = new Event("message");
        event.data = data;
        if (q == null)
          self2.dispatchEvent(event);
        else
          q.push(event);
      });
      threads.parentPort.on("error", (err) => {
        err.type = "Error";
        self2.dispatchEvent(err);
      });
      class WorkerGlobalScope extends EventTarget {
        postMessage(data, transferList) {
          threads.parentPort.postMessage(data, transferList);
        }
        // Emulates https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope/close
        close() {
          process.exit();
        }
      }
      let proto = Object.getPrototypeOf(global);
      delete proto.constructor;
      Object.defineProperties(WorkerGlobalScope.prototype, proto);
      proto = Object.setPrototypeOf(global, new WorkerGlobalScope());
      ["postMessage", "addEventListener", "removeEventListener", "dispatchEvent"].forEach((fn) => {
        proto[fn] = proto[fn].bind(global);
      });
      global.name = name;
      const isDataUrl = /^data:/.test(mod4);
      if (type === "module") {
        import(mod4).catch((err) => {
          if (isDataUrl && err.message === "Not supported") {
            console.warn("Worker(): Importing data: URLs requires Node 12.10+. Falling back to classic worker.");
            return evaluateDataUrl(mod4, name);
          }
          console.error(err);
        }).then(flush);
      } else {
        try {
          if (/^data:/.test(mod4)) {
            evaluateDataUrl(mod4, name);
          } else {
            require(mod4);
          }
        } catch (err) {
          console.error(err);
        }
        Promise.resolve().then(flush);
      }
    }
    function evaluateDataUrl(url2, name) {
      const {
        data
      } = parseDataUrl(url2);
      return VM.runInThisContext(data, {
        filename: "worker.<" + (name || "data:") + ">"
      });
    }
    function parseDataUrl(url2) {
      let [m, type, encoding, data] = url2.match(/^data: *([^;,]*)(?: *; *([^,]*))? *,(.*)$/) || [];
      if (!m)
        throw Error("Invalid Data URL.");
      if (encoding)
        switch (encoding.toLowerCase()) {
          case "base64":
            data = Buffer.from(data, "base64").toString();
            break;
          default:
            throw Error('Unknown Data URL encoding "' + encoding + '"');
        }
      return {
        type,
        data
      };
    }
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/utils.js"(exports) {
    "use strict";
    exports.bigInt2BytesLE = function bigInt2BytesLE(_a, len) {
      const b = Array(len);
      let v = BigInt(_a);
      for (let i = 0; i < len; i++) {
        b[i] = Number(v & 0xFFn);
        v = v >> 8n;
      }
      return b;
    };
    exports.bigInt2U32LE = function bigInt2BytesLE(_a, len) {
      const b = Array(len);
      let v = BigInt(_a);
      for (let i = 0; i < len; i++) {
        b[i] = Number(v & 0xFFFFFFFFn);
        v = v >> 32n;
      }
      return b;
    };
    exports.isOcamNum = function(a) {
      if (!Array.isArray(a))
        return false;
      if (a.length != 3)
        return false;
      if (typeof a[0] !== "number")
        return false;
      if (typeof a[1] !== "number")
        return false;
      if (!Array.isArray(a[2]))
        return false;
      return true;
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_int.js
var require_build_int2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_int.js"(exports, module2) {
    "use strict";
    module2.exports = function buildInt(module3, n64, _prefix) {
      const prefix = _prefix || "int";
      if (module3.modules[prefix])
        return prefix;
      module3.modules[prefix] = {};
      const n32 = n64 * 2;
      const n8 = n64 * 8;
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("px", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pr"),
              i * 8,
              c.i64_load(
                c.getLocal("px"),
                i * 8
              )
            )
          );
        }
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pr"),
              i * 8,
              c.i64_const(0)
            )
          );
        }
      }
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.i64_store(
            c.getLocal("pr"),
            0,
            c.i64_const(1)
          )
        );
        for (let i = 1; i < n64; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pr"),
              i * 8,
              c.i64_const(0)
            )
          );
        }
      }
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("px", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c.ret(c.i64_eqz(
              c.i64_load(c.getLocal("px"))
            ));
          }
          return c.if(
            c.i64_eqz(
              c.i64_load(c.getLocal("px"), n * 8)
            ),
            getCompCode(n - 1),
            c.ret(c.i32_const(0))
          );
        }
        f.addCode(getCompCode(n64 - 1));
        f.addCode(c.ret(c.i32_const(0)));
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("px", "i32");
        f.addParam("py", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c.ret(c.i64_eq(
              c.i64_load(c.getLocal("px")),
              c.i64_load(c.getLocal("py"))
            ));
          }
          return c.if(
            c.i64_eq(
              c.i64_load(c.getLocal("px"), n * 8),
              c.i64_load(c.getLocal("py"), n * 8)
            ),
            getCompCode(n - 1),
            c.ret(c.i32_const(0))
          );
        }
        f.addCode(getCompCode(n64 - 1));
        f.addCode(c.ret(c.i32_const(0)));
      }
      function buildGte() {
        const f = module3.addFunction(prefix + "_gte");
        f.addParam("px", "i32");
        f.addParam("py", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c.ret(c.i64_ge_u(
              c.i64_load(c.getLocal("px")),
              c.i64_load(c.getLocal("py"))
            ));
          }
          return c.if(
            c.i64_lt_u(
              c.i64_load(c.getLocal("px"), n * 8),
              c.i64_load(c.getLocal("py"), n * 8)
            ),
            c.ret(c.i32_const(0)),
            c.if(
              c.i64_gt_u(
                c.i64_load(c.getLocal("px"), n * 8),
                c.i64_load(c.getLocal("py"), n * 8)
              ),
              c.ret(c.i32_const(1)),
              getCompCode(n - 1)
            )
          );
        }
        f.addCode(getCompCode(n64 - 1));
        f.addCode(c.ret(c.i32_const(0)));
      }
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.setReturnType("i32");
        f.addLocal("c", "i64");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal(
          "c",
          c.i64_add(
            c.i64_load32_u(c.getLocal("x")),
            c.i64_load32_u(c.getLocal("y"))
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("r"),
          c.getLocal("c")
        ));
        for (let i = 1; i < n32; i++) {
          f.addCode(c.setLocal(
            "c",
            c.i64_add(
              c.i64_add(
                c.i64_load32_u(c.getLocal("x"), 4 * i),
                c.i64_load32_u(c.getLocal("y"), 4 * i)
              ),
              c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
            )
          ));
          f.addCode(c.i64_store32(
            c.getLocal("r"),
            i * 4,
            c.getLocal("c")
          ));
        }
        f.addCode(c.i32_wrap_i64(c.i64_shr_u(c.getLocal("c"), c.i64_const(32))));
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.setReturnType("i32");
        f.addLocal("c", "i64");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal(
          "c",
          c.i64_sub(
            c.i64_load32_u(c.getLocal("x")),
            c.i64_load32_u(c.getLocal("y"))
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("r"),
          c.i64_and(
            c.getLocal("c"),
            c.i64_const("0xFFFFFFFF")
          )
        ));
        for (let i = 1; i < n32; i++) {
          f.addCode(c.setLocal(
            "c",
            c.i64_add(
              c.i64_sub(
                c.i64_load32_u(c.getLocal("x"), 4 * i),
                c.i64_load32_u(c.getLocal("y"), 4 * i)
              ),
              c.i64_shr_s(c.getLocal("c"), c.i64_const(32))
            )
          ));
          f.addCode(c.i64_store32(
            c.getLocal("r"),
            i * 4,
            c.i64_and(c.getLocal("c"), c.i64_const("0xFFFFFFFF"))
          ));
        }
        f.addCode(c.i32_wrap_i64(c.i64_shr_s(c.getLocal("c"), c.i64_const(32))));
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
          f.addLocal("y" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const loadX = [];
        const loadY = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadY[j]) {
            Y = c.teeLocal("y" + j, c.i64_load32_u(c.getLocal("y"), j * 4));
            loadY[j] = true;
          } else {
            Y = c.getLocal("y" + j);
          }
          return c.i64_mul(X, Y);
        }
        let c0 = "c0";
        let c1 = "c1";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          for (let i = Math.max(0, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          f.addCode(
            c.i64_store32(
              c.getLocal("r"),
              k * 4,
              c.getLocal(c0)
            )
          );
          [c0, c1] = [c1, c0];
          f.addCode(
            c.setLocal(
              c1,
              c.i64_shr_u(
                c.getLocal(c0),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 * 2 - 4,
            c.getLocal(c0)
          )
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        f.addLocal("c0_old", "i64");
        f.addLocal("c1_old", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const loadX = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadX[j]) {
            Y = c.teeLocal("x" + j, c.i64_load32_u(c.getLocal("x"), j * 4));
            loadX[j] = true;
          } else {
            Y = c.getLocal("x" + j);
          }
          return c.i64_mul(X, Y);
        }
        let c0 = "c0";
        let c1 = "c1";
        let c0_old = "c0_old";
        let c1_old = "c1_old";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          f.addCode(
            c.setLocal(c0, c.i64_const(0)),
            c.setLocal(c1, c.i64_const(0))
          );
          for (let i = Math.max(0, k - n32 + 1); i < k + 1 >> 1 && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          f.addCode(
            c.setLocal(
              c0,
              c.i64_shl(
                c.i64_and(
                  c.getLocal(c0),
                  c.i64_const(4294967295)
                ),
                c.i64_const(1)
              )
            )
          );
          f.addCode(
            c.setLocal(
              c1,
              c.i64_add(
                c.i64_shl(
                  c.getLocal(c1),
                  c.i64_const(1)
                ),
                c.i64_shr_u(
                  c.getLocal(c0),
                  c.i64_const(32)
                )
              )
            )
          );
          if (k % 2 == 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(k >> 1, k >> 1)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k > 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  c.i64_and(
                    c.getLocal(c0_old),
                    c.i64_const(4294967295)
                  )
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.i64_add(
                    c.getLocal(c1),
                    c.i64_shr_u(
                      c.getLocal(c0),
                      c.i64_const(32)
                    )
                  ),
                  c.getLocal(c1_old)
                )
              )
            );
          }
          f.addCode(
            c.i64_store32(
              c.getLocal("r"),
              k * 4,
              c.getLocal(c0)
            )
          );
          f.addCode(
            c.setLocal(
              c0_old,
              c.getLocal(c1)
            ),
            c.setLocal(
              c1_old,
              c.i64_shr_u(
                c.getLocal(c0_old),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 * 2 - 4,
            c.getLocal(c0_old)
          )
        );
      }
      function buildSquareOld() {
        const f = module3.addFunction(prefix + "_squareOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.getLocal("x"), c.getLocal("r")));
      }
      function _buildMul1() {
        const f = module3.addFunction(prefix + "__mul1");
        f.addParam("px", "i32");
        f.addParam("y", "i64");
        f.addParam("pr", "i32");
        f.addLocal("c", "i64");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal(
          "c",
          c.i64_mul(
            c.i64_load32_u(c.getLocal("px"), 0, 0),
            c.getLocal("y")
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("pr"),
          0,
          0,
          c.getLocal("c")
        ));
        for (let i = 1; i < n32; i++) {
          f.addCode(c.setLocal(
            "c",
            c.i64_add(
              c.i64_mul(
                c.i64_load32_u(c.getLocal("px"), 4 * i, 0),
                c.getLocal("y")
              ),
              c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
            )
          ));
          f.addCode(c.i64_store32(
            c.getLocal("pr"),
            i * 4,
            0,
            c.getLocal("c")
          ));
        }
      }
      function _buildAdd1() {
        const f = module3.addFunction(prefix + "__add1");
        f.addParam("x", "i32");
        f.addParam("y", "i64");
        f.addLocal("c", "i64");
        f.addLocal("px", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal("px", c.getLocal("x")));
        f.addCode(c.setLocal(
          "c",
          c.i64_add(
            c.i64_load32_u(c.getLocal("px"), 0, 0),
            c.getLocal("y")
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("px"),
          0,
          0,
          c.getLocal("c")
        ));
        f.addCode(c.setLocal(
          "c",
          c.i64_shr_u(
            c.getLocal("c"),
            c.i64_const(32)
          )
        ));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.i64_eqz(c.getLocal("c"))
          ),
          c.setLocal(
            "px",
            c.i32_add(
              c.getLocal("px"),
              c.i32_const(4)
            )
          ),
          c.setLocal(
            "c",
            c.i64_add(
              c.i64_load32_u(c.getLocal("px"), 0, 0),
              c.getLocal("c")
            )
          ),
          c.i64_store32(
            c.getLocal("px"),
            0,
            0,
            c.getLocal("c")
          ),
          c.setLocal(
            "c",
            c.i64_shr_u(
              c.getLocal("c"),
              c.i64_const(32)
            )
          ),
          c.br(0)
        )));
      }
      function buildDiv() {
        _buildMul1();
        _buildAdd1();
        const f = module3.addFunction(prefix + "_div");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("c", "i32");
        f.addParam("r", "i32");
        f.addLocal("rr", "i32");
        f.addLocal("cc", "i32");
        f.addLocal("eX", "i32");
        f.addLocal("eY", "i32");
        f.addLocal("sy", "i64");
        f.addLocal("sx", "i64");
        f.addLocal("ec", "i32");
        const c = f.getCodeBuilder();
        const Y = c.i32_const(module3.alloc(n8));
        const Caux = c.i32_const(module3.alloc(n8));
        const Raux = c.i32_const(module3.alloc(n8));
        const C = c.getLocal("cc");
        const R = c.getLocal("rr");
        const pr1 = module3.alloc(n8 * 2);
        const R1 = c.i32_const(pr1);
        const R2 = c.i32_const(pr1 + n8);
        f.addCode(c.if(
          c.getLocal("c"),
          c.setLocal("cc", c.getLocal("c")),
          c.setLocal("cc", Caux)
        ));
        f.addCode(c.if(
          c.getLocal("r"),
          c.setLocal("rr", c.getLocal("r")),
          c.setLocal("rr", Raux)
        ));
        f.addCode(c.call(prefix + "_copy", c.getLocal("x"), R));
        f.addCode(c.call(prefix + "_copy", c.getLocal("y"), Y));
        f.addCode(c.call(prefix + "_zero", C));
        f.addCode(c.call(prefix + "_zero", R1));
        f.addCode(c.setLocal("eX", c.i32_const(n8 - 1)));
        f.addCode(c.setLocal("eY", c.i32_const(n8 - 1)));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.i32_or(
              c.i32_load8_u(
                c.i32_add(Y, c.getLocal("eY")),
                0,
                0
              ),
              c.i32_eq(
                c.getLocal("eY"),
                c.i32_const(3)
              )
            )
          ),
          c.setLocal("eY", c.i32_sub(c.getLocal("eY"), c.i32_const(1))),
          c.br(0)
        )));
        f.addCode(
          c.setLocal(
            "sy",
            c.i64_add(
              c.i64_load32_u(
                c.i32_sub(
                  c.i32_add(Y, c.getLocal("eY")),
                  c.i32_const(3)
                ),
                0,
                0
              ),
              c.i64_const(1)
            )
          )
        );
        f.addCode(
          c.if(
            c.i64_eq(
              c.getLocal("sy"),
              c.i64_const(1)
            ),
            c.drop(c.i64_div_u(c.i64_const(0), c.i64_const(0)))
          )
        );
        f.addCode(c.block(c.loop(
          // while (eX>7)&&(Y[eX]==0) ex--;
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_or(
                c.i32_load8_u(
                  c.i32_add(R, c.getLocal("eX")),
                  0,
                  0
                ),
                c.i32_eq(
                  c.getLocal("eX"),
                  c.i32_const(7)
                )
              )
            ),
            c.setLocal("eX", c.i32_sub(c.getLocal("eX"), c.i32_const(1))),
            c.br(0)
          )),
          c.setLocal(
            "sx",
            c.i64_load(
              c.i32_sub(
                c.i32_add(R, c.getLocal("eX")),
                c.i32_const(7)
              ),
              0,
              0
            )
          ),
          c.setLocal(
            "sx",
            c.i64_div_u(
              c.getLocal("sx"),
              c.getLocal("sy")
            )
          ),
          c.setLocal(
            "ec",
            c.i32_sub(
              c.i32_sub(
                c.getLocal("eX"),
                c.getLocal("eY")
              ),
              c.i32_const(4)
            )
          ),
          // While greater than 32 bits or ec is neg, shr and inc exp
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_and(
                c.i64_eqz(
                  c.i64_and(
                    c.getLocal("sx"),
                    c.i64_const("0xFFFFFFFF00000000")
                  )
                ),
                c.i32_ge_s(
                  c.getLocal("ec"),
                  c.i32_const(0)
                )
              )
            ),
            c.setLocal(
              "sx",
              c.i64_shr_u(
                c.getLocal("sx"),
                c.i64_const(8)
              )
            ),
            c.setLocal(
              "ec",
              c.i32_add(
                c.getLocal("ec"),
                c.i32_const(1)
              )
            ),
            c.br(0)
          )),
          c.if(
            c.i64_eqz(c.getLocal("sx")),
            [
              ...c.br_if(
                2,
                c.i32_eqz(c.call(prefix + "_gte", R, Y))
              ),
              ...c.setLocal("sx", c.i64_const(1)),
              ...c.setLocal("ec", c.i32_const(0))
            ]
          ),
          c.call(prefix + "__mul1", Y, c.getLocal("sx"), R2),
          c.drop(c.call(
            prefix + "_sub",
            R,
            c.i32_sub(R2, c.getLocal("ec")),
            R
          )),
          c.call(
            prefix + "__add1",
            c.i32_add(C, c.getLocal("ec")),
            c.getLocal("sx")
          ),
          c.br(0)
        )));
      }
      function buildInverseMod() {
        const f = module3.addFunction(prefix + "_inverseMod");
        f.addParam("px", "i32");
        f.addParam("pm", "i32");
        f.addParam("pr", "i32");
        f.addLocal("t", "i32");
        f.addLocal("newt", "i32");
        f.addLocal("r", "i32");
        f.addLocal("qq", "i32");
        f.addLocal("qr", "i32");
        f.addLocal("newr", "i32");
        f.addLocal("swp", "i32");
        f.addLocal("x", "i32");
        f.addLocal("signt", "i32");
        f.addLocal("signnewt", "i32");
        f.addLocal("signx", "i32");
        const c = f.getCodeBuilder();
        const aux1 = c.i32_const(module3.alloc(n8));
        const aux2 = c.i32_const(module3.alloc(n8));
        const aux3 = c.i32_const(module3.alloc(n8));
        const aux4 = c.i32_const(module3.alloc(n8));
        const aux5 = c.i32_const(module3.alloc(n8));
        const aux6 = c.i32_const(module3.alloc(n8));
        const mulBuff = c.i32_const(module3.alloc(n8 * 2));
        const aux7 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("t", aux1),
          c.call(prefix + "_zero", aux1),
          c.setLocal("signt", c.i32_const(0))
        );
        f.addCode(
          c.setLocal("r", aux2),
          c.call(prefix + "_copy", c.getLocal("pm"), aux2)
        );
        f.addCode(
          c.setLocal("newt", aux3),
          c.call(prefix + "_one", aux3),
          c.setLocal("signnewt", c.i32_const(0))
        );
        f.addCode(
          c.setLocal("newr", aux4),
          c.call(prefix + "_copy", c.getLocal("px"), aux4)
        );
        f.addCode(c.setLocal("qq", aux5));
        f.addCode(c.setLocal("qr", aux6));
        f.addCode(c.setLocal("x", aux7));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.call(prefix + "_isZero", c.getLocal("newr"))
          ),
          c.call(prefix + "_div", c.getLocal("r"), c.getLocal("newr"), c.getLocal("qq"), c.getLocal("qr")),
          c.call(prefix + "_mul", c.getLocal("qq"), c.getLocal("newt"), mulBuff),
          c.if(
            c.getLocal("signt"),
            c.if(
              c.getLocal("signnewt"),
              c.if(
                c.call(prefix + "_gte", mulBuff, c.getLocal("t")),
                [
                  ...c.drop(c.call(prefix + "_sub", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(0))
                ],
                [
                  ...c.drop(c.call(prefix + "_sub", c.getLocal("t"), mulBuff, c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(1))
                ]
              ),
              [
                ...c.drop(c.call(prefix + "_add", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                ...c.setLocal("signx", c.i32_const(1))
              ]
            ),
            c.if(
              c.getLocal("signnewt"),
              [
                ...c.drop(c.call(prefix + "_add", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                ...c.setLocal("signx", c.i32_const(0))
              ],
              c.if(
                c.call(prefix + "_gte", c.getLocal("t"), mulBuff),
                [
                  ...c.drop(c.call(prefix + "_sub", c.getLocal("t"), mulBuff, c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(0))
                ],
                [
                  ...c.drop(c.call(prefix + "_sub", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(1))
                ]
              )
            )
          ),
          c.setLocal("swp", c.getLocal("t")),
          c.setLocal("t", c.getLocal("newt")),
          c.setLocal("newt", c.getLocal("x")),
          c.setLocal("x", c.getLocal("swp")),
          c.setLocal("signt", c.getLocal("signnewt")),
          c.setLocal("signnewt", c.getLocal("signx")),
          c.setLocal("swp", c.getLocal("r")),
          c.setLocal("r", c.getLocal("newr")),
          c.setLocal("newr", c.getLocal("qr")),
          c.setLocal("qr", c.getLocal("swp")),
          c.br(0)
        )));
        f.addCode(c.if(
          c.getLocal("signt"),
          c.drop(c.call(prefix + "_sub", c.getLocal("pm"), c.getLocal("t"), c.getLocal("pr"))),
          c.call(prefix + "_copy", c.getLocal("t"), c.getLocal("pr"))
        ));
      }
      buildCopy();
      buildZero();
      buildIsZero();
      buildOne();
      buildEq();
      buildGte();
      buildAdd();
      buildSub();
      buildMul();
      buildSquare();
      buildSquareOld();
      buildDiv();
      buildInverseMod();
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_gte");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_squareOld");
      module3.exportFunction(prefix + "_div");
      module3.exportFunction(prefix + "_inverseMod");
      return prefix;
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_timesscalar.js
var require_build_timesscalar2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_timesscalar.js"(exports, module2) {
    "use strict";
    module2.exports = function buildTimesScalar(module3, fnName, elementLen, opAB, opAA, opCopy, opInit) {
      const f = module3.addFunction(fnName);
      f.addParam("base", "i32");
      f.addParam("scalar", "i32");
      f.addParam("scalarLength", "i32");
      f.addParam("r", "i32");
      f.addLocal("i", "i32");
      f.addLocal("b", "i32");
      const c = f.getCodeBuilder();
      const aux = c.i32_const(module3.alloc(elementLen));
      f.addCode(
        c.if(
          c.i32_eqz(c.getLocal("scalarLength")),
          [
            ...c.call(opInit, c.getLocal("r")),
            ...c.ret([])
          ]
        )
      );
      f.addCode(c.call(opCopy, c.getLocal("base"), aux));
      f.addCode(c.call(opInit, c.getLocal("r")));
      f.addCode(c.setLocal("i", c.getLocal("scalarLength")));
      f.addCode(c.block(c.loop(
        c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
        c.setLocal(
          "b",
          c.i32_load8_u(
            c.i32_add(
              c.getLocal("scalar"),
              c.getLocal("i")
            )
          )
        ),
        ...innerLoop(),
        c.br_if(1, c.i32_eqz(c.getLocal("i"))),
        c.br(0)
      )));
      function innerLoop() {
        const code = [];
        for (let i = 0; i < 8; i++) {
          code.push(
            ...c.call(opAA, c.getLocal("r"), c.getLocal("r")),
            ...c.if(
              c.i32_ge_u(c.getLocal("b"), c.i32_const(128 >> i)),
              [
                ...c.setLocal(
                  "b",
                  c.i32_sub(
                    c.getLocal("b"),
                    c.i32_const(128 >> i)
                  )
                ),
                ...c.call(opAB, c.getLocal("r"), aux, c.getLocal("r"))
              ]
            )
          );
        }
        return code;
      }
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_batchinverse.js
var require_build_batchinverse2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_batchinverse.js"(exports, module2) {
    "use strict";
    module2.exports = buildBatchInverse;
    function buildBatchInverse(module3, prefix) {
      const n8 = module3.modules[prefix].n64 * 8;
      const f = module3.addFunction(prefix + "_batchInverse");
      f.addParam("pIn", "i32");
      f.addParam("inStep", "i32");
      f.addParam("n", "i32");
      f.addParam("pOut", "i32");
      f.addParam("outStep", "i32");
      f.addLocal("itAux", "i32");
      f.addLocal("itIn", "i32");
      f.addLocal("itOut", "i32");
      f.addLocal("i", "i32");
      const c = f.getCodeBuilder();
      const AUX = c.i32_const(module3.alloc(n8));
      f.addCode(
        c.setLocal("itAux", c.i32_load(c.i32_const(0))),
        c.i32_store(
          c.i32_const(0),
          c.i32_add(
            c.getLocal("itAux"),
            c.i32_mul(
              c.i32_add(
                c.getLocal("n"),
                c.i32_const(1)
              ),
              c.i32_const(n8)
            )
          )
        )
      );
      f.addCode(
        // aux[0] = a;
        c.call(prefix + "_one", c.getLocal("itAux")),
        // for (i=0;i<n;i++) aux[i] = aux[i-1]*in[i]
        c.setLocal("itIn", c.getLocal("pIn")),
        c.setLocal("itAux", c.i32_add(c.getLocal("itAux"), c.i32_const(n8))),
        c.setLocal("i", c.i32_const(0)),
        c.block(c.loop(
          c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("itIn")),
            c.call(
              prefix + "_copy",
              c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)),
              c.getLocal("itAux")
            ),
            c.call(
              prefix + "_mul",
              c.getLocal("itIn"),
              c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)),
              c.getLocal("itAux")
            )
          ),
          c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.getLocal("inStep"))),
          c.setLocal("itAux", c.i32_add(c.getLocal("itAux"), c.i32_const(n8))),
          c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        )),
        // point to the last
        c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.getLocal("inStep"))),
        c.setLocal("itAux", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))),
        // itOut = pOut + (n-1)*stepOut   // Point to the last
        c.setLocal(
          "itOut",
          c.i32_add(
            c.getLocal("pOut"),
            c.i32_mul(
              c.i32_sub(c.getLocal("n"), c.i32_const(1)),
              c.getLocal("outStep")
            )
          )
        ),
        // aux[n-1] = 1/aux[n-1]
        c.call(prefix + "_inverse", c.getLocal("itAux"), c.getLocal("itAux")),
        c.block(c.loop(
          c.br_if(1, c.i32_eqz(c.getLocal("i"))),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("itIn")),
            [
              ...c.call(
                prefix + "_copy",
                c.getLocal("itAux"),
                c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))
              ),
              ...c.call(
                prefix + "_zero",
                c.getLocal("itOut")
              )
            ],
            [
              ...c.call(prefix + "_copy", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)), AUX),
              ...c.call(
                prefix + "_mul",
                c.getLocal("itAux"),
                c.getLocal("itIn"),
                c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))
              ),
              ...c.call(
                prefix + "_mul",
                c.getLocal("itAux"),
                AUX,
                c.getLocal("itOut")
              )
            ]
          ),
          c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.getLocal("inStep"))),
          c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.getLocal("outStep"))),
          c.setLocal("itAux", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))),
          c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        ))
      );
      f.addCode(
        c.i32_store(
          c.i32_const(0),
          c.getLocal("itAux")
        )
      );
    }
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_batchconvertion.js
var require_build_batchconvertion2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_batchconvertion.js"(exports, module2) {
    "use strict";
    module2.exports = buildBatchConvertion;
    function buildBatchConvertion(module3, fnName, internalFnName, sizeIn, sizeOut, reverse) {
      if (typeof reverse === "undefined") {
        if (sizeIn < sizeOut) {
          reverse = true;
        } else {
          reverse = false;
        }
      }
      const f = module3.addFunction(fnName);
      f.addParam("pIn", "i32");
      f.addParam("n", "i32");
      f.addParam("pOut", "i32");
      f.addLocal("i", "i32");
      f.addLocal("itIn", "i32");
      f.addLocal("itOut", "i32");
      const c = f.getCodeBuilder();
      if (reverse) {
        f.addCode(
          c.setLocal(
            "itIn",
            c.i32_add(
              c.getLocal("pIn"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeIn)
              )
            )
          ),
          c.setLocal(
            "itOut",
            c.i32_add(
              c.getLocal("pOut"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeOut)
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn"), c.getLocal("itOut")),
            c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      } else {
        f.addCode(
          c.setLocal("itIn", c.getLocal("pIn")),
          c.setLocal("itOut", c.getLocal("pOut")),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn"), c.getLocal("itOut")),
            c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_add(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
    }
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_batchop.js
var require_build_batchop2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_batchop.js"(exports, module2) {
    "use strict";
    module2.exports = buildBatchConvertion;
    function buildBatchConvertion(module3, fnName, internalFnName, sizeIn, sizeOut, reverse) {
      if (typeof reverse === "undefined") {
        if (sizeIn < sizeOut) {
          reverse = true;
        } else {
          reverse = false;
        }
      }
      const f = module3.addFunction(fnName);
      f.addParam("pIn1", "i32");
      f.addParam("pIn2", "i32");
      f.addParam("n", "i32");
      f.addParam("pOut", "i32");
      f.addLocal("i", "i32");
      f.addLocal("itIn1", "i32");
      f.addLocal("itIn2", "i32");
      f.addLocal("itOut", "i32");
      const c = f.getCodeBuilder();
      if (reverse) {
        f.addCode(
          c.setLocal(
            "itIn1",
            c.i32_add(
              c.getLocal("pIn1"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeIn)
              )
            )
          ),
          c.setLocal(
            "itIn2",
            c.i32_add(
              c.getLocal("pIn2"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeIn)
              )
            )
          ),
          c.setLocal(
            "itOut",
            c.i32_add(
              c.getLocal("pOut"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeOut)
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn1"), c.getLocal("itIn2"), c.getLocal("itOut")),
            c.setLocal("itIn1", c.i32_sub(c.getLocal("itIn1"), c.i32_const(sizeIn))),
            c.setLocal("itIn2", c.i32_sub(c.getLocal("itIn2"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      } else {
        f.addCode(
          c.setLocal("itIn1", c.getLocal("pIn1")),
          c.setLocal("itIn2", c.getLocal("pIn2")),
          c.setLocal("itOut", c.getLocal("pOut")),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn1"), c.getLocal("itIn2"), c.getLocal("itOut")),
            c.setLocal("itIn1", c.i32_add(c.getLocal("itIn1"), c.i32_const(sizeIn))),
            c.setLocal("itIn2", c.i32_add(c.getLocal("itIn2"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_add(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
    }
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/bigint.js
var require_bigint2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/bigint.js"(exports, module2) {
    "use strict";
    function compare(a, b) {
      return a === b ? 0 : a > b ? 1 : -1;
    }
    function square4(n) {
      return n * n;
    }
    function isOdd4(n) {
      return n % 2n !== 0n;
    }
    function isEven(n) {
      return n % 2n === 0n;
    }
    function isNegative5(n) {
      return n < 0n;
    }
    function isPositive(n) {
      return n > 0n;
    }
    function bitLength5(n) {
      if (isNegative5(n)) {
        return n.toString(2).length - 1;
      } else {
        return n.toString(2).length;
      }
    }
    function abs4(n) {
      return n < 0n ? -n : n;
    }
    function isUnit(n) {
      return abs4(n) === 1n;
    }
    function modInv(a, n) {
      var t = 0n, newT = 1n, r = n, newR = abs4(a), q, lastT, lastR;
      while (newR !== 0n) {
        q = r / newR;
        lastT = t;
        lastR = r;
        t = newT;
        r = newR;
        newT = lastT - q * newT;
        newR = lastR - q * newR;
      }
      if (!isUnit(r))
        throw new Error(a.toString() + " and " + n.toString() + " are not co-prime");
      if (compare(t, 0n) === -1) {
        t = t + n;
      }
      if (isNegative5(a)) {
        return -t;
      }
      return t;
    }
    function modPow(n, exp7, mod4) {
      if (mod4 === 0n)
        throw new Error("Cannot take modPow with modulus 0");
      var r = 1n, base = n % mod4;
      if (isNegative5(exp7)) {
        exp7 = exp7 * -1n;
        base = modInv(base, mod4);
      }
      while (isPositive(exp7)) {
        if (base === 0n)
          return 0n;
        if (isOdd4(exp7))
          r = r * base % mod4;
        exp7 = exp7 / 2n;
        base = square4(base) % mod4;
      }
      return r;
    }
    function compareAbs(a, b) {
      a = a >= 0n ? a : -a;
      b = b >= 0n ? b : -b;
      return a === b ? 0 : a > b ? 1 : -1;
    }
    function isDivisibleBy(a, n) {
      if (n === 0n)
        return false;
      if (isUnit(n))
        return true;
      if (compareAbs(n, 2n) === 0)
        return isEven(a);
      return a % n === 0n;
    }
    function isBasicPrime(v) {
      var n = abs4(v);
      if (isUnit(n))
        return false;
      if (n === 2n || n === 3n || n === 5n)
        return true;
      if (isEven(n) || isDivisibleBy(n, 3n) || isDivisibleBy(n, 5n))
        return false;
      if (n < 49n)
        return true;
    }
    function prev(n) {
      return n - 1n;
    }
    function millerRabinTest(n, a) {
      var nPrev = prev(n), b = nPrev, r = 0, d, i, x;
      while (isEven(b))
        b = b / 2n, r++;
      next:
        for (i = 0; i < a.length; i++) {
          if (n < a[i])
            continue;
          x = modPow(BigInt(a[i]), b, n);
          if (isUnit(x) || x === nPrev)
            continue;
          for (d = r - 1; d != 0; d--) {
            x = square4(x) % n;
            if (isUnit(x))
              return false;
            if (x === nPrev)
              continue next;
          }
          return false;
        }
      return true;
    }
    function isPrime(p) {
      var isPrime2 = isBasicPrime(p);
      if (isPrime2 !== void 0)
        return isPrime2;
      var n = abs4(p);
      var bits4 = bitLength5(n);
      if (bits4 <= 64)
        return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
      var logN = Math.log(2) * Number(bits4);
      var t = Math.ceil(logN);
      for (var a = [], i = 0; i < t; i++) {
        a.push(BigInt(i + 2));
      }
      return millerRabinTest(n, a);
    }
    module2.exports.bitLength = bitLength5;
    module2.exports.isOdd = isOdd4;
    module2.exports.isNegative = isNegative5;
    module2.exports.abs = abs4;
    module2.exports.isUnit = isUnit;
    module2.exports.compare = compare;
    module2.exports.modInv = modInv;
    module2.exports.modPow = modPow;
    module2.exports.isPrime = isPrime;
    module2.exports.square = square4;
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_f1m.js
var require_build_f1m2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_f1m.js"(exports, module2) {
    "use strict";
    var buildInt = require_build_int2();
    var utils2 = require_utils2();
    var buildExp = require_build_timesscalar2();
    var buildBatchInverse = require_build_batchinverse2();
    var buildBatchConvertion = require_build_batchconvertion2();
    var buildBatchOp = require_build_batchop2();
    var { bitLength: bitLength5, modInv, modPow, isPrime, isOdd: isOdd4, square: square4 } = require_bigint2();
    module2.exports = function buildF1m(module3, _q, _prefix, _intPrefix) {
      const q = BigInt(_q);
      const n64 = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n32 = n64 * 2;
      const n8 = n64 * 8;
      const prefix = _prefix || "f1m";
      if (module3.modules[prefix])
        return prefix;
      const intPrefix = buildInt(module3, n64, _intPrefix);
      const pq = module3.alloc(n8, utils2.bigInt2BytesLE(q, n8));
      const pR2 = module3.alloc(utils2.bigInt2BytesLE(square4(1n << BigInt(n64 * 64)) % q, n8));
      const pOne = module3.alloc(utils2.bigInt2BytesLE((1n << BigInt(n64 * 64)) % q, n8));
      const pZero = module3.alloc(utils2.bigInt2BytesLE(0n, n8));
      const _minusOne = q - 1n;
      const _e = _minusOne >> 1n;
      const pe = module3.alloc(n8, utils2.bigInt2BytesLE(_e, n8));
      const _ePlusOne = _e + 1n;
      const pePlusOne = module3.alloc(n8, utils2.bigInt2BytesLE(_ePlusOne, n8));
      module3.modules[prefix] = {
        pq,
        pR2,
        n64,
        q,
        pOne,
        pZero,
        pePlusOne
      };
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(intPrefix + "_copy", c.i32_const(pOne), c.getLocal("pr")));
      }
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.call(intPrefix + "_add", c.getLocal("x"), c.getLocal("y"), c.getLocal("r")),
            c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r"))),
            c.if(
              c.call(intPrefix + "_gte", c.getLocal("r"), c.i32_const(pq)),
              c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
            )
          )
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.call(intPrefix + "_sub", c.getLocal("x"), c.getLocal("y"), c.getLocal("r")),
            c.drop(c.call(intPrefix + "_add", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
          )
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(prefix + "_sub", c.i32_const(pZero), c.getLocal("x"), c.getLocal("r"))
        );
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call(prefix + "_fromMontgomery", c.getLocal("x"), AUX),
          c.call(intPrefix + "_gte", AUX, c.i32_const(pePlusOne))
        );
      }
      function buildSign() {
        const f = module3.addFunction(prefix + "_sign");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(intPrefix + "_isZero", c.getLocal("x")),
            c.ret(c.i32_const(0))
          ),
          c.call(prefix + "_fromMontgomery", c.getLocal("x"), AUX),
          c.if(
            c.call(intPrefix + "_gte", AUX, c.i32_const(pePlusOne)),
            c.ret(c.i32_const(-1))
          ),
          c.ret(c.i32_const(1))
        );
      }
      function buildMReduct() {
        const carries = module3.alloc(n32 * n32 * 8);
        const f = module3.addFunction(prefix + "_mReduct");
        f.addParam("t", "i32");
        f.addParam("r", "i32");
        f.addLocal("np32", "i64");
        f.addLocal("c", "i64");
        f.addLocal("m", "i64");
        const c = f.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f.addCode(c.setLocal("np32", c.i64_const(np32)));
        for (let i = 0; i < n32; i++) {
          f.addCode(c.setLocal("c", c.i64_const(0)));
          f.addCode(
            c.setLocal(
              "m",
              c.i64_and(
                c.i64_mul(
                  c.i64_load32_u(c.getLocal("t"), i * 4),
                  c.getLocal("np32")
                ),
                c.i64_const("0xFFFFFFFF")
              )
            )
          );
          for (let j = 0; j < n32; j++) {
            f.addCode(
              c.setLocal(
                "c",
                c.i64_add(
                  c.i64_add(
                    c.i64_load32_u(c.getLocal("t"), (i + j) * 4),
                    c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
                  ),
                  c.i64_mul(
                    c.i64_load32_u(c.i32_const(pq), j * 4),
                    c.getLocal("m")
                  )
                )
              )
            );
            f.addCode(
              c.i64_store32(
                c.getLocal("t"),
                (i + j) * 4,
                c.getLocal("c")
              )
            );
          }
          f.addCode(
            c.i64_store32(
              c.i32_const(carries),
              i * 4,
              c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
            )
          );
        }
        f.addCode(
          c.call(
            prefix + "_add",
            c.i32_const(carries),
            c.i32_add(
              c.getLocal("t"),
              c.i32_const(n32 * 4)
            ),
            c.getLocal("r")
          )
        );
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        f.addLocal("np32", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
          f.addLocal("y" + i, "i64");
          f.addLocal("m" + i, "i64");
          f.addLocal("q" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f.addCode(c.setLocal("np32", c.i64_const(np32)));
        const loadX = [];
        const loadY = [];
        const loadQ = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadY[j]) {
            Y = c.teeLocal("y" + j, c.i64_load32_u(c.getLocal("y"), j * 4));
            loadY[j] = true;
          } else {
            Y = c.getLocal("y" + j);
          }
          return c.i64_mul(X, Y);
        }
        function mulqm(i, j) {
          let Q, M;
          if (!loadQ[i]) {
            Q = c.teeLocal("q" + i, c.i64_load32_u(c.i32_const(0), pq + i * 4));
            loadQ[i] = true;
          } else {
            Q = c.getLocal("q" + i);
          }
          M = c.getLocal("m" + j);
          return c.i64_mul(Q, M);
        }
        let c0 = "c0";
        let c1 = "c1";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          for (let i = Math.max(0, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          for (let i = Math.max(1, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k < n32) {
            f.addCode(
              c.setLocal(
                "m" + k,
                c.i64_and(
                  c.i64_mul(
                    c.i64_and(
                      c.getLocal(c0),
                      c.i64_const(4294967295)
                    ),
                    c.getLocal("np32")
                  ),
                  c.i64_const("0xFFFFFFFF")
                )
              )
            );
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(0, k)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k >= n32) {
            f.addCode(
              c.i64_store32(
                c.getLocal("r"),
                (k - n32) * 4,
                c.getLocal(c0)
              )
            );
          }
          [c0, c1] = [c1, c0];
          f.addCode(
            c.setLocal(
              c1,
              c.i64_shr_u(
                c.getLocal(c0),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 - 4,
            c.getLocal(c0)
          )
        );
        f.addCode(
          c.if(
            c.i32_wrap_i64(c.getLocal(c1)),
            c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r"))),
            c.if(
              c.call(intPrefix + "_gte", c.getLocal("r"), c.i32_const(pq)),
              c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
            )
          )
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        f.addLocal("c0_old", "i64");
        f.addLocal("c1_old", "i64");
        f.addLocal("np32", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
          f.addLocal("m" + i, "i64");
          f.addLocal("q" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f.addCode(c.setLocal("np32", c.i64_const(np32)));
        const loadX = [];
        const loadQ = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadX[j]) {
            Y = c.teeLocal("x" + j, c.i64_load32_u(c.getLocal("x"), j * 4));
            loadX[j] = true;
          } else {
            Y = c.getLocal("x" + j);
          }
          return c.i64_mul(X, Y);
        }
        function mulqm(i, j) {
          let Q, M;
          if (!loadQ[i]) {
            Q = c.teeLocal("q" + i, c.i64_load32_u(c.i32_const(0), pq + i * 4));
            loadQ[i] = true;
          } else {
            Q = c.getLocal("q" + i);
          }
          M = c.getLocal("m" + j);
          return c.i64_mul(Q, M);
        }
        let c0 = "c0";
        let c1 = "c1";
        let c0_old = "c0_old";
        let c1_old = "c1_old";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          f.addCode(
            c.setLocal(c0, c.i64_const(0)),
            c.setLocal(c1, c.i64_const(0))
          );
          for (let i = Math.max(0, k - n32 + 1); i < k + 1 >> 1 && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          f.addCode(
            c.setLocal(
              c0,
              c.i64_shl(
                c.i64_and(
                  c.getLocal(c0),
                  c.i64_const(4294967295)
                ),
                c.i64_const(1)
              )
            )
          );
          f.addCode(
            c.setLocal(
              c1,
              c.i64_add(
                c.i64_shl(
                  c.getLocal(c1),
                  c.i64_const(1)
                ),
                c.i64_shr_u(
                  c.getLocal(c0),
                  c.i64_const(32)
                )
              )
            )
          );
          if (k % 2 == 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(k >> 1, k >> 1)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k > 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  c.i64_and(
                    c.getLocal(c0_old),
                    c.i64_const(4294967295)
                  )
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.i64_add(
                    c.getLocal(c1),
                    c.i64_shr_u(
                      c.getLocal(c0),
                      c.i64_const(32)
                    )
                  ),
                  c.getLocal(c1_old)
                )
              )
            );
          }
          for (let i = Math.max(1, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k < n32) {
            f.addCode(
              c.setLocal(
                "m" + k,
                c.i64_and(
                  c.i64_mul(
                    c.i64_and(
                      c.getLocal(c0),
                      c.i64_const(4294967295)
                    ),
                    c.getLocal("np32")
                  ),
                  c.i64_const("0xFFFFFFFF")
                )
              )
            );
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(0, k)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k >= n32) {
            f.addCode(
              c.i64_store32(
                c.getLocal("r"),
                (k - n32) * 4,
                c.getLocal(c0)
              )
            );
          }
          f.addCode(
            c.setLocal(
              c0_old,
              c.getLocal(c1)
            ),
            c.setLocal(
              c1_old,
              c.i64_shr_u(
                c.getLocal(c0_old),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 - 4,
            c.getLocal(c0_old)
          )
        );
        f.addCode(
          c.if(
            c.i32_wrap_i64(c.getLocal(c1_old)),
            c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r"))),
            c.if(
              c.call(intPrefix + "_gte", c.getLocal("r"), c.i32_const(pq)),
              c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
            )
          )
        );
      }
      function buildSquareOld() {
        const f = module3.addFunction(prefix + "_squareOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.getLocal("x"), c.getLocal("r")));
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.i32_const(pR2), c.getLocal("r")));
      }
      function buildFromMontgomery() {
        const pAux2 = module3.alloc(n8 * 2);
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(intPrefix + "_copy", c.getLocal("x"), c.i32_const(pAux2)));
        f.addCode(c.call(intPrefix + "_zero", c.i32_const(pAux2 + n8)));
        f.addCode(c.call(prefix + "_mReduct", c.i32_const(pAux2), c.getLocal("r")));
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_fromMontgomery", c.getLocal("x"), c.getLocal("r")));
        f.addCode(c.call(intPrefix + "_inverseMod", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")));
        f.addCode(c.call(prefix + "_toMontgomery", c.getLocal("r"), c.getLocal("r")));
      }
      let _nqr = 2n;
      if (isPrime(q)) {
        while (modPow(_nqr, _e, q) !== _minusOne)
          _nqr = _nqr + 1n;
      }
      let s2 = 0;
      let _t = _minusOne;
      while (!isOdd4(_t) && _t !== 0n) {
        s2++;
        _t = _t >> 1n;
      }
      const pt = module3.alloc(n8, utils2.bigInt2BytesLE(_t, n8));
      const _nqrToT = modPow(_nqr, _t, q);
      const pNqrToT = module3.alloc(utils2.bigInt2BytesLE((_nqrToT << BigInt(n64 * 64)) % q, n8));
      const _tPlusOneOver2 = _t + 1n >> 1n;
      const ptPlusOneOver2 = module3.alloc(n8, utils2.bigInt2BytesLE(_tPlusOneOver2, n8));
      function buildSqrt4() {
        const f = module3.addFunction(prefix + "_sqrt");
        f.addParam("n", "i32");
        f.addParam("r", "i32");
        f.addLocal("m", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        const c = f.getCodeBuilder();
        const ONE = c.i32_const(pOne);
        const C = c.i32_const(module3.alloc(n8));
        const T = c.i32_const(module3.alloc(n8));
        const R = c.i32_const(module3.alloc(n8));
        const SQ = c.i32_const(module3.alloc(n8));
        const B = c.i32_const(module3.alloc(n8));
        f.addCode(
          // If (n==0) return 0
          c.if(
            c.call(prefix + "_isZero", c.getLocal("n")),
            c.ret(
              c.call(prefix + "_zero", c.getLocal("r"))
            )
          ),
          c.setLocal("m", c.i32_const(s2)),
          c.call(prefix + "_copy", c.i32_const(pNqrToT), C),
          c.call(prefix + "_exp", c.getLocal("n"), c.i32_const(pt), c.i32_const(n8), T),
          c.call(prefix + "_exp", c.getLocal("n"), c.i32_const(ptPlusOneOver2), c.i32_const(n8), R),
          c.block(c.loop(
            c.br_if(1, c.call(prefix + "_eq", T, ONE)),
            c.call(prefix + "_square", T, SQ),
            c.setLocal("i", c.i32_const(1)),
            c.block(c.loop(
              c.br_if(1, c.call(prefix + "_eq", SQ, ONE)),
              c.call(prefix + "_square", SQ, SQ),
              c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
              c.br(0)
            )),
            c.call(prefix + "_copy", C, B),
            c.setLocal("j", c.i32_sub(c.i32_sub(c.getLocal("m"), c.getLocal("i")), c.i32_const(1))),
            c.block(c.loop(
              c.br_if(1, c.i32_eqz(c.getLocal("j"))),
              c.call(prefix + "_square", B, B),
              c.setLocal("j", c.i32_sub(c.getLocal("j"), c.i32_const(1))),
              c.br(0)
            )),
            c.setLocal("m", c.getLocal("i")),
            c.call(prefix + "_square", B, C),
            c.call(prefix + "_mul", T, C, T),
            c.call(prefix + "_mul", R, B, R),
            c.br(0)
          )),
          c.if(
            c.call(prefix + "_isNegative", R),
            c.call(prefix + "_neg", R, c.getLocal("r")),
            c.call(prefix + "_copy", R, c.getLocal("r"))
          )
        );
      }
      function buildIsSquare() {
        const f = module3.addFunction(prefix + "_isSquare");
        f.addParam("n", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const ONE = c.i32_const(pOne);
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("n")),
            c.ret(c.i32_const(1))
          ),
          c.call(prefix + "_exp", c.getLocal("n"), c.i32_const(pe), c.i32_const(n8), AUX),
          c.call(prefix + "_eq", AUX, ONE)
        );
      }
      function buildLoad() {
        const f = module3.addFunction(prefix + "_load");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        f.addLocal("p", "i32");
        f.addLocal("l", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        const c = f.getCodeBuilder();
        const R = c.i32_const(module3.alloc(n8));
        const pAux = module3.alloc(n8);
        const AUX = c.i32_const(pAux);
        f.addCode(
          c.call(intPrefix + "_zero", c.getLocal("r")),
          c.setLocal("i", c.i32_const(n8)),
          c.setLocal("p", c.getLocal("scalar")),
          c.block(c.loop(
            c.br_if(1, c.i32_gt_u(c.getLocal("i"), c.getLocal("scalarLen"))),
            c.if(
              c.i32_eq(c.getLocal("i"), c.i32_const(n8)),
              c.call(prefix + "_one", R),
              c.call(prefix + "_mul", R, c.i32_const(pR2), R)
            ),
            c.call(prefix + "_mul", c.getLocal("p"), R, AUX),
            c.call(prefix + "_add", c.getLocal("r"), AUX, c.getLocal("r")),
            c.setLocal("p", c.i32_add(c.getLocal("p"), c.i32_const(n8))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(n8))),
            c.br(0)
          )),
          c.setLocal("l", c.i32_rem_u(c.getLocal("scalarLen"), c.i32_const(n8))),
          c.if(c.i32_eqz(c.getLocal("l")), c.ret([])),
          c.call(intPrefix + "_zero", AUX),
          c.setLocal("j", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("j"), c.getLocal("l"))),
            c.i32_store8(
              c.getLocal("j"),
              pAux,
              c.i32_load8_u(c.getLocal("p"))
            ),
            c.setLocal("p", c.i32_add(c.getLocal("p"), c.i32_const(1))),
            c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
            c.br(0)
          )),
          c.if(
            c.i32_eq(c.getLocal("i"), c.i32_const(n8)),
            c.call(prefix + "_one", R),
            c.call(prefix + "_mul", R, c.i32_const(pR2), R)
          ),
          c.call(prefix + "_mul", AUX, R, AUX),
          c.call(prefix + "_add", c.getLocal("r"), AUX, c.getLocal("r"))
        );
      }
      function buildTimesScalar() {
        const f = module3.addFunction(prefix + "_timesScalar");
        f.addParam("x", "i32");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call(prefix + "_load", c.getLocal("scalar"), c.getLocal("scalarLen"), AUX),
          c.call(prefix + "_toMontgomery", AUX, AUX),
          c.call(prefix + "_mul", c.getLocal("x"), AUX, c.getLocal("r"))
        );
      }
      function buildIsOne() {
        const f = module3.addFunction(prefix + "_isOne");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.ret(c.call(intPrefix + "_eq", c.getLocal("x"), c.i32_const(pOne)))
        );
      }
      module3.exportFunction(intPrefix + "_copy", prefix + "_copy");
      module3.exportFunction(intPrefix + "_zero", prefix + "_zero");
      module3.exportFunction(intPrefix + "_isZero", prefix + "_isZero");
      module3.exportFunction(intPrefix + "_eq", prefix + "_eq");
      buildIsOne();
      buildAdd();
      buildSub();
      buildNeg();
      buildMReduct();
      buildMul();
      buildSquare();
      buildSquareOld();
      buildToMontgomery();
      buildFromMontgomery();
      buildIsNegative();
      buildSign();
      buildInverse();
      buildOne();
      buildLoad();
      buildTimesScalar();
      buildBatchInverse(module3, prefix);
      buildBatchConvertion(module3, prefix + "_batchToMontgomery", prefix + "_toMontgomery", n8, n8);
      buildBatchConvertion(module3, prefix + "_batchFromMontgomery", prefix + "_fromMontgomery", n8, n8);
      buildBatchConvertion(module3, prefix + "_batchNeg", prefix + "_neg", n8, n8);
      buildBatchOp(module3, prefix + "_batchAdd", prefix + "_add", n8, n8);
      buildBatchOp(module3, prefix + "_batchSub", prefix + "_sub", n8, n8);
      buildBatchOp(module3, prefix + "_batchMul", prefix + "_mul", n8, n8);
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_isNegative");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_mReduct");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_squareOld");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_inverse");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_load");
      module3.exportFunction(prefix + "_timesScalar");
      buildExp(
        module3,
        prefix + "_exp",
        n8,
        prefix + "_mul",
        prefix + "_square",
        intPrefix + "_copy",
        prefix + "_one"
      );
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_batchInverse");
      if (isPrime(q)) {
        buildSqrt4();
        buildIsSquare();
        module3.exportFunction(prefix + "_sqrt");
        module3.exportFunction(prefix + "_isSquare");
      }
      module3.exportFunction(prefix + "_batchToMontgomery");
      module3.exportFunction(prefix + "_batchFromMontgomery");
      return prefix;
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_f1.js
var require_build_f12 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_f1.js"(exports, module2) {
    "use strict";
    var buildF1m = require_build_f1m2();
    var { bitLength: bitLength5 } = require_bigint2();
    module2.exports = function buildF1(module3, _q, _prefix, _f1mPrefix, _intPrefix) {
      const q = BigInt(_q);
      const n64 = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n8 = n64 * 8;
      const prefix = _prefix || "f1";
      if (module3.modules[prefix])
        return prefix;
      module3.modules[prefix] = {
        n64
      };
      const intPrefix = _intPrefix || "int";
      const f1mPrefix = buildF1m(module3, q, _f1mPrefix, intPrefix);
      const pR2 = module3.modules[f1mPrefix].pR2;
      const pq = module3.modules[f1mPrefix].pq;
      const pePlusOne = module3.modules[f1mPrefix].pePlusOne;
      function buildMul() {
        const pAux1 = module3.alloc(n8);
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(f1mPrefix + "_mul", c.getLocal("x"), c.getLocal("y"), c.i32_const(pAux1)));
        f.addCode(c.call(f1mPrefix + "_mul", c.i32_const(pAux1), c.i32_const(pR2), c.getLocal("r")));
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.getLocal("x"), c.getLocal("r")));
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(intPrefix + "_inverseMod", c.getLocal("x"), c.i32_const(pq), c.getLocal("r")));
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(intPrefix + "_gte", c.getLocal("x"), c.i32_const(pePlusOne))
        );
      }
      buildMul();
      buildSquare();
      buildInverse();
      buildIsNegative();
      module3.exportFunction(f1mPrefix + "_add", prefix + "_add");
      module3.exportFunction(f1mPrefix + "_sub", prefix + "_sub");
      module3.exportFunction(f1mPrefix + "_neg", prefix + "_neg");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_inverse");
      module3.exportFunction(prefix + "_isNegative");
      module3.exportFunction(f1mPrefix + "_copy", prefix + "_copy");
      module3.exportFunction(f1mPrefix + "_zero", prefix + "_zero");
      module3.exportFunction(f1mPrefix + "_one", prefix + "_one");
      module3.exportFunction(f1mPrefix + "_isZero", prefix + "_isZero");
      module3.exportFunction(f1mPrefix + "_eq", prefix + "_eq");
      return prefix;
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_f2m.js
var require_build_f2m2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_f2m.js"(exports, module2) {
    "use strict";
    var buildExp = require_build_timesscalar2();
    var buildBatchInverse = require_build_batchinverse2();
    var utils2 = require_utils2();
    module2.exports = function buildF2m(module3, mulNonResidueFn, prefix, f1mPrefix) {
      if (module3.modules[prefix])
        return prefix;
      const f1n8 = module3.modules[f1mPrefix].n64 * 8;
      const q = module3.modules[f1mPrefix].q;
      module3.modules[prefix] = {
        n64: module3.modules[f1mPrefix].n64 * 2
      };
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_add", x0, y0, r0),
          c.call(f1mPrefix + "_add", x1, y1, r1)
        );
      }
      function buildTimesScalar() {
        const f = module3.addFunction(prefix + "_timesScalar");
        f.addParam("x", "i32");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_timesScalar", x0, c.getLocal("scalar"), c.getLocal("scalarLen"), r0),
          c.call(f1mPrefix + "_timesScalar", x1, c.getLocal("scalar"), c.getLocal("scalarLen"), r1)
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_sub", x0, y0, r0),
          c.call(f1mPrefix + "_sub", x1, y1, r1)
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_neg", x0, r0),
          c.call(f1mPrefix + "_neg", x1, r1)
        );
      }
      function buildConjugate() {
        const f = module3.addFunction(prefix + "_conjugate");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, r0),
          c.call(f1mPrefix + "_neg", x1, r1)
        );
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.if(
            c.call(f1mPrefix + "_isZero", x1),
            c.ret(c.call(f1mPrefix + "_isNegative", x0))
          ),
          c.ret(c.call(f1mPrefix + "_isNegative", x1))
        );
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const A = c.i32_const(module3.alloc(f1n8));
        const B = c.i32_const(module3.alloc(f1n8));
        const C = c.i32_const(module3.alloc(f1n8));
        const D = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_mul", x0, y0, A),
          // A = x0*y0
          c.call(f1mPrefix + "_mul", x1, y1, B),
          // B = x1*y1
          c.call(f1mPrefix + "_add", x0, x1, C),
          // C = x0 + x1
          c.call(f1mPrefix + "_add", y0, y1, D),
          // D = y0 + y1
          c.call(f1mPrefix + "_mul", C, D, C),
          // C = (x0 + x1)*(y0 + y1) = x0*y0+x0*y1+x1*y0+x1*y1
          //  c.call(f1mPrefix + "_mul", B, c.i32_const(pNonResidue), r0),  // r0 = nr*(x1*y1)
          c.call(mulNonResidueFn, B, r0),
          // r0 = nr*(x1*y1)
          c.call(f1mPrefix + "_add", A, r0, r0),
          // r0 = x0*y0 + nr*(x1*y1)
          c.call(f1mPrefix + "_add", A, B, r1),
          // r1 = x0*y0+x1*y1
          c.call(f1mPrefix + "_sub", C, r1, r1)
          // r1 = x0*y0+x0*y1+x1*y0+x1*y1 - x0*y0+x1*y1 = x0*y1+x1*y0
        );
      }
      function buildMul1() {
        const f = module3.addFunction(prefix + "_mul1");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y = c.getLocal("y");
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_mul", x0, y, r0),
          // A = x0*y
          c.call(f1mPrefix + "_mul", x1, y, r1)
          // B = x1*y
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const AB = c.i32_const(module3.alloc(f1n8));
        const APB = c.i32_const(module3.alloc(f1n8));
        const APNB = c.i32_const(module3.alloc(f1n8));
        const ABPNAB = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          // AB = x0*y1
          c.call(f1mPrefix + "_mul", x0, x1, AB),
          // APB = x0+y1
          c.call(f1mPrefix + "_add", x0, x1, APB),
          // APBN0 = x0 + nr*x1
          c.call(mulNonResidueFn, x1, APNB),
          c.call(f1mPrefix + "_add", x0, APNB, APNB),
          // ABPNAB = ab + nr*ab
          c.call(mulNonResidueFn, AB, ABPNAB),
          c.call(f1mPrefix + "_add", ABPNAB, AB, ABPNAB),
          // r0 = APB * APNB - ABPNAB
          c.call(f1mPrefix + "_mul", APB, APNB, r0),
          c.call(f1mPrefix + "_sub", r0, ABPNAB, r0),
          // r1 = AB + AB
          c.call(f1mPrefix + "_add", AB, AB, r1)
        );
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_toMontgomery", x0, r0),
          c.call(f1mPrefix + "_toMontgomery", x1, r1)
        );
      }
      function buildFromMontgomery() {
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_fromMontgomery", x0, r0),
          c.call(f1mPrefix + "_fromMontgomery", x1, r1)
        );
      }
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, r0),
          c.call(f1mPrefix + "_copy", x1, r1)
        );
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_zero", x0),
          c.call(f1mPrefix + "_zero", x1)
        );
      }
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_one", x0),
          c.call(f1mPrefix + "_zero", x1)
        );
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        f.addCode(
          c.i32_and(
            c.call(f1mPrefix + "_eq", x0, y0),
            c.call(f1mPrefix + "_eq", x1, y1)
          )
        );
      }
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.i32_and(
            c.call(f1mPrefix + "_isZero", x0),
            c.call(f1mPrefix + "_isZero", x1)
          )
        );
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const t0 = c.i32_const(module3.alloc(f1n8));
        const t1 = c.i32_const(module3.alloc(f1n8));
        const t2 = c.i32_const(module3.alloc(f1n8));
        const t3 = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_square", x0, t0),
          c.call(f1mPrefix + "_square", x1, t1),
          // c.call(f1mPrefix+"_mul", t1, c.i32_const(pNonResidue), t2),
          c.call(mulNonResidueFn, t1, t2),
          c.call(f1mPrefix + "_sub", t0, t2, t2),
          c.call(f1mPrefix + "_inverse", t2, t3),
          c.call(f1mPrefix + "_mul", x0, t3, r0),
          c.call(f1mPrefix + "_mul", x1, t3, r1),
          c.call(f1mPrefix + "_neg", r1, r1)
        );
      }
      function buildSign() {
        const f = module3.addFunction(prefix + "_sign");
        f.addParam("x", "i32");
        f.addLocal("s", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.setLocal("s", c.call(f1mPrefix + "_sign", x1)),
          c.if(
            c.getLocal("s"),
            c.ret(c.getLocal("s"))
          ),
          c.ret(c.call(f1mPrefix + "_sign", x0))
        );
      }
      function buildIsOne() {
        const f = module3.addFunction(prefix + "_isOne");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.ret(c.i32_and(
            c.call(f1mPrefix + "_isOne", x0),
            c.call(f1mPrefix + "_isZero", x1)
          ))
        );
      }
      function buildSqrt4() {
        const f = module3.addFunction(prefix + "_sqrt");
        f.addParam("a", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const e34 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8)));
        const e12 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 1n) / 2n, f1n8)));
        const a = c.getLocal("a");
        const a1 = c.i32_const(module3.alloc(f1n8 * 2));
        const alpha = c.i32_const(module3.alloc(f1n8 * 2));
        const a0 = c.i32_const(module3.alloc(f1n8 * 2));
        const pn1 = module3.alloc(f1n8 * 2);
        const n1 = c.i32_const(pn1);
        const n1a = c.i32_const(pn1);
        const n1b = c.i32_const(pn1 + f1n8);
        const x0 = c.i32_const(module3.alloc(f1n8 * 2));
        const b = c.i32_const(module3.alloc(f1n8 * 2));
        f.addCode(
          c.call(prefix + "_one", n1),
          c.call(prefix + "_neg", n1, n1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_exp", a, e34, c.i32_const(f1n8), a1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_square", a1, alpha),
          c.call(prefix + "_mul", a, alpha, alpha),
          // const a0 = F.mul(F.frobenius(1, alfa), alfa);
          c.call(prefix + "_conjugate", alpha, a0),
          c.call(prefix + "_mul", a0, alpha, a0),
          // if (F.eq(a0, F.negone)) return null;
          c.if(c.call(prefix + "_eq", a0, n1), c.unreachable()),
          // const x0 = F.mul(a1, a);
          c.call(prefix + "_mul", a1, a, x0),
          // if (F.eq(alfa, F.negone)) {
          c.if(
            c.call(prefix + "_eq", alpha, n1),
            [
              // x = F.mul(x0, [F.F.zero, F.F.one]);
              ...c.call(f1mPrefix + "_zero", n1a),
              ...c.call(f1mPrefix + "_one", n1b),
              ...c.call(prefix + "_mul", n1, x0, c.getLocal("pr"))
            ],
            [
              // const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);
              ...c.call(prefix + "_one", b),
              ...c.call(prefix + "_add", b, alpha, b),
              ...c.call(prefix + "_exp", b, e12, c.i32_const(f1n8), b),
              // x = F.mul(b, x0);
              ...c.call(prefix + "_mul", b, x0, c.getLocal("pr"))
            ]
          )
        );
      }
      function buildIsSquare() {
        const f = module3.addFunction(prefix + "_isSquare");
        f.addParam("a", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const e34 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8)));
        const a = c.getLocal("a");
        const a1 = c.i32_const(module3.alloc(f1n8 * 2));
        const alpha = c.i32_const(module3.alloc(f1n8 * 2));
        const a0 = c.i32_const(module3.alloc(f1n8 * 2));
        const pn1 = module3.alloc(f1n8 * 2);
        const n1 = c.i32_const(pn1);
        f.addCode(
          c.call(prefix + "_one", n1),
          c.call(prefix + "_neg", n1, n1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_exp", a, e34, c.i32_const(f1n8), a1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_square", a1, alpha),
          c.call(prefix + "_mul", a, alpha, alpha),
          // const a0 = F.mul(F.frobenius(1, alfa), alfa);
          c.call(prefix + "_conjugate", alpha, a0),
          c.call(prefix + "_mul", a0, alpha, a0),
          // if (F.eq(a0, F.negone)) return null;
          c.if(
            c.call(
              prefix + "_eq",
              a0,
              n1
            ),
            c.ret(c.i32_const(0))
          ),
          c.ret(c.i32_const(1))
        );
      }
      buildIsZero();
      buildIsOne();
      buildZero();
      buildOne();
      buildCopy();
      buildMul();
      buildMul1();
      buildSquare();
      buildAdd();
      buildSub();
      buildNeg();
      buildConjugate();
      buildToMontgomery();
      buildFromMontgomery();
      buildEq();
      buildInverse();
      buildTimesScalar();
      buildSign();
      buildIsNegative();
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_mul1");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_conjugate");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_inverse");
      buildBatchInverse(module3, prefix);
      buildExp(
        module3,
        prefix + "_exp",
        f1n8 * 2,
        prefix + "_mul",
        prefix + "_square",
        prefix + "_copy",
        prefix + "_one"
      );
      buildSqrt4();
      buildIsSquare();
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_batchInverse");
      module3.exportFunction(prefix + "_sqrt");
      module3.exportFunction(prefix + "_isSquare");
      module3.exportFunction(prefix + "_isNegative");
      return prefix;
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_f3m.js
var require_build_f3m2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_f3m.js"(exports, module2) {
    "use strict";
    var buildExp = require_build_timesscalar2();
    var buildBatchInverse = require_build_batchinverse2();
    module2.exports = function buildF3m(module3, mulNonResidueFn, prefix, f1mPrefix) {
      if (module3.modules[prefix])
        return prefix;
      const f1n8 = module3.modules[f1mPrefix].n64 * 8;
      module3.modules[prefix] = {
        n64: module3.modules[f1mPrefix].n64 * 3
      };
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const y2 = c.i32_add(c.getLocal("y"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_add", x0, y0, r0),
          c.call(f1mPrefix + "_add", x1, y1, r1),
          c.call(f1mPrefix + "_add", x2, y2, r2)
        );
      }
      function buildTimesScalar() {
        const f = module3.addFunction(prefix + "_timesScalar");
        f.addParam("x", "i32");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_timesScalar", x0, c.getLocal("scalar"), c.getLocal("scalarLen"), r0),
          c.call(f1mPrefix + "_timesScalar", x1, c.getLocal("scalar"), c.getLocal("scalarLen"), r1),
          c.call(f1mPrefix + "_timesScalar", x2, c.getLocal("scalar"), c.getLocal("scalarLen"), r2)
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const y2 = c.i32_add(c.getLocal("y"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_sub", x0, y0, r0),
          c.call(f1mPrefix + "_sub", x1, y1, r1),
          c.call(f1mPrefix + "_sub", x2, y2, r2)
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_neg", x0, r0),
          c.call(f1mPrefix + "_neg", x1, r1),
          c.call(f1mPrefix + "_neg", x2, r2)
        );
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.if(
            c.call(f1mPrefix + "_isZero", x2),
            c.if(
              c.call(f1mPrefix + "_isZero", x1),
              c.ret(c.call(f1mPrefix + "_isNegative", x0)),
              c.ret(c.call(f1mPrefix + "_isNegative", x1))
            )
          ),
          c.ret(c.call(f1mPrefix + "_isNegative", x2))
        );
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const cd = f.getCodeBuilder();
        const a = cd.getLocal("x");
        const b = cd.i32_add(cd.getLocal("x"), cd.i32_const(f1n8));
        const c = cd.i32_add(cd.getLocal("x"), cd.i32_const(2 * f1n8));
        const A = cd.getLocal("y");
        const B = cd.i32_add(cd.getLocal("y"), cd.i32_const(f1n8));
        const C = cd.i32_add(cd.getLocal("y"), cd.i32_const(2 * f1n8));
        const r0 = cd.getLocal("r");
        const r1 = cd.i32_add(cd.getLocal("r"), cd.i32_const(f1n8));
        const r2 = cd.i32_add(cd.getLocal("r"), cd.i32_const(2 * f1n8));
        const aA = cd.i32_const(module3.alloc(f1n8));
        const bB = cd.i32_const(module3.alloc(f1n8));
        const cC = cd.i32_const(module3.alloc(f1n8));
        const a_b = cd.i32_const(module3.alloc(f1n8));
        const A_B = cd.i32_const(module3.alloc(f1n8));
        const a_c = cd.i32_const(module3.alloc(f1n8));
        const A_C = cd.i32_const(module3.alloc(f1n8));
        const b_c = cd.i32_const(module3.alloc(f1n8));
        const B_C = cd.i32_const(module3.alloc(f1n8));
        const aA_bB = cd.i32_const(module3.alloc(f1n8));
        const aA_cC = cd.i32_const(module3.alloc(f1n8));
        const bB_cC = cd.i32_const(module3.alloc(f1n8));
        const AUX = cd.i32_const(module3.alloc(f1n8));
        f.addCode(
          cd.call(f1mPrefix + "_mul", a, A, aA),
          cd.call(f1mPrefix + "_mul", b, B, bB),
          cd.call(f1mPrefix + "_mul", c, C, cC),
          cd.call(f1mPrefix + "_add", a, b, a_b),
          cd.call(f1mPrefix + "_add", A, B, A_B),
          cd.call(f1mPrefix + "_add", a, c, a_c),
          cd.call(f1mPrefix + "_add", A, C, A_C),
          cd.call(f1mPrefix + "_add", b, c, b_c),
          cd.call(f1mPrefix + "_add", B, C, B_C),
          cd.call(f1mPrefix + "_add", aA, bB, aA_bB),
          cd.call(f1mPrefix + "_add", aA, cC, aA_cC),
          cd.call(f1mPrefix + "_add", bB, cC, bB_cC),
          cd.call(f1mPrefix + "_mul", b_c, B_C, r0),
          cd.call(f1mPrefix + "_sub", r0, bB_cC, r0),
          cd.call(mulNonResidueFn, r0, r0),
          cd.call(f1mPrefix + "_add", aA, r0, r0),
          cd.call(f1mPrefix + "_mul", a_b, A_B, r1),
          cd.call(f1mPrefix + "_sub", r1, aA_bB, r1),
          cd.call(mulNonResidueFn, cC, AUX),
          cd.call(f1mPrefix + "_add", r1, AUX, r1),
          cd.call(f1mPrefix + "_mul", a_c, A_C, r2),
          cd.call(f1mPrefix + "_sub", r2, aA_cC, r2),
          cd.call(f1mPrefix + "_add", r2, bB, r2)
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const A = c.getLocal("x");
        const B = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const C = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        const s0 = c.i32_const(module3.alloc(f1n8));
        const ab = c.i32_const(module3.alloc(f1n8));
        const s1 = c.i32_const(module3.alloc(f1n8));
        const s2 = c.i32_const(module3.alloc(f1n8));
        const bc = c.i32_const(module3.alloc(f1n8));
        const s3 = c.i32_const(module3.alloc(f1n8));
        const s4 = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_square", A, s0),
          c.call(f1mPrefix + "_mul", A, B, ab),
          c.call(f1mPrefix + "_add", ab, ab, s1),
          c.call(f1mPrefix + "_sub", A, B, s2),
          c.call(f1mPrefix + "_add", s2, C, s2),
          c.call(f1mPrefix + "_square", s2, s2),
          c.call(f1mPrefix + "_mul", B, C, bc),
          c.call(f1mPrefix + "_add", bc, bc, s3),
          c.call(f1mPrefix + "_square", C, s4),
          c.call(mulNonResidueFn, s3, r0),
          c.call(f1mPrefix + "_add", s0, r0, r0),
          c.call(mulNonResidueFn, s4, r1),
          c.call(f1mPrefix + "_add", s1, r1, r1),
          c.call(f1mPrefix + "_add", s0, s4, r2),
          c.call(f1mPrefix + "_sub", s3, r2, r2),
          c.call(f1mPrefix + "_add", s2, r2, r2),
          c.call(f1mPrefix + "_add", s1, r2, r2)
        );
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_toMontgomery", x0, r0),
          c.call(f1mPrefix + "_toMontgomery", x1, r1),
          c.call(f1mPrefix + "_toMontgomery", x2, r2)
        );
      }
      function buildFromMontgomery() {
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_fromMontgomery", x0, r0),
          c.call(f1mPrefix + "_fromMontgomery", x1, r1),
          c.call(f1mPrefix + "_fromMontgomery", x2, r2)
        );
      }
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, r0),
          c.call(f1mPrefix + "_copy", x1, r1),
          c.call(f1mPrefix + "_copy", x2, r2)
        );
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_zero", x0),
          c.call(f1mPrefix + "_zero", x1),
          c.call(f1mPrefix + "_zero", x2)
        );
      }
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_one", x0),
          c.call(f1mPrefix + "_zero", x1),
          c.call(f1mPrefix + "_zero", x2)
        );
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const y2 = c.i32_add(c.getLocal("y"), c.i32_const(2 * f1n8));
        f.addCode(
          c.i32_and(
            c.i32_and(
              c.call(f1mPrefix + "_eq", x0, y0),
              c.call(f1mPrefix + "_eq", x1, y1)
            ),
            c.call(f1mPrefix + "_eq", x2, y2)
          )
        );
      }
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.i32_and(
            c.i32_and(
              c.call(f1mPrefix + "_isZero", x0),
              c.call(f1mPrefix + "_isZero", x1)
            ),
            c.call(f1mPrefix + "_isZero", x2)
          )
        );
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        const t0 = c.i32_const(module3.alloc(f1n8));
        const t1 = c.i32_const(module3.alloc(f1n8));
        const t2 = c.i32_const(module3.alloc(f1n8));
        const t3 = c.i32_const(module3.alloc(f1n8));
        const t4 = c.i32_const(module3.alloc(f1n8));
        const t5 = c.i32_const(module3.alloc(f1n8));
        const c0 = c.i32_const(module3.alloc(f1n8));
        const c1 = c.i32_const(module3.alloc(f1n8));
        const c2 = c.i32_const(module3.alloc(f1n8));
        const t6 = c.i32_const(module3.alloc(f1n8));
        const AUX = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_square", x0, t0),
          c.call(f1mPrefix + "_square", x1, t1),
          c.call(f1mPrefix + "_square", x2, t2),
          c.call(f1mPrefix + "_mul", x0, x1, t3),
          c.call(f1mPrefix + "_mul", x0, x2, t4),
          c.call(f1mPrefix + "_mul", x1, x2, t5),
          c.call(mulNonResidueFn, t5, c0),
          c.call(f1mPrefix + "_sub", t0, c0, c0),
          c.call(mulNonResidueFn, t2, c1),
          c.call(f1mPrefix + "_sub", c1, t3, c1),
          c.call(f1mPrefix + "_sub", t1, t4, c2),
          c.call(f1mPrefix + "_mul", x2, c1, t6),
          c.call(f1mPrefix + "_mul", x1, c2, AUX),
          c.call(f1mPrefix + "_add", t6, AUX, t6),
          c.call(mulNonResidueFn, t6, t6),
          c.call(f1mPrefix + "_mul", x0, c0, AUX),
          c.call(f1mPrefix + "_add", AUX, t6, t6),
          c.call(f1mPrefix + "_inverse", t6, t6),
          c.call(f1mPrefix + "_mul", t6, c0, r0),
          c.call(f1mPrefix + "_mul", t6, c1, r1),
          c.call(f1mPrefix + "_mul", t6, c2, r2)
        );
      }
      function buildSign() {
        const f = module3.addFunction(prefix + "_sign");
        f.addParam("x", "i32");
        f.addLocal("s", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.setLocal("s", c.call(f1mPrefix + "_sign", x2)),
          c.if(
            c.getLocal("s"),
            c.ret(c.getLocal("s"))
          ),
          c.setLocal("s", c.call(f1mPrefix + "_sign", x1)),
          c.if(
            c.getLocal("s"),
            c.ret(c.getLocal("s"))
          ),
          c.ret(c.call(f1mPrefix + "_sign", x0))
        );
      }
      function buildIsOne() {
        const f = module3.addFunction(prefix + "_isOne");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8 * 2));
        f.addCode(
          c.ret(
            c.i32_and(
              c.i32_and(
                c.call(f1mPrefix + "_isOne", x0),
                c.call(f1mPrefix + "_isZero", x1)
              ),
              c.call(f1mPrefix + "_isZero", x2)
            )
          )
        );
      }
      buildIsZero();
      buildIsOne();
      buildZero();
      buildOne();
      buildCopy();
      buildMul();
      buildSquare();
      buildAdd();
      buildSub();
      buildNeg();
      buildSign();
      buildToMontgomery();
      buildFromMontgomery();
      buildEq();
      buildInverse();
      buildTimesScalar();
      buildIsNegative();
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_inverse");
      buildBatchInverse(module3, prefix);
      buildExp(
        module3,
        prefix + "_exp",
        f1n8 * 3,
        prefix + "_mul",
        prefix + "_square",
        prefix + "_copy",
        prefix + "_one"
      );
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_batchInverse");
      module3.exportFunction(prefix + "_isNegative");
      return prefix;
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_timesscalarnaf.js
var require_build_timesscalarnaf2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_timesscalarnaf.js"(exports, module2) {
    "use strict";
    module2.exports = function buildTimesScalarNAF(module3, fnName, elementLen, opAB, opAA, opAmB, opCopy, opInit) {
      const f = module3.addFunction(fnName);
      f.addParam("base", "i32");
      f.addParam("scalar", "i32");
      f.addParam("scalarLength", "i32");
      f.addParam("r", "i32");
      f.addLocal("old0", "i32");
      f.addLocal("nbits", "i32");
      f.addLocal("i", "i32");
      f.addLocal("last", "i32");
      f.addLocal("cur", "i32");
      f.addLocal("carry", "i32");
      f.addLocal("p", "i32");
      const c = f.getCodeBuilder();
      const aux = c.i32_const(module3.alloc(elementLen));
      function getBit(IDX) {
        return c.i32_and(
          c.i32_shr_u(
            c.i32_load(
              c.i32_add(
                c.getLocal("scalar"),
                c.i32_and(
                  c.i32_shr_u(
                    IDX,
                    c.i32_const(3)
                  ),
                  c.i32_const(4294967292)
                )
              )
            ),
            c.i32_and(
              IDX,
              c.i32_const(31)
            )
          ),
          c.i32_const(1)
        );
      }
      function pushBit(b) {
        return [
          ...c.i32_store8(
            c.getLocal("p"),
            c.i32_const(b)
          ),
          ...c.setLocal(
            "p",
            c.i32_add(
              c.getLocal("p"),
              c.i32_const(1)
            )
          )
        ];
      }
      f.addCode(
        c.if(
          c.i32_eqz(c.getLocal("scalarLength")),
          [
            ...c.call(opInit, c.getLocal("r")),
            ...c.ret([])
          ]
        ),
        c.setLocal("nbits", c.i32_shl(c.getLocal("scalarLength"), c.i32_const(3))),
        c.setLocal("old0", c.i32_load(c.i32_const(0))),
        c.setLocal("p", c.getLocal("old0")),
        c.i32_store(
          c.i32_const(0),
          c.i32_and(
            c.i32_add(
              c.i32_add(
                c.getLocal("old0"),
                c.i32_const(32)
              ),
              c.getLocal("nbits")
            ),
            c.i32_const(4294967288)
          )
        ),
        c.setLocal("i", c.i32_const(1)),
        c.setLocal("last", getBit(c.i32_const(0))),
        c.setLocal("carry", c.i32_const(0)),
        c.block(c.loop(
          c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("nbits"))),
          c.setLocal("cur", getBit(c.getLocal("i"))),
          c.if(
            c.getLocal("last"),
            c.if(
              c.getLocal("cur"),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(1)
                ],
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(255)
                ]
              ),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(255)
                ],
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(1)
                ]
              )
            ),
            c.if(
              c.getLocal("cur"),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(0)
                ],
                [
                  ...c.setLocal("last", c.i32_const(1)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(0)
                ]
              ),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(1)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(0)
                ],
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(0)
                ]
              )
            )
          ),
          c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        )),
        c.if(
          c.getLocal("last"),
          c.if(
            c.getLocal("carry"),
            [
              ...pushBit(255),
              ...pushBit(0),
              ...pushBit(1)
            ],
            [
              ...pushBit(1)
            ]
          ),
          c.if(
            c.getLocal("carry"),
            [
              ...pushBit(0),
              ...pushBit(1)
            ]
          )
        ),
        c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
        // p already points to the last bit
        c.call(opCopy, c.getLocal("base"), aux),
        c.call(opInit, c.getLocal("r")),
        c.block(c.loop(
          c.call(opAA, c.getLocal("r"), c.getLocal("r")),
          c.setLocal(
            "cur",
            c.i32_load8_u(
              c.getLocal("p")
            )
          ),
          c.if(
            c.getLocal("cur"),
            c.if(
              c.i32_eq(c.getLocal("cur"), c.i32_const(1)),
              c.call(opAB, c.getLocal("r"), aux, c.getLocal("r")),
              c.call(opAmB, c.getLocal("r"), aux, c.getLocal("r"))
            )
          ),
          c.br_if(1, c.i32_eq(c.getLocal("old0"), c.getLocal("p"))),
          c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
          c.br(0)
        )),
        c.i32_store(c.i32_const(0), c.getLocal("old0"))
      );
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_multiexp.js
var require_build_multiexp2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_multiexp.js"(exports, module2) {
    "use strict";
    module2.exports = function buildMultiexp4(module3, prefix, fnName, opAdd, n8b) {
      const n64g = module3.modules[prefix].n64;
      const n8g = n64g * 8;
      function buildGetChunk() {
        const f = module3.addFunction(fnName + "_getChunk");
        f.addParam("pScalar", "i32");
        f.addParam("scalarSize", "i32");
        f.addParam("startBit", "i32");
        f.addParam("chunkSize", "i32");
        f.addLocal("bitsToEnd", "i32");
        f.addLocal("mask", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "bitsToEnd",
            c.i32_sub(
              c.i32_mul(
                c.getLocal("scalarSize"),
                c.i32_const(8)
              ),
              c.getLocal("startBit")
            )
          ),
          c.if(
            c.i32_gt_s(
              c.getLocal("chunkSize"),
              c.getLocal("bitsToEnd")
            ),
            c.setLocal(
              "mask",
              c.i32_sub(
                c.i32_shl(
                  c.i32_const(1),
                  c.getLocal("bitsToEnd")
                ),
                c.i32_const(1)
              )
            ),
            c.setLocal(
              "mask",
              c.i32_sub(
                c.i32_shl(
                  c.i32_const(1),
                  c.getLocal("chunkSize")
                ),
                c.i32_const(1)
              )
            )
          ),
          c.i32_and(
            c.i32_shr_u(
              c.i32_load(
                c.i32_add(
                  c.getLocal("pScalar"),
                  c.i32_shr_u(
                    c.getLocal("startBit"),
                    c.i32_const(3)
                  )
                ),
                0,
                // offset
                0
                // align to byte.
              ),
              c.i32_and(
                c.getLocal("startBit"),
                c.i32_const(7)
              )
            ),
            c.getLocal("mask")
          )
        );
      }
      function buildMutiexpChunk() {
        const f = module3.addFunction(fnName + "_chunk");
        f.addParam("pBases", "i32");
        f.addParam("pScalars", "i32");
        f.addParam("scalarSize", "i32");
        f.addParam("n", "i32");
        f.addParam("startBit", "i32");
        f.addParam("chunkSize", "i32");
        f.addParam("pr", "i32");
        f.addLocal("nChunks", "i32");
        f.addLocal("itScalar", "i32");
        f.addLocal("endScalar", "i32");
        f.addLocal("itBase", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("nTable", "i32");
        f.addLocal("pTable", "i32");
        f.addLocal("idx", "i32");
        f.addLocal("pIdxTable", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.i32_eqz(c.getLocal("n")),
            [
              ...c.call(prefix + "_zero", c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          // Allocate memory
          c.setLocal(
            "nTable",
            c.i32_shl(
              c.i32_const(1),
              c.getLocal("chunkSize")
            )
          ),
          c.setLocal("pTable", c.i32_load(c.i32_const(0))),
          c.i32_store(
            c.i32_const(0),
            c.i32_add(
              c.getLocal("pTable"),
              c.i32_mul(
                c.getLocal("nTable"),
                c.i32_const(n8g)
              )
            )
          ),
          // Reset Table
          c.setLocal("j", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("j"),
                c.getLocal("nTable")
              )
            ),
            c.call(
              prefix + "_zero",
              c.i32_add(
                c.getLocal("pTable"),
                c.i32_mul(
                  c.getLocal("j"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
            c.br(0)
          )),
          // Distribute elements
          c.setLocal("itBase", c.getLocal("pBases")),
          c.setLocal("itScalar", c.getLocal("pScalars")),
          c.setLocal(
            "endScalar",
            c.i32_add(
              c.getLocal("pScalars"),
              c.i32_mul(
                c.getLocal("n"),
                c.getLocal("scalarSize")
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("itScalar"),
                c.getLocal("endScalar")
              )
            ),
            c.setLocal(
              "idx",
              c.call(
                fnName + "_getChunk",
                c.getLocal("itScalar"),
                c.getLocal("scalarSize"),
                c.getLocal("startBit"),
                c.getLocal("chunkSize")
              )
            ),
            c.if(
              c.getLocal("idx"),
              [
                ...c.setLocal(
                  "pIdxTable",
                  c.i32_add(
                    c.getLocal("pTable"),
                    c.i32_mul(
                      c.i32_sub(
                        c.getLocal("idx"),
                        c.i32_const(1)
                      ),
                      c.i32_const(n8g)
                    )
                  )
                ),
                ...c.call(
                  opAdd,
                  c.getLocal("pIdxTable"),
                  c.getLocal("itBase"),
                  c.getLocal("pIdxTable")
                )
              ]
            ),
            c.setLocal("itScalar", c.i32_add(c.getLocal("itScalar"), c.getLocal("scalarSize"))),
            c.setLocal("itBase", c.i32_add(c.getLocal("itBase"), c.i32_const(n8b))),
            c.br(0)
          )),
          c.call(fnName + "_reduceTable", c.getLocal("pTable"), c.getLocal("chunkSize")),
          c.call(
            prefix + "_copy",
            c.getLocal("pTable"),
            c.getLocal("pr")
          ),
          c.i32_store(
            c.i32_const(0),
            c.getLocal("pTable")
          )
        );
      }
      function buildMultiexp5() {
        const f = module3.addFunction(fnName);
        f.addParam("pBases", "i32");
        f.addParam("pScalars", "i32");
        f.addParam("scalarSize", "i32");
        f.addParam("n", "i32");
        f.addParam("pr", "i32");
        f.addLocal("chunkSize", "i32");
        f.addLocal("nChunks", "i32");
        f.addLocal("itScalar", "i32");
        f.addLocal("endScalar", "i32");
        f.addLocal("itBase", "i32");
        f.addLocal("itBit", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("nTable", "i32");
        f.addLocal("pTable", "i32");
        f.addLocal("idx", "i32");
        f.addLocal("pIdxTable", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8g));
        const pTSizes2 = module3.alloc([
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          16,
          16,
          15,
          14,
          13,
          13,
          12,
          11,
          10,
          9,
          8,
          7,
          7,
          6,
          5,
          4,
          3,
          2,
          1,
          1,
          1,
          1
        ]);
        f.addCode(
          c.call(prefix + "_zero", c.getLocal("pr")),
          c.if(
            c.i32_eqz(c.getLocal("n")),
            c.ret([])
          ),
          c.setLocal("chunkSize", c.i32_load8_u(c.i32_clz(c.getLocal("n")), pTSizes2)),
          c.setLocal(
            "nChunks",
            c.i32_add(
              c.i32_div_u(
                c.i32_sub(
                  c.i32_shl(
                    c.getLocal("scalarSize"),
                    c.i32_const(3)
                  ),
                  c.i32_const(1)
                ),
                c.getLocal("chunkSize")
              ),
              c.i32_const(1)
            )
          ),
          // Allocate memory
          c.setLocal(
            "itBit",
            c.i32_mul(
              c.i32_sub(
                c.getLocal("nChunks"),
                c.i32_const(1)
              ),
              c.getLocal("chunkSize")
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_lt_s(
                c.getLocal("itBit"),
                c.i32_const(0)
              )
            ),
            // Double nChunk times
            c.if(
              c.i32_eqz(c.call(prefix + "_isZero", c.getLocal("pr"))),
              [
                ...c.setLocal("j", c.i32_const(0)),
                ...c.block(c.loop(
                  c.br_if(
                    1,
                    c.i32_eq(
                      c.getLocal("j"),
                      c.getLocal("chunkSize")
                    )
                  ),
                  c.call(prefix + "_double", c.getLocal("pr"), c.getLocal("pr")),
                  c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
                  c.br(0)
                ))
              ]
            ),
            c.call(
              fnName + "_chunk",
              c.getLocal("pBases"),
              c.getLocal("pScalars"),
              c.getLocal("scalarSize"),
              c.getLocal("n"),
              c.getLocal("itBit"),
              c.getLocal("chunkSize"),
              aux
            ),
            c.call(
              prefix + "_add",
              c.getLocal("pr"),
              aux,
              c.getLocal("pr")
            ),
            c.setLocal("itBit", c.i32_sub(c.getLocal("itBit"), c.getLocal("chunkSize"))),
            c.br(0)
          ))
        );
      }
      function buildReduceTable() {
        const f = module3.addFunction(fnName + "_reduceTable");
        f.addParam("pTable", "i32");
        f.addParam("p", "i32");
        f.addLocal("half", "i32");
        f.addLocal("it1", "i32");
        f.addLocal("it2", "i32");
        f.addLocal("pAcc", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.i32_eq(c.getLocal("p"), c.i32_const(1)),
            c.ret([])
          ),
          c.setLocal(
            "half",
            c.i32_shl(
              c.i32_const(1),
              c.i32_sub(
                c.getLocal("p"),
                c.i32_const(1)
              )
            )
          ),
          c.setLocal("it1", c.getLocal("pTable")),
          c.setLocal(
            "it2",
            c.i32_add(
              c.getLocal("pTable"),
              c.i32_mul(
                c.getLocal("half"),
                c.i32_const(n8g)
              )
            )
          ),
          c.setLocal(
            "pAcc",
            c.i32_sub(
              c.getLocal("it2"),
              c.i32_const(n8g)
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("it1"),
                c.getLocal("pAcc")
              )
            ),
            c.call(
              prefix + "_add",
              c.getLocal("it1"),
              c.getLocal("it2"),
              c.getLocal("it1")
            ),
            c.call(
              prefix + "_add",
              c.getLocal("pAcc"),
              c.getLocal("it2"),
              c.getLocal("pAcc")
            ),
            c.setLocal("it1", c.i32_add(c.getLocal("it1"), c.i32_const(n8g))),
            c.setLocal("it2", c.i32_add(c.getLocal("it2"), c.i32_const(n8g))),
            c.br(0)
          )),
          c.call(
            fnName + "_reduceTable",
            c.getLocal("pTable"),
            c.i32_sub(
              c.getLocal("p"),
              c.i32_const(1)
            )
          ),
          c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
          c.block(c.loop(
            c.br_if(1, c.i32_eqz(c.getLocal("p"))),
            c.call(prefix + "_double", c.getLocal("pAcc"), c.getLocal("pAcc")),
            c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
            c.br(0)
          )),
          c.call(prefix + "_add", c.getLocal("pTable"), c.getLocal("pAcc"), c.getLocal("pTable"))
        );
      }
      buildGetChunk();
      buildReduceTable();
      buildMutiexpChunk();
      buildMultiexp5();
      module3.exportFunction(fnName);
      module3.exportFunction(fnName + "_chunk");
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_curve_jacobian_a0.js
var require_build_curve_jacobian_a02 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_curve_jacobian_a0.js"(exports, module2) {
    "use strict";
    var buildTimesScalarNAF = require_build_timesscalarnaf2();
    var buildBatchConvertion = require_build_batchconvertion2();
    var buildMultiexp4 = require_build_multiexp2();
    module2.exports = function buildCurve(module3, prefix, prefixField, pB) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      if (module3.modules[prefix])
        return prefix;
      module3.modules[prefix] = {
        n64: n64 * 3
      };
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("p1", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_isZero",
          c.i32_add(
            c.getLocal("p1"),
            c.i32_const(n8 * 2)
          )
        ));
      }
      function buildIsZeroAffine() {
        const f = module3.addFunction(prefix + "_isZeroAffine");
        f.addParam("p1", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.i32_and(
            c.call(
              prefixField + "_isZero",
              c.getLocal("p1")
            ),
            c.call(
              prefixField + "_isZero",
              c.i32_add(
                c.getLocal("p1"),
                c.i32_const(n8)
              )
            )
          )
        );
      }
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("ps", "i32");
        f.addParam("pd", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64 * 3; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pd"),
              i * 8,
              c.i64_load(
                c.getLocal("ps"),
                i * 8
              )
            )
          );
        }
      }
      function buildCopyAffine() {
        const f = module3.addFunction(prefix + "_copyAffine");
        f.addParam("ps", "i32");
        f.addParam("pd", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64 * 2; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pd"),
              i * 8,
              c.i64_load(
                c.getLocal("ps"),
                i * 8
              )
            )
          );
        }
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_zero",
          c.getLocal("pr")
        ));
        f.addCode(c.call(
          prefixField + "_one",
          c.i32_add(
            c.getLocal("pr"),
            c.i32_const(n8)
          )
        ));
        f.addCode(c.call(
          prefixField + "_zero",
          c.i32_add(
            c.getLocal("pr"),
            c.i32_const(n8 * 2)
          )
        ));
      }
      function buildZeroAffine() {
        const f = module3.addFunction(prefix + "_zeroAffine");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_zero",
          c.getLocal("pr")
        ));
        f.addCode(c.call(
          prefixField + "_zero",
          c.i32_add(
            c.getLocal("pr"),
            c.i32_const(n8)
          )
        ));
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");
        f.addLocal("z2", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        f.addCode(c.setLocal("z2", c.i32_add(c.getLocal("p2"), c.i32_const(n8 * 2))));
        const z2 = c.getLocal("z2");
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const Z2Z2 = c.i32_const(module3.alloc(n8));
        const U1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const Z2_cubed = c.i32_const(module3.alloc(n8));
        const S1 = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            c.ret(c.call(prefix + "_isZero", c.getLocal("p2")))
          ),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p2")),
            c.ret(c.i32_const(0))
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            c.ret(c.call(prefix + "_eqMixed", c.getLocal("p2"), c.getLocal("p1")))
          ),
          c.if(
            c.call(prefixField + "_isOne", z2),
            c.ret(c.call(prefix + "_eqMixed", c.getLocal("p1"), c.getLocal("p2")))
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_square", z2, Z2Z2),
          c.call(prefixField + "_mul", x1, Z2Z2, U1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
          c.call(prefixField + "_mul", y1, Z2_cubed, S1),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", U1, U2),
            c.if(
              c.call(prefixField + "_eq", S1, S2),
              c.ret(c.i32_const(1))
            )
          ),
          c.ret(c.i32_const(0))
        );
      }
      function buildEqMixed() {
        const f = module3.addFunction(prefix + "_eqMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            c.ret(c.call(prefix + "_isZeroAffine", c.getLocal("p2")))
          ),
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
            c.ret(c.i32_const(0))
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            c.ret(c.call(prefix + "_eqAffine", c.getLocal("p1"), c.getLocal("p2")))
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", x1, U2),
            c.if(
              c.call(prefixField + "_eq", y1, S2),
              c.ret(c.i32_const(1))
            )
          ),
          c.ret(c.i32_const(0))
        );
      }
      function buildDouble() {
        const f = module3.addFunction(prefix + "_double");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const A = c.i32_const(module3.alloc(n8));
        const B = c.i32_const(module3.alloc(n8));
        const C = c.i32_const(module3.alloc(n8));
        const D = c.i32_const(module3.alloc(n8));
        const E = c.i32_const(module3.alloc(n8));
        const F = c.i32_const(module3.alloc(n8));
        const G = c.i32_const(module3.alloc(n8));
        const eightC = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z),
            [
              ...c.ret(c.call(prefix + "_doubleAffine", c.getLocal("p1"), c.getLocal("pr"))),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_square", x, A),
          c.call(prefixField + "_square", y, B),
          c.call(prefixField + "_square", B, C),
          c.call(prefixField + "_add", x, B, D),
          c.call(prefixField + "_square", D, D),
          c.call(prefixField + "_sub", D, A, D),
          c.call(prefixField + "_sub", D, C, D),
          c.call(prefixField + "_add", D, D, D),
          c.call(prefixField + "_add", A, A, E),
          c.call(prefixField + "_add", E, A, E),
          c.call(prefixField + "_square", E, F),
          c.call(prefixField + "_mul", y, z, G),
          c.call(prefixField + "_add", D, D, x3),
          c.call(prefixField + "_sub", F, x3, x3),
          c.call(prefixField + "_add", C, C, eightC),
          c.call(prefixField + "_add", eightC, eightC, eightC),
          c.call(prefixField + "_add", eightC, eightC, eightC),
          c.call(prefixField + "_sub", D, x3, y3),
          c.call(prefixField + "_mul", y3, E, y3),
          c.call(prefixField + "_sub", y3, eightC, y3),
          c.call(prefixField + "_add", G, G, z3)
        );
      }
      function buildDoubleAffine() {
        const f = module3.addFunction(prefix + "_doubleAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const XX = c.i32_const(module3.alloc(n8));
        const YY = c.i32_const(module3.alloc(n8));
        const YYYY = c.i32_const(module3.alloc(n8));
        const S = c.i32_const(module3.alloc(n8));
        const M = c.i32_const(module3.alloc(n8));
        const eightYYYY = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p1")),
            [
              ...c.call(prefix + "_toJacobian", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          // XX = X1^2
          c.call(prefixField + "_square", x, XX),
          // YY = Y1^2
          c.call(prefixField + "_square", y, YY),
          // YYYY = YY^2
          c.call(prefixField + "_square", YY, YYYY),
          // S = 2*((X1+YY)^2-XX-YYYY)
          c.call(prefixField + "_add", x, YY, S),
          c.call(prefixField + "_square", S, S),
          c.call(prefixField + "_sub", S, XX, S),
          c.call(prefixField + "_sub", S, YYYY, S),
          c.call(prefixField + "_add", S, S, S),
          // M = 3*XX+a  (Hera a=0)
          c.call(prefixField + "_add", XX, XX, M),
          c.call(prefixField + "_add", M, XX, M),
          // Z3 = 2*Y1
          c.call(prefixField + "_add", y, y, z3),
          // T = M^2-2*S
          // X3 = T
          c.call(prefixField + "_square", M, x3),
          c.call(prefixField + "_sub", x3, S, x3),
          c.call(prefixField + "_sub", x3, S, x3),
          // Y3 = M*(S-T)-8*YYYY
          c.call(prefixField + "_add", YYYY, YYYY, eightYYYY),
          c.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
          c.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
          c.call(prefixField + "_sub", S, x3, y3),
          c.call(prefixField + "_mul", y3, M, y3),
          c.call(prefixField + "_sub", y3, eightYYYY, y3)
        );
      }
      function buildEqAffine() {
        const f = module3.addFunction(prefix + "_eqAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.ret(c.i32_and(
            c.call(
              prefixField + "_eq",
              c.getLocal("p1"),
              c.getLocal("p2")
            ),
            c.call(
              prefixField + "_eq",
              c.i32_add(c.getLocal("p1"), c.i32_const(n8)),
              c.i32_add(c.getLocal("p2"), c.i32_const(n8))
            )
          ))
        );
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_toMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 3; i++) {
          f.addCode(c.call(
            prefixField + "_toMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildToMontgomeryAffine() {
        const f = module3.addFunction(prefix + "_toMontgomeryAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_toMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 2; i++) {
          f.addCode(c.call(
            prefixField + "_toMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildFromMontgomery() {
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_fromMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 3; i++) {
          f.addCode(c.call(
            prefixField + "_fromMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildFromMontgomeryAffine() {
        const f = module3.addFunction(prefix + "_fromMontgomeryAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_fromMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 2; i++) {
          f.addCode(c.call(
            prefixField + "_fromMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");
        f.addLocal("z2", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        f.addCode(c.setLocal("z2", c.i32_add(c.getLocal("p2"), c.i32_const(n8 * 2))));
        const z2 = c.getLocal("z2");
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const Z2Z2 = c.i32_const(module3.alloc(n8));
        const U1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const Z2_cubed = c.i32_const(module3.alloc(n8));
        const S1 = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        const H = c.i32_const(module3.alloc(n8));
        const S2_minus_S1 = c.i32_const(module3.alloc(n8));
        const I = c.i32_const(module3.alloc(n8));
        const J = c.i32_const(module3.alloc(n8));
        const r = c.i32_const(module3.alloc(n8));
        const r2 = c.i32_const(module3.alloc(n8));
        const V = c.i32_const(module3.alloc(n8));
        const V2 = c.i32_const(module3.alloc(n8));
        const S1_J2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p2"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p2")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            [
              ...c.call(prefix + "_addMixed", x2, x1, x3),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z2),
            [
              ...c.call(prefix + "_addMixed", x1, x2, x3),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_square", z2, Z2Z2),
          c.call(prefixField + "_mul", x1, Z2Z2, U1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
          c.call(prefixField + "_mul", y1, Z2_cubed, S1),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", U1, U2),
            c.if(
              c.call(prefixField + "_eq", S1, S2),
              [
                ...c.call(prefix + "_double", c.getLocal("p1"), c.getLocal("pr")),
                ...c.ret([])
              ]
            )
          ),
          c.call(prefixField + "_sub", U2, U1, H),
          c.call(prefixField + "_sub", S2, S1, S2_minus_S1),
          c.call(prefixField + "_add", H, H, I),
          c.call(prefixField + "_square", I, I),
          c.call(prefixField + "_mul", H, I, J),
          c.call(prefixField + "_add", S2_minus_S1, S2_minus_S1, r),
          c.call(prefixField + "_mul", U1, I, V),
          c.call(prefixField + "_square", r, r2),
          c.call(prefixField + "_add", V, V, V2),
          c.call(prefixField + "_sub", r2, J, x3),
          c.call(prefixField + "_sub", x3, V2, x3),
          c.call(prefixField + "_mul", S1, J, S1_J2),
          c.call(prefixField + "_add", S1_J2, S1_J2, S1_J2),
          c.call(prefixField + "_sub", V, x3, y3),
          c.call(prefixField + "_mul", y3, r, y3),
          c.call(prefixField + "_sub", y3, S1_J2, y3),
          c.call(prefixField + "_add", z1, z2, z3),
          c.call(prefixField + "_square", z3, z3),
          c.call(prefixField + "_sub", z3, Z1Z1, z3),
          c.call(prefixField + "_sub", z3, Z2Z2, z3),
          c.call(prefixField + "_mul", z3, H, z3)
        );
      }
      function buildAddMixed() {
        const f = module3.addFunction(prefix + "_addMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        const H = c.i32_const(module3.alloc(n8));
        const HH = c.i32_const(module3.alloc(n8));
        const S2_minus_y1 = c.i32_const(module3.alloc(n8));
        const I = c.i32_const(module3.alloc(n8));
        const J = c.i32_const(module3.alloc(n8));
        const r = c.i32_const(module3.alloc(n8));
        const r2 = c.i32_const(module3.alloc(n8));
        const V = c.i32_const(module3.alloc(n8));
        const V2 = c.i32_const(module3.alloc(n8));
        const y1_J2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copyAffine", c.getLocal("p2"), c.getLocal("pr")),
              ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            [
              ...c.call(prefix + "_addAffine", x1, x2, x3),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", x1, U2),
            c.if(
              c.call(prefixField + "_eq", y1, S2),
              [
                ...c.call(prefix + "_doubleAffine", c.getLocal("p2"), c.getLocal("pr")),
                ...c.ret([])
              ]
            )
          ),
          c.call(prefixField + "_sub", U2, x1, H),
          c.call(prefixField + "_sub", S2, y1, S2_minus_y1),
          c.call(prefixField + "_square", H, HH),
          c.call(prefixField + "_add", HH, HH, I),
          c.call(prefixField + "_add", I, I, I),
          c.call(prefixField + "_mul", H, I, J),
          c.call(prefixField + "_add", S2_minus_y1, S2_minus_y1, r),
          c.call(prefixField + "_mul", x1, I, V),
          c.call(prefixField + "_square", r, r2),
          c.call(prefixField + "_add", V, V, V2),
          c.call(prefixField + "_sub", r2, J, x3),
          c.call(prefixField + "_sub", x3, V2, x3),
          c.call(prefixField + "_mul", y1, J, y1_J2),
          c.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
          c.call(prefixField + "_sub", V, x3, y3),
          c.call(prefixField + "_mul", y3, r, y3),
          c.call(prefixField + "_sub", y3, y1_J2, y3),
          c.call(prefixField + "_add", z1, H, z3),
          c.call(prefixField + "_square", z3, z3),
          c.call(prefixField + "_sub", z3, Z1Z1, z3),
          c.call(prefixField + "_sub", z3, HH, z3)
        );
      }
      function buildAddAffine() {
        const f = module3.addFunction(prefix + "_addAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const H = c.i32_const(module3.alloc(n8));
        const HH = c.i32_const(module3.alloc(n8));
        const y2_minus_y1 = c.i32_const(module3.alloc(n8));
        const I = c.i32_const(module3.alloc(n8));
        const J = c.i32_const(module3.alloc(n8));
        const r = c.i32_const(module3.alloc(n8));
        const r2 = c.i32_const(module3.alloc(n8));
        const V = c.i32_const(module3.alloc(n8));
        const V2 = c.i32_const(module3.alloc(n8));
        const y1_J2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copyAffine", c.getLocal("p2"), c.getLocal("pr")),
              ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
            [
              ...c.call(prefix + "_copyAffine", c.getLocal("p1"), c.getLocal("pr")),
              ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_eq", x1, x2),
            c.if(
              c.call(prefixField + "_eq", y1, y2),
              [
                ...c.call(prefix + "_doubleAffine", c.getLocal("p2"), c.getLocal("pr")),
                ...c.ret([])
              ]
            )
          ),
          c.call(prefixField + "_sub", x2, x1, H),
          c.call(prefixField + "_sub", y2, y1, y2_minus_y1),
          c.call(prefixField + "_square", H, HH),
          c.call(prefixField + "_add", HH, HH, I),
          c.call(prefixField + "_add", I, I, I),
          c.call(prefixField + "_mul", H, I, J),
          c.call(prefixField + "_add", y2_minus_y1, y2_minus_y1, r),
          c.call(prefixField + "_mul", x1, I, V),
          c.call(prefixField + "_square", r, r2),
          c.call(prefixField + "_add", V, V, V2),
          c.call(prefixField + "_sub", r2, J, x3),
          c.call(prefixField + "_sub", x3, V2, x3),
          c.call(prefixField + "_mul", y1, J, y1_J2),
          c.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
          c.call(prefixField + "_sub", V, x3, y3),
          c.call(prefixField + "_mul", y3, r, y3),
          c.call(prefixField + "_sub", y3, y1_J2, y3),
          c.call(prefixField + "_add", H, H, z3)
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        f.addCode(
          c.call(prefixField + "_copy", x, x3),
          c.call(prefixField + "_neg", y, y3),
          c.call(prefixField + "_copy", z, z3)
        );
      }
      function buildNegAffine() {
        const f = module3.addFunction(prefix + "_negAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        f.addCode(
          c.call(prefixField + "_copy", x, x3),
          c.call(prefixField + "_neg", y, y3)
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8 * 3));
        f.addCode(
          c.call(prefix + "_neg", c.getLocal("p2"), AUX),
          c.call(prefix + "_add", c.getLocal("p1"), AUX, c.getLocal("pr"))
        );
      }
      function buildSubMixed() {
        const f = module3.addFunction(prefix + "_subMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8 * 3));
        f.addCode(
          c.call(prefix + "_negAffine", c.getLocal("p2"), AUX),
          c.call(prefix + "_addMixed", c.getLocal("p1"), AUX, c.getLocal("pr"))
        );
      }
      function buildSubAffine() {
        const f = module3.addFunction(prefix + "_subAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8 * 3));
        f.addCode(
          c.call(prefix + "_negAffine", c.getLocal("p2"), AUX),
          c.call(prefix + "_addAffine", c.getLocal("p1"), AUX, c.getLocal("pr"))
        );
      }
      function buildNormalize() {
        const f = module3.addFunction(prefix + "_normalize");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const Z_inv = c.i32_const(module3.alloc(n8));
        const Z2_inv = c.i32_const(module3.alloc(n8));
        const Z3_inv = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            c.call(prefix + "_zero", c.getLocal("pr")),
            [
              ...c.call(prefixField + "_inverse", z, Z_inv),
              ...c.call(prefixField + "_square", Z_inv, Z2_inv),
              ...c.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
              ...c.call(prefixField + "_mul", x, Z2_inv, x3),
              ...c.call(prefixField + "_mul", y, Z3_inv, y3),
              ...c.call(prefixField + "_one", z3)
            ]
          )
        );
      }
      function buildToAffine() {
        const f = module3.addFunction(prefix + "_toAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const Z_inv = c.i32_const(module3.alloc(n8));
        const Z2_inv = c.i32_const(module3.alloc(n8));
        const Z3_inv = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefixField + "_zero", x3),
              ...c.call(prefixField + "_zero", y3)
            ],
            [
              ...c.call(prefixField + "_inverse", z, Z_inv),
              ...c.call(prefixField + "_square", Z_inv, Z2_inv),
              ...c.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
              ...c.call(prefixField + "_mul", x, Z2_inv, x3),
              ...c.call(prefixField + "_mul", y, Z3_inv, y3)
            ]
          )
        );
      }
      function buildToJacobian() {
        const f = module3.addFunction(prefix + "_toJacobian");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p1")),
            c.call(prefix + "_zero", c.getLocal("pr")),
            [
              ...c.call(prefixField + "_one", z3),
              ...c.call(prefixField + "_copy", y, y3),
              ...c.call(prefixField + "_copy", x, x3)
            ]
          )
        );
      }
      function buildBatchToAffine() {
        const f = module3.addFunction(prefix + "_batchToAffine");
        f.addParam("pIn", "i32");
        f.addParam("n", "i32");
        f.addParam("pOut", "i32");
        f.addLocal("pAux", "i32");
        f.addLocal("itIn", "i32");
        f.addLocal("itAux", "i32");
        f.addLocal("itOut", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const tmp = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("pAux", c.i32_load(c.i32_const(0))),
          c.i32_store(
            c.i32_const(0),
            c.i32_add(
              c.getLocal("pAux"),
              c.i32_mul(c.getLocal("n"), c.i32_const(n8))
            )
          ),
          c.call(
            prefixField + "_batchInverse",
            c.i32_add(c.getLocal("pIn"), c.i32_const(n8 * 2)),
            c.i32_const(n8 * 3),
            c.getLocal("n"),
            c.getLocal("pAux"),
            c.i32_const(n8)
          ),
          c.setLocal("itIn", c.getLocal("pIn")),
          c.setLocal("itAux", c.getLocal("pAux")),
          c.setLocal("itOut", c.getLocal("pOut")),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.if(
              c.call(prefixField + "_isZero", c.getLocal("itAux")),
              [
                ...c.call(prefixField + "_zero", c.getLocal("itOut")),
                ...c.call(prefixField + "_zero", c.i32_add(c.getLocal("itOut"), c.i32_const(n8)))
              ],
              [
                ...c.call(
                  prefixField + "_mul",
                  c.getLocal("itAux"),
                  c.i32_add(c.getLocal("itIn"), c.i32_const(n8)),
                  tmp
                ),
                ...c.call(
                  prefixField + "_square",
                  c.getLocal("itAux"),
                  c.getLocal("itAux")
                ),
                ...c.call(
                  prefixField + "_mul",
                  c.getLocal("itAux"),
                  c.getLocal("itIn"),
                  c.getLocal("itOut")
                ),
                ...c.call(
                  prefixField + "_mul",
                  c.getLocal("itAux"),
                  tmp,
                  c.i32_add(c.getLocal("itOut"), c.i32_const(n8))
                )
              ]
            ),
            c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.i32_const(n8 * 3))),
            c.setLocal("itOut", c.i32_add(c.getLocal("itOut"), c.i32_const(n8 * 2))),
            c.setLocal("itAux", c.i32_add(c.getLocal("itAux"), c.i32_const(n8))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          )),
          c.i32_store(
            c.i32_const(0),
            c.getLocal("pAux")
          )
        );
      }
      function buildReverseBytes() {
        const f = module3.addFunction(prefix + "__reverseBytes");
        f.addParam("pIn", "i32");
        f.addParam("n", "i32");
        f.addParam("pOut", "i32");
        f.addLocal("itOut", "i32");
        f.addLocal("itIn", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "itOut",
            c.i32_sub(
              c.i32_add(
                c.getLocal("pOut"),
                c.getLocal("n")
              ),
              c.i32_const(1)
            )
          ),
          c.setLocal(
            "itIn",
            c.getLocal("pIn")
          ),
          c.block(c.loop(
            c.br_if(1, c.i32_lt_s(c.getLocal("itOut"), c.getLocal("pOut"))),
            c.i32_store8(
              c.getLocal("itOut"),
              c.i32_load8_u(c.getLocal("itIn"))
            ),
            c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.i32_const(1))),
            c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildLEMtoC() {
        const f = module3.addFunction(prefix + "_LEMtoC");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        const c = f.getCodeBuilder();
        const tmp = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("pIn")),
            [
              ...c.call(prefixField + "_zero", c.getLocal("pOut")),
              ...c.i32_store8(
                c.getLocal("pOut"),
                c.i32_const(64)
              ),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_fromMontgomery", c.getLocal("pIn"), tmp),
          c.call(prefix + "__reverseBytes", tmp, c.i32_const(n8), c.getLocal("pOut")),
          c.if(
            c.i32_eq(
              c.call(prefixField + "_sign", c.i32_add(c.getLocal("pIn"), c.i32_const(n8))),
              c.i32_const(-1)
            ),
            c.i32_store8(
              c.getLocal("pOut"),
              c.i32_or(
                c.i32_load8_u(c.getLocal("pOut")),
                c.i32_const(128)
              )
            )
          )
        );
      }
      function buildLEMtoU() {
        const f = module3.addFunction(prefix + "_LEMtoU");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        const c = f.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmp = c.i32_const(pTmp);
        const tmpX = c.i32_const(pTmp);
        const tmpY = c.i32_const(pTmp + n8);
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("pIn")),
            [
              ...c.call(prefix + "_zeroAffine", c.getLocal("pOut")),
              ...c.ret([])
            ]
          ),
          c.call(prefix + "_fromMontgomeryAffine", c.getLocal("pIn"), tmp),
          c.call(prefix + "__reverseBytes", tmpX, c.i32_const(n8), c.getLocal("pOut")),
          c.call(prefix + "__reverseBytes", tmpY, c.i32_const(n8), c.i32_add(c.getLocal("pOut"), c.i32_const(n8)))
        );
      }
      function buildUtoLEM() {
        const f = module3.addFunction(prefix + "_UtoLEM");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        const c = f.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmp = c.i32_const(pTmp);
        const tmpX = c.i32_const(pTmp);
        const tmpY = c.i32_const(pTmp + n8);
        f.addCode(
          c.if(
            c.i32_and(c.i32_load8_u(c.getLocal("pIn")), c.i32_const(64)),
            [
              ...c.call(prefix + "_zeroAffine", c.getLocal("pOut")),
              ...c.ret([])
            ]
          ),
          c.call(prefix + "__reverseBytes", c.getLocal("pIn"), c.i32_const(n8), tmpX),
          c.call(prefix + "__reverseBytes", c.i32_add(c.getLocal("pIn"), c.i32_const(n8)), c.i32_const(n8), tmpY),
          c.call(prefix + "_toMontgomeryAffine", tmp, c.getLocal("pOut"))
        );
      }
      function buildCtoLEM() {
        const f = module3.addFunction(prefix + "_CtoLEM");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        f.addLocal("firstByte", "i32");
        f.addLocal("greatest", "i32");
        const c = f.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmpX = c.i32_const(pTmp);
        const tmpY = c.i32_const(pTmp + n8);
        f.addCode(
          c.setLocal("firstByte", c.i32_load8_u(c.getLocal("pIn"))),
          c.if(
            c.i32_and(
              c.getLocal("firstByte"),
              c.i32_const(64)
            ),
            [
              ...c.call(prefix + "_zeroAffine", c.getLocal("pOut")),
              ...c.ret([])
            ]
          ),
          c.setLocal(
            "greatest",
            c.i32_and(
              c.getLocal("firstByte"),
              c.i32_const(128)
            )
          ),
          c.call(prefixField + "_copy", c.getLocal("pIn"), tmpY),
          c.i32_store8(tmpY, c.i32_and(c.getLocal("firstByte"), c.i32_const(63))),
          c.call(prefix + "__reverseBytes", tmpY, c.i32_const(n8), tmpX),
          c.call(prefixField + "_toMontgomery", tmpX, c.getLocal("pOut")),
          c.call(prefixField + "_square", c.getLocal("pOut"), tmpY),
          c.call(prefixField + "_mul", c.getLocal("pOut"), tmpY, tmpY),
          c.call(prefixField + "_add", tmpY, c.i32_const(pB), tmpY),
          c.call(prefixField + "_sqrt", tmpY, tmpY),
          c.call(prefixField + "_neg", tmpY, tmpX),
          c.if(
            c.i32_eq(
              c.call(prefixField + "_sign", tmpY),
              c.i32_const(-1)
            ),
            c.if(
              c.getLocal("greatest"),
              c.call(prefixField + "_copy", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8))),
              c.call(prefixField + "_neg", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8)))
            ),
            c.if(
              c.getLocal("greatest"),
              c.call(prefixField + "_neg", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8))),
              c.call(prefixField + "_copy", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8)))
            )
          )
        );
      }
      function buildInCurveAffine() {
        const f = module3.addFunction(prefix + "_inCurveAffine");
        f.addParam("pIn", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("pIn");
        const y = c.i32_add(c.getLocal("pIn"), c.i32_const(n8));
        const y2 = c.i32_const(module3.alloc(n8));
        const x3b = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call(prefixField + "_square", y, y2),
          c.call(prefixField + "_square", x, x3b),
          c.call(prefixField + "_mul", x, x3b, x3b),
          c.call(prefixField + "_add", x3b, c.i32_const(pB), x3b),
          c.ret(
            c.call(prefixField + "_eq", y2, x3b)
          )
        );
      }
      function buildInCurve() {
        const f = module3.addFunction(prefix + "_inCurve");
        f.addParam("pIn", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8 * 2));
        f.addCode(
          c.call(prefix + "_toAffine", c.getLocal("pIn"), aux),
          c.ret(
            c.call(prefix + "_inCurveAffine", aux)
          )
        );
      }
      buildIsZeroAffine();
      buildIsZero();
      buildZeroAffine();
      buildZero();
      buildCopyAffine();
      buildCopy();
      buildToJacobian();
      buildEqAffine();
      buildEqMixed();
      buildEq();
      buildDoubleAffine();
      buildDouble();
      buildAddAffine();
      buildAddMixed();
      buildAdd();
      buildNegAffine();
      buildNeg();
      buildSubAffine();
      buildSubMixed();
      buildSub();
      buildFromMontgomeryAffine();
      buildFromMontgomery();
      buildToMontgomeryAffine();
      buildToMontgomery();
      buildToAffine();
      buildInCurveAffine();
      buildInCurve();
      buildBatchToAffine();
      buildNormalize();
      buildReverseBytes();
      buildLEMtoU();
      buildLEMtoC();
      buildUtoLEM();
      buildCtoLEM();
      buildBatchConvertion(module3, prefix + "_batchLEMtoU", prefix + "_LEMtoU", n8 * 2, n8 * 2);
      buildBatchConvertion(module3, prefix + "_batchLEMtoC", prefix + "_LEMtoC", n8 * 2, n8);
      buildBatchConvertion(module3, prefix + "_batchUtoLEM", prefix + "_UtoLEM", n8 * 2, n8 * 2);
      buildBatchConvertion(module3, prefix + "_batchCtoLEM", prefix + "_CtoLEM", n8, n8 * 2, true);
      buildBatchConvertion(module3, prefix + "_batchToJacobian", prefix + "_toJacobian", n8 * 2, n8 * 3, true);
      buildMultiexp4(module3, prefix, prefix + "_multiexp", prefix + "_add", n8 * 3);
      buildMultiexp4(module3, prefix, prefix + "_multiexpAffine", prefix + "_addMixed", n8 * 2);
      buildTimesScalarNAF(
        module3,
        prefix + "_timesScalar",
        n8 * 3,
        prefix + "_add",
        prefix + "_double",
        prefix + "_sub",
        prefix + "_copy",
        prefix + "_zero"
      );
      buildTimesScalarNAF(
        module3,
        prefix + "_timesScalarAffine",
        n8 * 2,
        prefix + "_addMixed",
        prefix + "_double",
        prefix + "_subMixed",
        prefix + "_copyAffine",
        prefix + "_zero"
      );
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isZeroAffine");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_eqMixed");
      module3.exportFunction(prefix + "_eqAffine");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_copyAffine");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_zeroAffine");
      module3.exportFunction(prefix + "_double");
      module3.exportFunction(prefix + "_doubleAffine");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_addMixed");
      module3.exportFunction(prefix + "_addAffine");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_negAffine");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_subMixed");
      module3.exportFunction(prefix + "_subAffine");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_fromMontgomeryAffine");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_toMontgomeryAffine");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_timesScalarAffine");
      module3.exportFunction(prefix + "_normalize");
      module3.exportFunction(prefix + "_LEMtoU");
      module3.exportFunction(prefix + "_LEMtoC");
      module3.exportFunction(prefix + "_UtoLEM");
      module3.exportFunction(prefix + "_CtoLEM");
      module3.exportFunction(prefix + "_batchLEMtoU");
      module3.exportFunction(prefix + "_batchLEMtoC");
      module3.exportFunction(prefix + "_batchUtoLEM");
      module3.exportFunction(prefix + "_batchCtoLEM");
      module3.exportFunction(prefix + "_toAffine");
      module3.exportFunction(prefix + "_toJacobian");
      module3.exportFunction(prefix + "_batchToAffine");
      module3.exportFunction(prefix + "_batchToJacobian");
      module3.exportFunction(prefix + "_inCurve");
      module3.exportFunction(prefix + "_inCurveAffine");
      return prefix;
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_fft.js
var require_build_fft2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_fft.js"(exports, module2) {
    "use strict";
    var { isOdd: isOdd4, modInv, modPow } = require_bigint2();
    var utils2 = require_utils2();
    module2.exports = function buildFFT4(module3, prefix, gPrefix, fPrefix, opGtimesF) {
      const n64f = module3.modules[fPrefix].n64;
      const n8f = n64f * 8;
      const n64g = module3.modules[gPrefix].n64;
      const n8g = n64g * 8;
      const q = module3.modules[fPrefix].q;
      let rem = q - 1n;
      let maxBits = 0;
      while (!isOdd4(rem)) {
        maxBits++;
        rem = rem >> 1n;
      }
      let nr = 2n;
      while (modPow(nr, q >> 1n, q) === 1n)
        nr = nr + 1n;
      const w = new Array(maxBits + 1);
      w[maxBits] = modPow(nr, rem, q);
      let n = maxBits - 1;
      while (n >= 0) {
        w[n] = modPow(w[n + 1], 2n, q);
        n--;
      }
      const bytes = [];
      const R = (1n << BigInt(n8f * 8)) % q;
      for (let i = 0; i < w.length; i++) {
        const m = w[i] * R % q;
        bytes.push(...utils2.bigInt2BytesLE(m, n8f));
      }
      const ROOTs = module3.alloc(bytes);
      const i2 = new Array(maxBits + 1);
      i2[0] = 1n;
      for (let i = 1; i <= maxBits; i++) {
        i2[i] = i2[i - 1] * 2n;
      }
      const bytesi2 = [];
      for (let i = 0; i <= maxBits; i++) {
        const m = modInv(i2[i], q) * R % q;
        bytesi2.push(...utils2.bigInt2BytesLE(m, n8f));
      }
      const INV2 = module3.alloc(bytesi2);
      const shift = modPow(nr, 2n, q);
      const bytesShiftToSmallM = [];
      const bytesSConst = [];
      for (let i = 0; i <= maxBits; i++) {
        const shiftToSmallM = modPow(shift, 2n ** BigInt(i), q);
        const sConst = modInv(q + 1n - shiftToSmallM, q);
        bytesShiftToSmallM.push(...utils2.bigInt2BytesLE(shiftToSmallM * R % q, n8f));
        bytesSConst.push(...utils2.bigInt2BytesLE(sConst * R % q, n8f));
      }
      const SHIFT_TO_M = module3.alloc(bytesShiftToSmallM);
      const SCONST = module3.alloc(bytesSConst);
      function rev(x) {
        let r = 0;
        for (let i = 0; i < 8; i++) {
          if (x & 1 << i) {
            r = r | 128 >> i;
          }
        }
        return r;
      }
      const rtable = Array(256);
      for (let i = 0; i < 256; i++) {
        rtable[i] = rev(i);
      }
      const REVTABLE = module3.alloc(rtable);
      function buildLog2() {
        const f = module3.addFunction(prefix + "__log2");
        f.addParam("n", "i32");
        f.setReturnType("i32");
        f.addLocal("bits", "i32");
        f.addLocal("aux", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "aux",
            c.i32_shr_u(
              c.getLocal("n"),
              c.i32_const(1)
            )
          )
        );
        f.addCode(c.setLocal("bits", c.i32_const(0)));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.i32_eqz(c.getLocal("aux"))
          ),
          c.setLocal(
            "aux",
            c.i32_shr_u(
              c.getLocal("aux"),
              c.i32_const(1)
            )
          ),
          c.setLocal(
            "bits",
            c.i32_add(
              c.getLocal("bits"),
              c.i32_const(1)
            )
          ),
          c.br(0)
        )));
        f.addCode(c.if(
          c.i32_ne(
            c.getLocal("n"),
            c.i32_shl(
              c.i32_const(1),
              c.getLocal("bits")
            )
          ),
          c.unreachable()
        ));
        f.addCode(c.if(
          c.i32_gt_u(
            c.getLocal("bits"),
            c.i32_const(maxBits)
          ),
          c.unreachable()
        ));
        f.addCode(c.getLocal("bits"));
      }
      function buildFFT5() {
        const f = module3.addFunction(prefix + "_fft");
        f.addParam("px", "i32");
        f.addParam("n", "i32");
        f.addLocal("bits", "i32");
        const c = f.getCodeBuilder();
        const One = c.i32_const(module3.alloc(n8f));
        f.addCode(
          c.setLocal(
            "bits",
            c.call(
              prefix + "__log2",
              c.getLocal("n")
            )
          ),
          c.call(fPrefix + "_one", One),
          c.call(
            prefix + "_rawfft",
            c.getLocal("px"),
            c.getLocal("bits"),
            c.i32_const(0),
            One
          )
        );
      }
      function buildIFFT() {
        const f = module3.addFunction(prefix + "_ifft");
        f.addParam("px", "i32");
        f.addParam("n", "i32");
        f.addLocal("bits", "i32");
        f.addLocal("pInv2", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "bits",
            c.call(
              prefix + "__log2",
              c.getLocal("n")
            )
          ),
          c.setLocal(
            "pInv2",
            c.i32_add(
              c.i32_const(INV2),
              c.i32_mul(
                c.getLocal("bits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(
            prefix + "_rawfft",
            c.getLocal("px"),
            c.getLocal("bits"),
            c.i32_const(1),
            c.getLocal("pInv2")
          )
        );
      }
      function buildRawFFT() {
        const f = module3.addFunction(prefix + "_rawfft");
        f.addParam("px", "i32");
        f.addParam("bits", "i32");
        f.addParam("reverse", "i32");
        f.addParam("mulFactor", "i32");
        f.addLocal("s", "i32");
        f.addLocal("k", "i32");
        f.addLocal("j", "i32");
        f.addLocal("m", "i32");
        f.addLocal("mdiv2", "i32");
        f.addLocal("n", "i32");
        f.addLocal("pwm", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const T = c.i32_const(module3.alloc(n8g));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.call(prefix + "__reversePermutation", c.getLocal("px"), c.getLocal("bits")),
          c.setLocal("n", c.i32_shl(c.i32_const(1), c.getLocal("bits"))),
          c.setLocal("s", c.i32_const(1)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_gt_u(
                c.getLocal("s"),
                c.getLocal("bits")
              )
            ),
            c.setLocal("m", c.i32_shl(c.i32_const(1), c.getLocal("s"))),
            c.setLocal(
              "pwm",
              c.i32_add(
                c.i32_const(ROOTs),
                c.i32_mul(
                  c.getLocal("s"),
                  c.i32_const(n8f)
                )
              )
            ),
            c.setLocal("k", c.i32_const(0)),
            c.block(c.loop(
              c.br_if(
                1,
                c.i32_ge_u(
                  c.getLocal("k"),
                  c.getLocal("n")
                )
              ),
              c.call(fPrefix + "_one", W),
              c.setLocal("mdiv2", c.i32_shr_u(c.getLocal("m"), c.i32_const(1))),
              c.setLocal("j", c.i32_const(0)),
              c.block(c.loop(
                c.br_if(
                  1,
                  c.i32_ge_u(
                    c.getLocal("j"),
                    c.getLocal("mdiv2")
                  )
                ),
                c.setLocal(
                  "idx1",
                  c.i32_add(
                    c.getLocal("px"),
                    c.i32_mul(
                      c.i32_add(
                        c.getLocal("k"),
                        c.getLocal("j")
                      ),
                      c.i32_const(n8g)
                    )
                  )
                ),
                c.setLocal(
                  "idx2",
                  c.i32_add(
                    c.getLocal("idx1"),
                    c.i32_mul(
                      c.getLocal("mdiv2"),
                      c.i32_const(n8g)
                    )
                  )
                ),
                c.call(
                  opGtimesF,
                  c.getLocal("idx2"),
                  W,
                  T
                ),
                c.call(
                  gPrefix + "_copy",
                  c.getLocal("idx1"),
                  U
                ),
                c.call(
                  gPrefix + "_add",
                  U,
                  T,
                  c.getLocal("idx1")
                ),
                c.call(
                  gPrefix + "_sub",
                  U,
                  T,
                  c.getLocal("idx2")
                ),
                c.call(
                  fPrefix + "_mul",
                  W,
                  c.getLocal("pwm"),
                  W
                ),
                c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
                c.br(0)
              )),
              c.setLocal("k", c.i32_add(c.getLocal("k"), c.getLocal("m"))),
              c.br(0)
            )),
            c.setLocal("s", c.i32_add(c.getLocal("s"), c.i32_const(1))),
            c.br(0)
          )),
          c.call(
            prefix + "__fftFinal",
            c.getLocal("px"),
            c.getLocal("bits"),
            c.getLocal("reverse"),
            c.getLocal("mulFactor")
          )
        );
      }
      function buildFinalInverse() {
        const f = module3.addFunction(prefix + "__fftFinal");
        f.addParam("px", "i32");
        f.addParam("bits", "i32");
        f.addParam("reverse", "i32");
        f.addParam("mulFactor", "i32");
        f.addLocal("n", "i32");
        f.addLocal("ndiv2", "i32");
        f.addLocal("pInv2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("mask", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        const c = f.getCodeBuilder();
        const T = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.if(
            c.i32_and(
              c.i32_eqz(c.getLocal("reverse")),
              c.call(fPrefix + "_isOne", c.getLocal("mulFactor"))
            ),
            c.ret([])
          ),
          c.setLocal("n", c.i32_shl(c.i32_const(1), c.getLocal("bits"))),
          c.setLocal("mask", c.i32_sub(c.getLocal("n"), c.i32_const(1))),
          c.setLocal("i", c.i32_const(1)),
          c.setLocal(
            "ndiv2",
            c.i32_shr_u(
              c.getLocal("n"),
              c.i32_const(1)
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_ge_u(
                c.getLocal("i"),
                c.getLocal("ndiv2")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.i32_sub(
                    c.getLocal("n"),
                    c.getLocal("i")
                  ),
                  c.i32_const(n8g)
                )
              )
            ),
            c.if(
              c.getLocal("reverse"),
              c.if(
                c.call(fPrefix + "_isOne", c.getLocal("mulFactor")),
                [
                  ...c.call(gPrefix + "_copy", c.getLocal("idx1"), T),
                  ...c.call(gPrefix + "_copy", c.getLocal("idx2"), c.getLocal("idx1")),
                  ...c.call(gPrefix + "_copy", T, c.getLocal("idx2"))
                ],
                [
                  ...c.call(gPrefix + "_copy", c.getLocal("idx1"), T),
                  ...c.call(opGtimesF, c.getLocal("idx2"), c.getLocal("mulFactor"), c.getLocal("idx1")),
                  ...c.call(opGtimesF, T, c.getLocal("mulFactor"), c.getLocal("idx2"))
                ]
              ),
              c.if(
                c.call(fPrefix + "_isOne", c.getLocal("mulFactor")),
                [
                  // Do nothing (It should not be here)
                ],
                [
                  ...c.call(opGtimesF, c.getLocal("idx1"), c.getLocal("mulFactor"), c.getLocal("idx1")),
                  ...c.call(opGtimesF, c.getLocal("idx2"), c.getLocal("mulFactor"), c.getLocal("idx2"))
                ]
              )
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          )),
          c.if(
            c.call(fPrefix + "_isOne", c.getLocal("mulFactor")),
            [
              // Do nothing (It should not be here)
            ],
            [
              ...c.call(opGtimesF, c.getLocal("px"), c.getLocal("mulFactor"), c.getLocal("px")),
              ...c.setLocal(
                "idx2",
                c.i32_add(
                  c.getLocal("px"),
                  c.i32_mul(
                    c.getLocal("ndiv2"),
                    c.i32_const(n8g)
                  )
                )
              ),
              ...c.call(opGtimesF, c.getLocal("idx2"), c.getLocal("mulFactor"), c.getLocal("idx2"))
            ]
          )
        );
      }
      function buildReversePermutation() {
        const f = module3.addFunction(prefix + "__reversePermutation");
        f.addParam("px", "i32");
        f.addParam("bits", "i32");
        f.addLocal("n", "i32");
        f.addLocal("i", "i32");
        f.addLocal("ri", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        const c = f.getCodeBuilder();
        const T = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal("n", c.i32_shl(c.i32_const(1), c.getLocal("bits"))),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal("ri", c.call(prefix + "__rev", c.getLocal("i"), c.getLocal("bits"))),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.getLocal("ri"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.if(
              c.i32_lt_u(
                c.getLocal("i"),
                c.getLocal("ri")
              ),
              [
                ...c.call(gPrefix + "_copy", c.getLocal("idx1"), T),
                ...c.call(gPrefix + "_copy", c.getLocal("idx2"), c.getLocal("idx1")),
                ...c.call(gPrefix + "_copy", T, c.getLocal("idx2"))
              ]
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildRev() {
        const f = module3.addFunction(prefix + "__rev");
        f.addParam("x", "i32");
        f.addParam("bits", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.i32_rotl(
            c.i32_add(
              c.i32_add(
                c.i32_shl(
                  c.i32_load8_u(
                    c.i32_and(
                      c.getLocal("x"),
                      c.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c.i32_const(24)
                ),
                c.i32_shl(
                  c.i32_load8_u(
                    c.i32_and(
                      c.i32_shr_u(
                        c.getLocal("x"),
                        c.i32_const(8)
                      ),
                      c.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c.i32_const(16)
                )
              ),
              c.i32_add(
                c.i32_shl(
                  c.i32_load8_u(
                    c.i32_and(
                      c.i32_shr_u(
                        c.getLocal("x"),
                        c.i32_const(16)
                      ),
                      c.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c.i32_const(8)
                ),
                c.i32_load8_u(
                  c.i32_and(
                    c.i32_shr_u(
                      c.getLocal("x"),
                      c.i32_const(24)
                    ),
                    c.i32_const(255)
                  ),
                  REVTABLE,
                  0
                )
              )
            ),
            c.getLocal("bits")
          )
        );
      }
      function buildFFTJoin() {
        const f = module3.addFunction(prefix + "_fftJoin");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const T = c.i32_const(module3.alloc(n8g));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              T
            ),
            c.call(
              gPrefix + "_copy",
              c.getLocal("idx1"),
              U
            ),
            c.call(
              gPrefix + "_add",
              U,
              T,
              c.getLocal("idx1")
            ),
            c.call(
              gPrefix + "_sub",
              U,
              T,
              c.getLocal("idx2")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTJoinExt() {
        const f = module3.addFunction(prefix + "_fftJoinExt");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addParam("totalBits", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("pShiftToM", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal(
            "pShiftToM",
            c.i32_add(
              c.i32_const(SHIFT_TO_M),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              gPrefix + "_add",
              c.getLocal("idx1"),
              c.getLocal("idx2"),
              U
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              c.getLocal("pShiftToM"),
              c.getLocal("idx2")
            ),
            c.call(
              gPrefix + "_add",
              c.getLocal("idx1"),
              c.getLocal("idx2"),
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              c.getLocal("idx2")
            ),
            c.call(
              gPrefix + "_copy",
              U,
              c.getLocal("idx1")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTJoinExtInv() {
        const f = module3.addFunction(prefix + "_fftJoinExtInv");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addParam("totalBits", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("pShiftToM", "i32");
        f.addLocal("pSConst", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal(
            "pShiftToM",
            c.i32_add(
              c.i32_const(SHIFT_TO_M),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.setLocal(
            "pSConst",
            c.i32_add(
              c.i32_const(SCONST),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              U
            ),
            c.call(
              gPrefix + "_sub",
              c.getLocal("idx1"),
              U,
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              c.getLocal("pSConst"),
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("pShiftToM"),
              c.getLocal("idx1")
            ),
            c.call(
              gPrefix + "_sub",
              U,
              c.getLocal("idx1"),
              c.getLocal("idx1")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("pSConst"),
              c.getLocal("idx1")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildPrepareLagrangeEvaluation() {
        const f = module3.addFunction(prefix + "_prepareLagrangeEvaluation");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addParam("totalBits", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("pShiftToM", "i32");
        f.addLocal("pSConst", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal(
            "pShiftToM",
            c.i32_add(
              c.i32_const(SHIFT_TO_M),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.setLocal(
            "pSConst",
            c.i32_add(
              c.i32_const(SCONST),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("pShiftToM"),
              U
            ),
            c.call(
              gPrefix + "_sub",
              c.getLocal("idx2"),
              U,
              U
            ),
            c.call(
              gPrefix + "_sub",
              c.getLocal("idx1"),
              c.getLocal("idx2"),
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              U,
              c.getLocal("pSConst"),
              c.getLocal("idx1")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              c.getLocal("idx2")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTMix() {
        const f = module3.addFunction(prefix + "_fftMix");
        f.addParam("pBuff", "i32");
        f.addParam("n", "i32");
        f.addParam("exp", "i32");
        f.addLocal("nGroups", "i32");
        f.addLocal("nPerGroup", "i32");
        f.addLocal("nPerGroupDiv2", "i32");
        f.addLocal("pairOffset", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("pwm", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const T = c.i32_const(module3.alloc(n8g));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal("nPerGroup", c.i32_shl(c.i32_const(1), c.getLocal("exp"))),
          c.setLocal("nPerGroupDiv2", c.i32_shr_u(c.getLocal("nPerGroup"), c.i32_const(1))),
          c.setLocal("nGroups", c.i32_shr_u(c.getLocal("n"), c.getLocal("exp"))),
          c.setLocal("pairOffset", c.i32_mul(c.getLocal("nPerGroupDiv2"), c.i32_const(n8g))),
          c.setLocal(
            "pwm",
            c.i32_add(
              c.i32_const(ROOTs),
              c.i32_mul(
                c.getLocal("exp"),
                c.i32_const(n8f)
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("nGroups")
              )
            ),
            c.call(fPrefix + "_one", W),
            c.setLocal("j", c.i32_const(0)),
            c.block(c.loop(
              c.br_if(
                1,
                c.i32_eq(
                  c.getLocal("j"),
                  c.getLocal("nPerGroupDiv2")
                )
              ),
              c.setLocal(
                "idx1",
                c.i32_add(
                  c.getLocal("pBuff"),
                  c.i32_mul(
                    c.i32_add(
                      c.i32_mul(
                        c.getLocal("i"),
                        c.getLocal("nPerGroup")
                      ),
                      c.getLocal("j")
                    ),
                    c.i32_const(n8g)
                  )
                )
              ),
              c.setLocal(
                "idx2",
                c.i32_add(
                  c.getLocal("idx1"),
                  c.getLocal("pairOffset")
                )
              ),
              c.call(
                opGtimesF,
                c.getLocal("idx2"),
                W,
                T
              ),
              c.call(
                gPrefix + "_copy",
                c.getLocal("idx1"),
                U
              ),
              c.call(
                gPrefix + "_add",
                U,
                T,
                c.getLocal("idx1")
              ),
              c.call(
                gPrefix + "_sub",
                U,
                T,
                c.getLocal("idx2")
              ),
              c.call(
                fPrefix + "_mul",
                W,
                c.getLocal("pwm"),
                W
              ),
              c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
              c.br(0)
            )),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTFinal() {
        const f = module3.addFunction(prefix + "_fftFinal");
        f.addParam("pBuff", "i32");
        f.addParam("n", "i32");
        f.addParam("factor", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("ndiv2", "i32");
        const c = f.getCodeBuilder();
        const T = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal("ndiv2", c.i32_shr_u(c.getLocal("n"), c.i32_const(1))),
          c.if(
            c.i32_and(
              c.getLocal("n"),
              c.i32_const(1)
            ),
            c.call(
              opGtimesF,
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.getLocal("ndiv2"),
                  c.i32_const(n8g)
                )
              ),
              c.getLocal("factor"),
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.getLocal("ndiv2"),
                  c.i32_const(n8g)
                )
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_ge_u(
                c.getLocal("i"),
                c.getLocal("ndiv2")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.i32_sub(
                    c.i32_sub(
                      c.getLocal("n"),
                      c.i32_const(1)
                    ),
                    c.getLocal("i")
                  ),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              c.getLocal("factor"),
              T
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("factor"),
              c.getLocal("idx2")
            ),
            c.call(
              gPrefix + "_copy",
              T,
              c.getLocal("idx1")
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      buildRev();
      buildReversePermutation();
      buildFinalInverse();
      buildRawFFT();
      buildLog2();
      buildFFT5();
      buildIFFT();
      buildFFTJoin();
      buildFFTJoinExt();
      buildFFTJoinExtInv();
      buildFFTMix();
      buildFFTFinal();
      buildPrepareLagrangeEvaluation();
      module3.exportFunction(prefix + "_fft");
      module3.exportFunction(prefix + "_ifft");
      module3.exportFunction(prefix + "_rawfft");
      module3.exportFunction(prefix + "_fftJoin");
      module3.exportFunction(prefix + "_fftJoinExt");
      module3.exportFunction(prefix + "_fftJoinExtInv");
      module3.exportFunction(prefix + "_fftMix");
      module3.exportFunction(prefix + "_fftFinal");
      module3.exportFunction(prefix + "_prepareLagrangeEvaluation");
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_pol.js
var require_build_pol2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_pol.js"(exports, module2) {
    "use strict";
    module2.exports = function buildPol(module3, prefix, prefixField) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("px", "i32");
        f.addParam("n", "i32");
        f.addLocal("lastp", "i32");
        f.addLocal("p", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal("p", c.getLocal("px")),
          c.setLocal(
            "lastp",
            c.i32_add(
              c.getLocal("px"),
              c.i32_mul(
                c.getLocal("n"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("p"),
                c.getLocal("lastp")
              )
            ),
            c.call(prefixField + "_zero", c.getLocal("p")),
            c.setLocal("p", c.i32_add(c.getLocal("p"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      function buildConstructLC() {
        const f = module3.addFunction(prefix + "_constructLC");
        f.addParam("ppolynomials", "i32");
        f.addParam("psignals", "i32");
        f.addParam("nSignals", "i32");
        f.addParam("pres", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("pp", "i32");
        f.addLocal("ps", "i32");
        f.addLocal("pd", "i32");
        f.addLocal("ncoefs", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("i", c.i32_const(0)),
          c.setLocal("pp", c.getLocal("ppolynomials")),
          c.setLocal("ps", c.getLocal("psignals")),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("nSignals")
              )
            ),
            c.setLocal("ncoefs", c.i32_load(c.getLocal("pp"))),
            c.setLocal("pp", c.i32_add(c.getLocal("pp"), c.i32_const(4))),
            c.setLocal("j", c.i32_const(0)),
            c.block(c.loop(
              c.br_if(
                1,
                c.i32_eq(
                  c.getLocal("j"),
                  c.getLocal("ncoefs")
                )
              ),
              c.setLocal(
                "pd",
                c.i32_add(
                  c.getLocal("pres"),
                  c.i32_mul(
                    c.i32_load(c.getLocal("pp")),
                    c.i32_const(n8)
                  )
                )
              ),
              c.setLocal("pp", c.i32_add(c.getLocal("pp"), c.i32_const(4))),
              c.call(
                prefixField + "_mul",
                c.getLocal("ps"),
                c.getLocal("pp"),
                aux
              ),
              c.call(
                prefixField + "_add",
                aux,
                c.getLocal("pd"),
                c.getLocal("pd")
              ),
              c.setLocal("pp", c.i32_add(c.getLocal("pp"), c.i32_const(n8))),
              c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
              c.br(0)
            )),
            c.setLocal("ps", c.i32_add(c.getLocal("ps"), c.i32_const(n8))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      buildZero();
      buildConstructLC();
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_constructLC");
      return prefix;
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_qap.js
var require_build_qap2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_qap.js"(exports, module2) {
    "use strict";
    module2.exports = function buildQAP(module3, prefix, prefixField) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      function buildBuildABC() {
        const f = module3.addFunction(prefix + "_buildABC");
        f.addParam("pCoefs", "i32");
        f.addParam("nCoefs", "i32");
        f.addParam("pWitness", "i32");
        f.addParam("pA", "i32");
        f.addParam("pB", "i32");
        f.addParam("pC", "i32");
        f.addParam("offsetOut", "i32");
        f.addParam("nOut", "i32");
        f.addParam("offsetWitness", "i32");
        f.addParam("nWitness", "i32");
        f.addLocal("it", "i32");
        f.addLocal("ita", "i32");
        f.addLocal("itb", "i32");
        f.addLocal("last", "i32");
        f.addLocal("m", "i32");
        f.addLocal("c", "i32");
        f.addLocal("s", "i32");
        f.addLocal("pOut", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8));
        f.addCode(
          // Set output a and b to 0
          c.setLocal("ita", c.getLocal("pA")),
          c.setLocal("itb", c.getLocal("pB")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pA"),
              c.i32_mul(
                c.getLocal("nOut"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(prefixField + "_zero", c.getLocal("ita")),
            c.call(prefixField + "_zero", c.getLocal("itb")),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.br(0)
          )),
          c.setLocal("it", c.getLocal("pCoefs")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pCoefs"),
              c.i32_mul(
                c.getLocal("nCoefs"),
                c.i32_const(n8 + 12)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("it"),
                c.getLocal("last")
              )
            ),
            c.setLocal(
              "s",
              c.i32_load(c.getLocal("it"), 8)
            ),
            c.if(
              c.i32_or(
                c.i32_lt_u(
                  c.getLocal("s"),
                  c.getLocal("offsetWitness")
                ),
                c.i32_ge_u(
                  c.getLocal("s"),
                  c.i32_add(
                    c.getLocal("offsetWitness"),
                    c.getLocal("nWitness")
                  )
                )
              ),
              [
                ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
                ...c.br(1)
              ]
            ),
            c.setLocal(
              "m",
              c.i32_load(c.getLocal("it"))
            ),
            c.if(
              c.i32_eq(c.getLocal("m"), c.i32_const(0)),
              c.setLocal("pOut", c.getLocal("pA")),
              c.if(
                c.i32_eq(c.getLocal("m"), c.i32_const(1)),
                c.setLocal("pOut", c.getLocal("pB")),
                [
                  ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
                  ...c.br(1)
                ]
              )
            ),
            c.setLocal(
              "c",
              c.i32_load(c.getLocal("it"), 4)
            ),
            c.if(
              c.i32_or(
                c.i32_lt_u(
                  c.getLocal("c"),
                  c.getLocal("offsetOut")
                ),
                c.i32_ge_u(
                  c.getLocal("c"),
                  c.i32_add(
                    c.getLocal("offsetOut"),
                    c.getLocal("nOut")
                  )
                )
              ),
              [
                ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
                ...c.br(1)
              ]
            ),
            c.setLocal(
              "pOut",
              c.i32_add(
                c.getLocal("pOut"),
                c.i32_mul(
                  c.i32_sub(
                    c.getLocal("c"),
                    c.getLocal("offsetOut")
                  ),
                  c.i32_const(n8)
                )
              )
            ),
            c.call(
              prefixField + "_mul",
              c.i32_add(
                c.getLocal("pWitness"),
                c.i32_mul(
                  c.i32_sub(c.getLocal("s"), c.getLocal("offsetWitness")),
                  c.i32_const(n8)
                )
              ),
              c.i32_add(c.getLocal("it"), c.i32_const(12)),
              aux
            ),
            c.call(
              prefixField + "_add",
              c.getLocal("pOut"),
              aux,
              c.getLocal("pOut")
            ),
            c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
            c.br(0)
          )),
          c.setLocal("ita", c.getLocal("pA")),
          c.setLocal("itb", c.getLocal("pB")),
          c.setLocal("it", c.getLocal("pC")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pA"),
              c.i32_mul(
                c.getLocal("nOut"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(
              prefixField + "_mul",
              c.getLocal("ita"),
              c.getLocal("itb"),
              c.getLocal("it")
            ),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      function buildJoinABC() {
        const f = module3.addFunction(prefix + "_joinABC");
        f.addParam("pA", "i32");
        f.addParam("pB", "i32");
        f.addParam("pC", "i32");
        f.addParam("n", "i32");
        f.addParam("pP", "i32");
        f.addLocal("ita", "i32");
        f.addLocal("itb", "i32");
        f.addLocal("itc", "i32");
        f.addLocal("itp", "i32");
        f.addLocal("last", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("ita", c.getLocal("pA")),
          c.setLocal("itb", c.getLocal("pB")),
          c.setLocal("itc", c.getLocal("pC")),
          c.setLocal("itp", c.getLocal("pP")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pA"),
              c.i32_mul(
                c.getLocal("n"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(
              prefixField + "_mul",
              c.getLocal("ita"),
              c.getLocal("itb"),
              aux
            ),
            c.call(
              prefixField + "_sub",
              aux,
              c.getLocal("itc"),
              c.getLocal("itp")
            ),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.setLocal("itc", c.i32_add(c.getLocal("itc"), c.i32_const(n8))),
            c.setLocal("itp", c.i32_add(c.getLocal("itp"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      function buildBatchAdd() {
        const f = module3.addFunction(prefix + "_batchAdd");
        f.addParam("pa", "i32");
        f.addParam("pb", "i32");
        f.addParam("n", "i32");
        f.addParam("pr", "i32");
        f.addLocal("ita", "i32");
        f.addLocal("itb", "i32");
        f.addLocal("itr", "i32");
        f.addLocal("last", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal("ita", c.getLocal("pa")),
          c.setLocal("itb", c.getLocal("pb")),
          c.setLocal("itr", c.getLocal("pr")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pa"),
              c.i32_mul(
                c.getLocal("n"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(
              prefixField + "_add",
              c.getLocal("ita"),
              c.getLocal("itb"),
              c.getLocal("itr")
            ),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.setLocal("itr", c.i32_add(c.getLocal("itr"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      buildBuildABC();
      buildJoinABC();
      buildBatchAdd();
      module3.exportFunction(prefix + "_buildABC");
      module3.exportFunction(prefix + "_joinABC");
      module3.exportFunction(prefix + "_batchAdd");
      return prefix;
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/build_applykey.js
var require_build_applykey2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/build_applykey.js"(exports, module2) {
    "use strict";
    module2.exports = function buildApplyKey(module3, fnName, gPrefix, frPrefix, sizeGIn, sizeGOut, sizeF, opGtimesF) {
      const f = module3.addFunction(fnName);
      f.addParam("pIn", "i32");
      f.addParam("n", "i32");
      f.addParam("pFirst", "i32");
      f.addParam("pInc", "i32");
      f.addParam("pOut", "i32");
      f.addLocal("pOldFree", "i32");
      f.addLocal("i", "i32");
      f.addLocal("pFrom", "i32");
      f.addLocal("pTo", "i32");
      const c = f.getCodeBuilder();
      const t = c.i32_const(module3.alloc(sizeF));
      f.addCode(
        c.setLocal("pFrom", c.getLocal("pIn")),
        c.setLocal("pTo", c.getLocal("pOut"))
      );
      f.addCode(
        c.call(
          frPrefix + "_copy",
          c.getLocal("pFirst"),
          t
        )
      );
      f.addCode(
        c.setLocal("i", c.i32_const(0)),
        c.block(c.loop(
          c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
          c.call(
            opGtimesF,
            c.getLocal("pFrom"),
            t,
            c.getLocal("pTo")
          ),
          c.setLocal("pFrom", c.i32_add(c.getLocal("pFrom"), c.i32_const(sizeGIn))),
          c.setLocal("pTo", c.i32_add(c.getLocal("pTo"), c.i32_const(sizeGOut))),
          // t = t* inc
          c.call(
            frPrefix + "_mul",
            t,
            c.getLocal("pInc"),
            t
          ),
          c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        ))
      );
      module3.exportFunction(fnName);
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/bn128/build_bn128.js
var require_build_bn1282 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/bn128/build_bn128.js"(exports, module2) {
    "use strict";
    var utils2 = require_utils2();
    var buildF1m = require_build_f1m2();
    var buildF1 = require_build_f12();
    var buildF2m = require_build_f2m2();
    var buildF3m = require_build_f3m2();
    var buildCurve = require_build_curve_jacobian_a02();
    var buildFFT4 = require_build_fft2();
    var buildPol = require_build_pol2();
    var buildQAP = require_build_qap2();
    var buildApplyKey = require_build_applykey2();
    var { bitLength: bitLength5, modInv, isOdd: isOdd4, isNegative: isNegative5 } = require_bigint2();
    module2.exports = function buildBN128(module3, _prefix) {
      const prefix = _prefix || "bn128";
      if (module3.modules[prefix])
        return prefix;
      const q = 21888242871839275222246405745257275088696311157297823662689037894645226208583n;
      const r = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;
      const n64 = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n8 = n64 * 8;
      const frsize = n8;
      const f1size = n8;
      const f2size = f1size * 2;
      const ftsize = f1size * 12;
      const pr = module3.alloc(utils2.bigInt2BytesLE(r, frsize));
      const f1mPrefix = buildF1m(module3, q, "f1m");
      buildF1(module3, r, "fr", "frm");
      const pG1b = module3.alloc(utils2.bigInt2BytesLE(toMontgomery(3n), f1size));
      const g1mPrefix = buildCurve(module3, "g1m", "f1m", pG1b);
      buildFFT4(module3, "frm", "frm", "frm", "frm_mul");
      buildPol(module3, "pol", "frm");
      buildQAP(module3, "qap", "frm");
      const f2mPrefix = buildF2m(module3, "f1m_neg", "f2m", "f1m");
      const pG2b = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
      ]);
      const g2mPrefix = buildCurve(module3, "g2m", "f2m", pG2b);
      function buildGTimesFr(fnName, opMul) {
        const f = module3.addFunction(fnName);
        f.addParam("pG", "i32");
        f.addParam("pFr", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call("frm_fromMontgomery", c.getLocal("pFr"), AUX),
          c.call(
            opMul,
            c.getLocal("pG"),
            AUX,
            c.i32_const(n8),
            c.getLocal("pr")
          )
        );
        module3.exportFunction(fnName);
      }
      buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
      buildFFT4(module3, "g1m", "g1m", "frm", "g1m_timesFr");
      buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
      buildFFT4(module3, "g2m", "g2m", "frm", "g2m_timesFr");
      buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
      buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
      buildApplyKey(module3, "frm_batchApplyKey", "fmr", "frm", n8, n8, n8, "frm_mul");
      buildApplyKey(module3, "g1m_batchApplyKey", "g1m", "frm", n8 * 3, n8 * 3, n8, "g1m_timesFr");
      buildApplyKey(module3, "g1m_batchApplyKeyMixed", "g1m", "frm", n8 * 2, n8 * 3, n8, "g1m_timesFrAffine");
      buildApplyKey(module3, "g2m_batchApplyKey", "g2m", "frm", n8 * 2 * 3, n8 * 3 * 2, n8, "g2m_timesFr");
      buildApplyKey(module3, "g2m_batchApplyKeyMixed", "g2m", "frm", n8 * 2 * 2, n8 * 3 * 2, n8, "g2m_timesFrAffine");
      function toMontgomery(a) {
        return BigInt(a) * (1n << BigInt(f1size * 8)) % q;
      }
      const G1gen = [
        1n,
        2n,
        1n
      ];
      const pG1gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
        ]
      );
      const G1zero = [
        0n,
        1n,
        0n
      ];
      const pG1zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
        ]
      );
      const G2gen = [
        [
          10857046999023057135944570762232829481370756359578518086990519993285655852781n,
          11559732032986387107991004021392285783925812861821192530917403151452391805634n
        ],
        [
          8495653923123431417604973247489272438418190587263600148770280649306958101930n,
          4082367875863433681332203403145435568316851327593401208105741076214120093531n
        ],
        [
          1n,
          0n
        ]
      ];
      const pG2gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
        ]
      );
      const G2zero = [
        [
          0n,
          0n
        ],
        [
          1n,
          0n
        ],
        [
          0n,
          0n
        ]
      ];
      const pG2zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
        ]
      );
      const pOneT = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size)
      ]);
      const pNonResidueF6 = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(9), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(1), f1size)
      ]);
      const pTwoInv = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(modInv(2n, q)), f1size),
        ...utils2.bigInt2BytesLE(0n, f1size)
      ]);
      const pAltBn128Twist = pNonResidueF6;
      const pTwistCoefB = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
      ]);
      function build_mulNR6() {
        const f = module3.addFunction(prefix + "_mulNR6");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(
            f2mPrefix + "_mul",
            c.i32_const(pNonResidueF6),
            c.getLocal("x"),
            c.getLocal("pr")
          )
        );
      }
      build_mulNR6();
      const f6mPrefix = buildF3m(module3, prefix + "_mulNR6", "f6m", "f2m");
      function build_mulNR12() {
        const f = module3.addFunction(prefix + "_mulNR12");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(
            f2mPrefix + "_mul",
            c.i32_const(pNonResidueF6),
            c.i32_add(c.getLocal("x"), c.i32_const(n8 * 4)),
            c.getLocal("pr")
          ),
          c.call(
            f2mPrefix + "_copy",
            c.getLocal("x"),
            c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))
          ),
          c.call(
            f2mPrefix + "_copy",
            c.i32_add(c.getLocal("x"), c.i32_const(n8 * 2)),
            c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 4))
          )
        );
      }
      build_mulNR12();
      const ftmPrefix = buildF2m(module3, prefix + "_mulNR12", "ftm", f6mPrefix);
      const ateLoopCount = 29793968203157093288n;
      const ateLoopBitBytes = bits4(ateLoopCount);
      const pAteLoopBitBytes = module3.alloc(ateLoopBitBytes);
      const isLoopNegative = false;
      const ateCoefSize = 3 * f2size;
      const ateNDblCoefs = ateLoopBitBytes.length - 1;
      const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) => acc + (b != 0 ? 1 : 0), 0);
      const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
      const prePSize = 3 * 2 * n8;
      const preQSize = 3 * n8 * 2 + ateNCoefs * ateCoefSize;
      const finalExpIsNegative = false;
      module3.modules[prefix] = {
        n64,
        pG1gen,
        pG1zero,
        pG1b,
        pG2gen,
        pG2zero,
        pG2b,
        pq: module3.modules["f1m"].pq,
        pr,
        pOneT,
        prePSize,
        preQSize,
        r: r.toString(),
        q: q.toString()
      };
      const finalExpZ = 4965661367192848881n;
      function naf4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            const z = 2 - Number(E % 4n);
            res.push(z);
            E = E - BigInt(z);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function bits4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            res.push(1);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function buildPrepareG1() {
        const f = module3.addFunction(prefix + "_prepareG1");
        f.addParam("pP", "i32");
        f.addParam("ppreP", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(g1mPrefix + "_normalize", c.getLocal("pP"), c.getLocal("ppreP"))
          // TODO Remove if already in affine
        );
      }
      function buildPrepAddStep() {
        const f = module3.addFunction(prefix + "_prepAddStep");
        f.addParam("pQ", "i32");
        f.addParam("pR", "i32");
        f.addParam("pCoef", "i32");
        const c = f.getCodeBuilder();
        const X2 = c.getLocal("pQ");
        const Y2 = c.i32_add(c.getLocal("pQ"), c.i32_const(f2size));
        const X1 = c.getLocal("pR");
        const Y1 = c.i32_add(c.getLocal("pR"), c.i32_const(f2size));
        const Z1 = c.i32_add(c.getLocal("pR"), c.i32_const(2 * f2size));
        const ELL_0 = c.getLocal("pCoef");
        const ELL_VW = c.i32_add(c.getLocal("pCoef"), c.i32_const(f2size));
        const ELL_VV = c.i32_add(c.getLocal("pCoef"), c.i32_const(2 * f2size));
        const D = ELL_VW;
        const E = c.i32_const(module3.alloc(f2size));
        const F = c.i32_const(module3.alloc(f2size));
        const G = c.i32_const(module3.alloc(f2size));
        const H = c.i32_const(module3.alloc(f2size));
        const I = c.i32_const(module3.alloc(f2size));
        const J = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // D = X1 - X2*Z1
          c.call(f2mPrefix + "_mul", X2, Z1, D),
          c.call(f2mPrefix + "_sub", X1, D, D),
          // E = Y1 - Y2*Z1
          c.call(f2mPrefix + "_mul", Y2, Z1, E),
          c.call(f2mPrefix + "_sub", Y1, E, E),
          // F = D^2
          c.call(f2mPrefix + "_square", D, F),
          // G = E^2
          c.call(f2mPrefix + "_square", E, G),
          // H = D*F
          c.call(f2mPrefix + "_mul", D, F, H),
          // I = X1 * F
          c.call(f2mPrefix + "_mul", X1, F, I),
          // J = H + Z1*G - (I+I)
          c.call(f2mPrefix + "_add", I, I, AUX),
          c.call(f2mPrefix + "_mul", Z1, G, J),
          c.call(f2mPrefix + "_add", H, J, J),
          c.call(f2mPrefix + "_sub", J, AUX, J),
          // X3 (X1) = D*J
          c.call(f2mPrefix + "_mul", D, J, X1),
          // Y3 (Y1) = E*(I-J)-(H*Y1)
          c.call(f2mPrefix + "_mul", H, Y1, Y1),
          c.call(f2mPrefix + "_sub", I, J, AUX),
          c.call(f2mPrefix + "_mul", E, AUX, AUX),
          c.call(f2mPrefix + "_sub", AUX, Y1, Y1),
          // Z3 (Z1) = Z1*H
          c.call(f2mPrefix + "_mul", Z1, H, Z1),
          // ell_0 = xi * (E * X2 - D * Y2)
          c.call(f2mPrefix + "_mul", D, Y2, AUX),
          c.call(f2mPrefix + "_mul", E, X2, ELL_0),
          c.call(f2mPrefix + "_sub", ELL_0, AUX, ELL_0),
          c.call(f2mPrefix + "_mul", ELL_0, c.i32_const(pAltBn128Twist), ELL_0),
          // ell_VV = - E (later: * xP)
          c.call(f2mPrefix + "_neg", E, ELL_VV)
          // ell_VW = D (later: * yP    )
          // Already assigned
        );
      }
      function buildPrepDoubleStep() {
        const f = module3.addFunction(prefix + "_prepDblStep");
        f.addParam("pR", "i32");
        f.addParam("pCoef", "i32");
        const c = f.getCodeBuilder();
        const X1 = c.getLocal("pR");
        const Y1 = c.i32_add(c.getLocal("pR"), c.i32_const(f2size));
        const Z1 = c.i32_add(c.getLocal("pR"), c.i32_const(2 * f2size));
        const ELL_0 = c.getLocal("pCoef");
        const ELL_VW = c.i32_add(c.getLocal("pCoef"), c.i32_const(f2size));
        const ELL_VV = c.i32_add(c.getLocal("pCoef"), c.i32_const(2 * f2size));
        const A = c.i32_const(module3.alloc(f2size));
        const B = c.i32_const(module3.alloc(f2size));
        const C = c.i32_const(module3.alloc(f2size));
        const D = c.i32_const(module3.alloc(f2size));
        const E = c.i32_const(module3.alloc(f2size));
        const F = c.i32_const(module3.alloc(f2size));
        const G = c.i32_const(module3.alloc(f2size));
        const H = c.i32_const(module3.alloc(f2size));
        const I = c.i32_const(module3.alloc(f2size));
        const J = c.i32_const(module3.alloc(f2size));
        const E2 = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // A = X1 * Y1 / 2
          c.call(f2mPrefix + "_mul", Y1, c.i32_const(pTwoInv), A),
          c.call(f2mPrefix + "_mul", X1, A, A),
          // B = Y1^2
          c.call(f2mPrefix + "_square", Y1, B),
          // C = Z1^2
          c.call(f2mPrefix + "_square", Z1, C),
          // D = 3 * C
          c.call(f2mPrefix + "_add", C, C, D),
          c.call(f2mPrefix + "_add", D, C, D),
          // E = twist_b * D
          c.call(f2mPrefix + "_mul", c.i32_const(pTwistCoefB), D, E),
          // F = 3 * E
          c.call(f2mPrefix + "_add", E, E, F),
          c.call(f2mPrefix + "_add", E, F, F),
          // G = (B+F)/2
          c.call(f2mPrefix + "_add", B, F, G),
          c.call(f2mPrefix + "_mul", G, c.i32_const(pTwoInv), G),
          // H = (Y1+Z1)^2-(B+C)
          c.call(f2mPrefix + "_add", B, C, AUX),
          c.call(f2mPrefix + "_add", Y1, Z1, H),
          c.call(f2mPrefix + "_square", H, H),
          c.call(f2mPrefix + "_sub", H, AUX, H),
          // I = E-B
          c.call(f2mPrefix + "_sub", E, B, I),
          // J = X1^2
          c.call(f2mPrefix + "_square", X1, J),
          // E_squared = E^2
          c.call(f2mPrefix + "_square", E, E2),
          // X3 (X1) = A * (B-F)
          c.call(f2mPrefix + "_sub", B, F, AUX),
          c.call(f2mPrefix + "_mul", A, AUX, X1),
          // Y3 (Y1) = G^2 - 3*E^2
          c.call(f2mPrefix + "_add", E2, E2, AUX),
          c.call(f2mPrefix + "_add", E2, AUX, AUX),
          c.call(f2mPrefix + "_square", G, Y1),
          c.call(f2mPrefix + "_sub", Y1, AUX, Y1),
          // Z3 (Z1) = B * H
          c.call(f2mPrefix + "_mul", B, H, Z1),
          // ell_0 = xi * I
          c.call(f2mPrefix + "_mul", c.i32_const(pAltBn128Twist), I, ELL_0),
          // ell_VW = - H (later: * yP)
          c.call(f2mPrefix + "_neg", H, ELL_VW),
          // ell_VV = 3*J (later: * xP)
          c.call(f2mPrefix + "_add", J, J, ELL_VV),
          c.call(f2mPrefix + "_add", J, ELL_VV, ELL_VV)
        );
      }
      function buildMulByQ() {
        const f = module3.addFunction(prefix + "_mulByQ");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(f2size));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(f2size * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(f2size));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(f2size * 2));
        const MulByQX = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery("21575463638280843010398324269430826099269044274347216827212613867836435027261"), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery("10307601595873709700152284273816112264069230130616436755625194854815875713954"), f1size)
        ]));
        const MulByQY = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery("2821565182194536844548159561693502659359617185244120367078079554186484126554"), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery("3505843767911556378687030309984248845540243509899259641013678093033130930403"), f1size)
        ]));
        f.addCode(
          // The frobeniusMap(1) in this field, is the conjugate
          c.call(f2mPrefix + "_conjugate", x, x3),
          c.call(f2mPrefix + "_mul", MulByQX, x3, x3),
          c.call(f2mPrefix + "_conjugate", y, y3),
          c.call(f2mPrefix + "_mul", MulByQY, y3, y3),
          c.call(f2mPrefix + "_conjugate", z, z3)
        );
      }
      function buildPrepareG2() {
        buildMulByQ();
        const f = module3.addFunction(prefix + "_prepareG2");
        f.addParam("pQ", "i32");
        f.addParam("ppreQ", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const QX = c.getLocal("pQ");
        const pR = module3.alloc(f2size * 3);
        const R = c.i32_const(pR);
        const RX = c.i32_const(pR);
        const RY = c.i32_const(pR + f2size);
        const RZ = c.i32_const(pR + 2 * f2size);
        const cQX = c.i32_add(c.getLocal("ppreQ"), c.i32_const(0));
        const cQY = c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size));
        const pQ1 = module3.alloc(f2size * 3);
        const Q1 = c.i32_const(pQ1);
        const pQ2 = module3.alloc(f2size * 3);
        const Q2 = c.i32_const(pQ2);
        const Q2Y = c.i32_const(pQ2 + f2size);
        f.addCode(
          c.call(g2mPrefix + "_normalize", QX, cQX),
          // TODO Remove if already in affine
          c.call(f2mPrefix + "_copy", cQX, RX),
          c.call(f2mPrefix + "_copy", cQY, RY),
          c.call(f2mPrefix + "_one", RZ)
        );
        f.addCode(
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3))),
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "_prepDblStep", R, c.getLocal("pCoef")),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(prefix + "_prepAddStep", cQX, R, c.getLocal("pCoef")),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
        f.addCode(
          c.call(prefix + "_mulByQ", cQX, Q1),
          c.call(prefix + "_mulByQ", Q1, Q2)
        );
        if (isLoopNegative) {
          f.addCode(
            c.call(f2mPrefix + "_neg", RY, RY)
          );
        }
        f.addCode(
          c.call(f2mPrefix + "_neg", Q2Y, Q2Y),
          c.call(prefix + "_prepAddStep", Q1, R, c.getLocal("pCoef")),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
          c.call(prefix + "_prepAddStep", Q2, R, c.getLocal("pCoef")),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
        );
      }
      function buildMulBy024Old() {
        const f = module3.addFunction(prefix + "__mulBy024Old");
        f.addParam("pEll0", "i32");
        f.addParam("pEllVW", "i32");
        f.addParam("pEllVV", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("pEll0");
        const x2 = c.getLocal("pEllVV");
        const x4 = c.getLocal("pEllVW");
        const z0 = c.getLocal("pR");
        const pAUX12 = module3.alloc(ftsize);
        const AUX12 = c.i32_const(pAUX12);
        const AUX12_0 = c.i32_const(pAUX12);
        const AUX12_2 = c.i32_const(pAUX12 + f2size);
        const AUX12_4 = c.i32_const(pAUX12 + f2size * 2);
        const AUX12_6 = c.i32_const(pAUX12 + f2size * 3);
        const AUX12_8 = c.i32_const(pAUX12 + f2size * 4);
        const AUX12_10 = c.i32_const(pAUX12 + f2size * 5);
        f.addCode(
          c.call(f2mPrefix + "_copy", x0, AUX12_0),
          c.call(f2mPrefix + "_zero", AUX12_2),
          c.call(f2mPrefix + "_copy", x2, AUX12_4),
          c.call(f2mPrefix + "_zero", AUX12_6),
          c.call(f2mPrefix + "_copy", x4, AUX12_8),
          c.call(f2mPrefix + "_zero", AUX12_10),
          c.call(ftmPrefix + "_mul", AUX12, z0, z0)
        );
      }
      function buildMulBy024() {
        const f = module3.addFunction(prefix + "__mulBy024");
        f.addParam("pEll0", "i32");
        f.addParam("pEllVW", "i32");
        f.addParam("pEllVV", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("pEll0");
        const x2 = c.getLocal("pEllVV");
        const x4 = c.getLocal("pEllVW");
        const z0 = c.getLocal("pR");
        const z1 = c.i32_add(c.getLocal("pR"), c.i32_const(2 * n8));
        const z2 = c.i32_add(c.getLocal("pR"), c.i32_const(4 * n8));
        const z3 = c.i32_add(c.getLocal("pR"), c.i32_const(6 * n8));
        const z4 = c.i32_add(c.getLocal("pR"), c.i32_const(8 * n8));
        const z5 = c.i32_add(c.getLocal("pR"), c.i32_const(10 * n8));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const s0 = c.i32_const(module3.alloc(f2size));
        const T3 = c.i32_const(module3.alloc(f2size));
        const T4 = c.i32_const(module3.alloc(f2size));
        const D0 = c.i32_const(module3.alloc(f2size));
        const D2 = c.i32_const(module3.alloc(f2size));
        const D4 = c.i32_const(module3.alloc(f2size));
        const S1 = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // D0 = z0 * x0;
          c.call(f2mPrefix + "_mul", z0, x0, D0),
          // D2 = z2 * x2;
          c.call(f2mPrefix + "_mul", z2, x2, D2),
          // D4 = z4 * x4;
          c.call(f2mPrefix + "_mul", z4, x4, D4),
          // t2 = z0 + z4;
          c.call(f2mPrefix + "_add", z0, z4, t2),
          // t1 = z0 + z2;
          c.call(f2mPrefix + "_add", z0, z2, t1),
          // s0 = z1 + z3 + z5;
          c.call(f2mPrefix + "_add", z1, z3, s0),
          c.call(f2mPrefix + "_add", s0, z5, s0),
          // For z.a_.a_ = z0.
          // S1 = z1 * x2;
          c.call(f2mPrefix + "_mul", z1, x2, S1),
          // T3 = S1 + D4;
          c.call(f2mPrefix + "_add", S1, D4, T3),
          // T4 = my_Fp6::non_residue * T3 + D0;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          c.call(f2mPrefix + "_add", T4, D0, z0),
          // z0 = T4;
          // For z.a_.b_ = z1
          // T3 = z5 * x4;
          c.call(f2mPrefix + "_mul", z5, x4, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T3 = T3 + D2;
          c.call(f2mPrefix + "_add", T3, D2, T3),
          // T4 = my_Fp6::non_residue * T3;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          // T3 = z1 * x0;
          c.call(f2mPrefix + "_mul", z1, x0, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = T4 + T3;
          c.call(f2mPrefix + "_add", T4, T3, z1),
          // z1 = T4;
          // For z.a_.c_ = z2
          // t0 = x0 + x2;
          c.call(f2mPrefix + "_add", x0, x2, t0),
          // T3 = t1 * t0 - D0 - D2;
          c.call(f2mPrefix + "_mul", t1, t0, T3),
          c.call(f2mPrefix + "_add", D0, D2, AUX),
          c.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = z3 * x4;
          c.call(f2mPrefix + "_mul", z3, x4, T4),
          // S1 = S1 + T4;
          c.call(f2mPrefix + "_add", S1, T4, S1),
          // For z.b_.a_ = z3 (z3 needs z2)
          // t0 = z2 + z4;
          c.call(f2mPrefix + "_add", z2, z4, t0),
          // T3 = T3 + T4;
          // z2 = T3;
          c.call(f2mPrefix + "_add", T3, T4, z2),
          // t1 = x2 + x4;
          c.call(f2mPrefix + "_add", x2, x4, t1),
          // T3 = t0 * t1 - D2 - D4;
          c.call(f2mPrefix + "_mul", t1, t0, T3),
          c.call(f2mPrefix + "_add", D2, D4, AUX),
          c.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = my_Fp6::non_residue * T3;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          // T3 = z3 * x0;
          c.call(f2mPrefix + "_mul", z3, x0, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = T4 + T3;
          c.call(f2mPrefix + "_add", T4, T3, z3),
          // z3 = T4;
          // For z.b_.b_ = z4
          // T3 = z5 * x2;
          c.call(f2mPrefix + "_mul", z5, x2, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = my_Fp6::non_residue * T3;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          // t0 = x0 + x4;
          c.call(f2mPrefix + "_add", x0, x4, t0),
          // T3 = t2 * t0 - D0 - D4;
          c.call(f2mPrefix + "_mul", t2, t0, T3),
          c.call(f2mPrefix + "_add", D0, D4, AUX),
          c.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = T4 + T3;
          c.call(f2mPrefix + "_add", T4, T3, z4),
          // z4 = T4;
          // For z.b_.c_ = z5.
          // t0 = x0 + x2 + x4;
          c.call(f2mPrefix + "_add", x0, x2, t0),
          c.call(f2mPrefix + "_add", t0, x4, t0),
          // T3 = s0 * t0 - S1;
          c.call(f2mPrefix + "_mul", s0, t0, T3),
          c.call(f2mPrefix + "_sub", T3, S1, z5)
          // z5 = T3;
        );
      }
      function buildMillerLoop() {
        const f = module3.addFunction(prefix + "_millerLoop");
        f.addParam("ppreP", "i32");
        f.addParam("ppreQ", "i32");
        f.addParam("r", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const preP_PX = c.getLocal("ppreP");
        const preP_PY = c.i32_add(c.getLocal("ppreP"), c.i32_const(f1size));
        const ELL_0 = c.getLocal("pCoef");
        const ELL_VW = c.i32_add(c.getLocal("pCoef"), c.i32_const(f2size));
        const ELL_VV = c.i32_add(c.getLocal("pCoef"), c.i32_const(2 * f2size));
        const pVW = module3.alloc(f2size);
        const VW = c.i32_const(pVW);
        const pVV = module3.alloc(f2size);
        const VV = c.i32_const(pVV);
        const F = c.getLocal("r");
        f.addCode(
          c.call(ftmPrefix + "_one", F),
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3))),
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(ftmPrefix + "_square", F, F),
            c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
            c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
            c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
                ...c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
                ...c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
        if (isLoopNegative) {
          f.addCode(
            c.call(ftmPrefix + "_inverse", F, F)
          );
        }
        f.addCode(
          c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
          c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
          c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
          c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
          c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
          c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
        );
      }
      function buildFrobeniusMap(n) {
        const F12 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [8376118865763821496583973867626364092589906065868298776909617916018768340080n, 16469823323077808223889137241176536799009286646108169935659301613961712198316n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556617n, 0n],
            [11697423496358154304825782922584725312912383441159505038794027105778954184319n, 303847389135065887422783454877609941456349188919719272345083954437860409601n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [3321304630594332808241809054958361220322477375291206261884409189760185844239n, 5722266937896532885780051958958348231143373700109372999374820235121374419868n],
            [21888242871839275222246405745257275088696311157297823662689037894645226208582n, 0n],
            [13512124006075453725662431877630910996106405091429524885779419978626457868503n, 5418419548761466998357268504080738289687024511189653727029736280683514010267n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [10190819375481120917420622822672549775783927716138318623895010788866272024264n, 21584395482704209334823622290379665147239961968378104390343953940207365798982n],
            [2203960485148121921418603742825762020974279258880205651967n, 0n],
            [18566938241244942414004596690298913868373833782006617400804628704885040364344n, 16165975933942742336466353786298926857552937457188450663314217659523851788715n]
          ]
        ];
        const F6 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [21575463638280843010398324269430826099269044274347216827212613867836435027261n, 10307601595873709700152284273816112264069230130616436755625194854815875713954n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [3772000881919853776433695186713858239009073593817195771773381919316419345261n, 2236595495967245188281701248203181795121068902605861227855261137820944008926n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [18429021223477853657660792034369865839114504446431234726392080002137598044644n, 9344045779998320333812420223237981029506012124075525679208581902008406485703n]
          ],
          [
            [1n, 0n],
            [2581911344467009335267311115468803099551665605076196740867805258568234346338n, 19937756971775647987995932169929341994314640652964949448313374472400716661030n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [5324479202449903542726783395506214481928257762400643279780343368557297135718n, 16208900380737693084919495127334387981393726419856888799917914180988844123039n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [13981852324922362344252311234282257507216387789820983642040889267519694726527n, 7629828391165209371577384193250820201684255241773809077146787135900891633097n]
          ]
        ];
        const f = module3.addFunction(prefix + "__frobeniusMap" + n);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < 6; i++) {
          const X = i == 0 ? c.getLocal("x") : c.i32_add(c.getLocal("x"), c.i32_const(i * f2size));
          const Xc0 = X;
          const Xc1 = c.i32_add(c.getLocal("x"), c.i32_const(i * f2size + f1size));
          const R = i == 0 ? c.getLocal("r") : c.i32_add(c.getLocal("r"), c.i32_const(i * f2size));
          const Rc0 = R;
          const Rc1 = c.i32_add(c.getLocal("r"), c.i32_const(i * f2size + f1size));
          const coef = mul22(F12[Math.floor(i / 3)][n % 12], F6[i % 3][n % 6]);
          const pCoef = module3.alloc([
            ...utils2.bigInt2BytesLE(toMontgomery(coef[0]), 32),
            ...utils2.bigInt2BytesLE(toMontgomery(coef[1]), 32)
          ]);
          if (n % 2 == 1) {
            f.addCode(
              c.call(f1mPrefix + "_copy", Xc0, Rc0),
              c.call(f1mPrefix + "_neg", Xc1, Rc1),
              c.call(f2mPrefix + "_mul", R, c.i32_const(pCoef), R)
            );
          } else {
            f.addCode(c.call(f2mPrefix + "_mul", X, c.i32_const(pCoef), R));
          }
        }
        function mul22(a, b) {
          const ac0 = BigInt(a[0]);
          const ac1 = BigInt(a[1]);
          const bc0 = BigInt(b[0]);
          const bc1 = BigInt(b[1]);
          const res = [
            (ac0 * bc0 - ac1 * bc1) % q,
            (ac0 * bc1 + ac1 * bc0) % q
          ];
          if (isNegative5(res[0]))
            res[0] = res[0] + q;
          return res;
        }
      }
      function buildFinalExponentiationFirstChunk() {
        const f = module3.addFunction(prefix + "__finalExponentiationFirstChunk");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const eltC0 = elt;
        const eltC1 = c.i32_add(elt, c.i32_const(n8 * 6));
        const r2 = c.getLocal("r");
        const pA = module3.alloc(ftsize);
        const A = c.i32_const(pA);
        const Ac0 = A;
        const Ac1 = c.i32_const(pA + n8 * 6);
        const B = c.i32_const(module3.alloc(ftsize));
        const C = c.i32_const(module3.alloc(ftsize));
        const D = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          // const alt_bn128_Fq12 A = alt_bn128_Fq12(elt.c0,-elt.c1);
          c.call(f6mPrefix + "_copy", eltC0, Ac0),
          c.call(f6mPrefix + "_neg", eltC1, Ac1),
          // const alt_bn128_Fq12 B = elt.inverse();
          c.call(ftmPrefix + "_inverse", elt, B),
          // const alt_bn128_Fq12 C = A * B;
          c.call(ftmPrefix + "_mul", A, B, C),
          // const alt_bn128_Fq12 D = C.Frobenius_map(2);
          c.call(prefix + "__frobeniusMap2", C, D),
          // const alt_bn128_Fq12 result = D * C;
          c.call(ftmPrefix + "_mul", C, D, r2)
        );
      }
      function buildCyclotomicSquare() {
        const f = module3.addFunction(prefix + "__cyclotomicSquare");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x4 = c.i32_add(c.getLocal("x"), c.i32_const(f2size));
        const x3 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f2size));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(3 * f2size));
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(4 * f2size));
        const x5 = c.i32_add(c.getLocal("x"), c.i32_const(5 * f2size));
        const r0 = c.getLocal("r");
        const r4 = c.i32_add(c.getLocal("r"), c.i32_const(f2size));
        const r3 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f2size));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(3 * f2size));
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(4 * f2size));
        const r5 = c.i32_add(c.getLocal("r"), c.i32_const(5 * f2size));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t3 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        const tmp = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          //    // t0 + t1*y = (z0 + z1*y)^2 = a^2
          //    tmp = z0 * z1;
          //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;
          //    t1 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x0, x1, tmp),
          c.call(f2mPrefix + "_mul", x1, c.i32_const(pNonResidueF6), t0),
          c.call(f2mPrefix + "_add", x0, t0, t0),
          c.call(f2mPrefix + "_add", x0, x1, AUX),
          c.call(f2mPrefix + "_mul", AUX, t0, t0),
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t0, AUX, t0),
          c.call(f2mPrefix + "_add", tmp, tmp, t1),
          //  // t2 + t3*y = (z2 + z3*y)^2 = b^2
          //  tmp = z2 * z3;
          //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;
          //  t3 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x2, x3, tmp),
          c.call(f2mPrefix + "_mul", x3, c.i32_const(pNonResidueF6), t2),
          c.call(f2mPrefix + "_add", x2, t2, t2),
          c.call(f2mPrefix + "_add", x2, x3, AUX),
          c.call(f2mPrefix + "_mul", AUX, t2, t2),
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t2, AUX, t2),
          c.call(f2mPrefix + "_add", tmp, tmp, t3),
          //  // t4 + t5*y = (z4 + z5*y)^2 = c^2
          //  tmp = z4 * z5;
          //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;
          //  t5 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x4, x5, tmp),
          c.call(f2mPrefix + "_mul", x5, c.i32_const(pNonResidueF6), t4),
          c.call(f2mPrefix + "_add", x4, t4, t4),
          c.call(f2mPrefix + "_add", x4, x5, AUX),
          c.call(f2mPrefix + "_mul", AUX, t4, t4),
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t4, AUX, t4),
          c.call(f2mPrefix + "_add", tmp, tmp, t5),
          // For A
          // z0 = 3 * t0 - 2 * z0
          c.call(f2mPrefix + "_sub", t0, x0, r0),
          c.call(f2mPrefix + "_add", r0, r0, r0),
          c.call(f2mPrefix + "_add", t0, r0, r0),
          // z1 = 3 * t1 + 2 * z1
          c.call(f2mPrefix + "_add", t1, x1, r1),
          c.call(f2mPrefix + "_add", r1, r1, r1),
          c.call(f2mPrefix + "_add", t1, r1, r1),
          // For B
          // z2 = 3 * (xi * t5) + 2 * z2
          c.call(f2mPrefix + "_mul", t5, c.i32_const(pAltBn128Twist), AUX),
          c.call(f2mPrefix + "_add", AUX, x2, r2),
          c.call(f2mPrefix + "_add", r2, r2, r2),
          c.call(f2mPrefix + "_add", AUX, r2, r2),
          // z3 = 3 * t4 - 2 * z3
          c.call(f2mPrefix + "_sub", t4, x3, r3),
          c.call(f2mPrefix + "_add", r3, r3, r3),
          c.call(f2mPrefix + "_add", t4, r3, r3),
          // For C
          // z4 = 3 * t2 - 2 * z4
          c.call(f2mPrefix + "_sub", t2, x4, r4),
          c.call(f2mPrefix + "_add", r4, r4, r4),
          c.call(f2mPrefix + "_add", t2, r4, r4),
          // z5 = 3 * t3 + 2 * z5
          c.call(f2mPrefix + "_add", t3, x5, r5),
          c.call(f2mPrefix + "_add", r5, r5, r5),
          c.call(f2mPrefix + "_add", t3, r5, r5)
        );
      }
      function buildCyclotomicExp(exponent, fnName) {
        const exponentNafBytes = naf4(exponent).map((b) => b == -1 ? 255 : b);
        const pExponentNafBytes = module3.alloc(exponentNafBytes);
        const f = module3.addFunction(prefix + "__cyclotomicExp_" + fnName);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("bit", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("x");
        const res = c.getLocal("r");
        const inverse = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          c.call(ftmPrefix + "_conjugate", x, inverse),
          c.call(ftmPrefix + "_one", res),
          c.if(
            c.teeLocal("bit", c.i32_load8_s(c.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
            c.if(
              c.i32_eq(
                c.getLocal("bit"),
                c.i32_const(1)
              ),
              c.call(ftmPrefix + "_mul", res, x, res),
              c.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c.setLocal("i", c.i32_const(exponentNafBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "__cyclotomicSquare", res, res),
            c.if(
              c.teeLocal("bit", c.i32_load8_s(c.getLocal("i"), pExponentNafBytes)),
              c.if(
                c.i32_eq(
                  c.getLocal("bit"),
                  c.i32_const(1)
                ),
                c.call(ftmPrefix + "_mul", res, x, res),
                c.call(ftmPrefix + "_mul", res, inverse, res)
              )
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFinalExponentiationLastChunk() {
        buildCyclotomicSquare();
        buildCyclotomicExp(finalExpZ, "w0");
        const f = module3.addFunction(prefix + "__finalExponentiationLastChunk");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const result = c.getLocal("r");
        const A = c.i32_const(module3.alloc(ftsize));
        const B = c.i32_const(module3.alloc(ftsize));
        const C = c.i32_const(module3.alloc(ftsize));
        const D = c.i32_const(module3.alloc(ftsize));
        const E = c.i32_const(module3.alloc(ftsize));
        const F = c.i32_const(module3.alloc(ftsize));
        const G = c.i32_const(module3.alloc(ftsize));
        const H = c.i32_const(module3.alloc(ftsize));
        const I = c.i32_const(module3.alloc(ftsize));
        const J = c.i32_const(module3.alloc(ftsize));
        const K = c.i32_const(module3.alloc(ftsize));
        const L = c.i32_const(module3.alloc(ftsize));
        const M = c.i32_const(module3.alloc(ftsize));
        const N = c.i32_const(module3.alloc(ftsize));
        const O = c.i32_const(module3.alloc(ftsize));
        const P = c.i32_const(module3.alloc(ftsize));
        const Q = c.i32_const(module3.alloc(ftsize));
        const R = c.i32_const(module3.alloc(ftsize));
        const S = c.i32_const(module3.alloc(ftsize));
        const T = c.i32_const(module3.alloc(ftsize));
        const U = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          // A = exp_by_neg_z(elt)  // = elt^(-z)
          c.call(prefix + "__cyclotomicExp_w0", elt, A),
          finalExpIsNegative ? [] : c.call(ftmPrefix + "_conjugate", A, A),
          // B = A^2                // = elt^(-2*z)
          c.call(prefix + "__cyclotomicSquare", A, B),
          // C = B^2                // = elt^(-4*z)
          c.call(prefix + "__cyclotomicSquare", B, C),
          // D = C * B              // = elt^(-6*z)
          c.call(ftmPrefix + "_mul", C, B, D),
          // E = exp_by_neg_z(D)    // = elt^(6*z^2)
          c.call(prefix + "__cyclotomicExp_w0", D, E),
          finalExpIsNegative ? [] : c.call(ftmPrefix + "_conjugate", E, E),
          // F = E^2                // = elt^(12*z^2)
          c.call(prefix + "__cyclotomicSquare", E, F),
          // G = epx_by_neg_z(F)    // = elt^(-12*z^3)
          c.call(prefix + "__cyclotomicExp_w0", F, G),
          finalExpIsNegative ? [] : c.call(ftmPrefix + "_conjugate", G, G),
          // H = conj(D)            // = elt^(6*z)
          c.call(ftmPrefix + "_conjugate", D, H),
          // I = conj(G)            // = elt^(12*z^3)
          c.call(ftmPrefix + "_conjugate", G, I),
          // J = I * E              // = elt^(12*z^3 + 6*z^2)
          c.call(ftmPrefix + "_mul", I, E, J),
          // K = J * H              // = elt^(12*z^3 + 6*z^2 + 6*z)
          c.call(ftmPrefix + "_mul", J, H, K),
          // L = K * B              // = elt^(12*z^3 + 6*z^2 + 4*z)
          c.call(ftmPrefix + "_mul", K, B, L),
          // M = K * E              // = elt^(12*z^3 + 12*z^2 + 6*z)
          c.call(ftmPrefix + "_mul", K, E, M),
          // N = M * elt            // = elt^(12*z^3 + 12*z^2 + 6*z + 1)
          c.call(ftmPrefix + "_mul", M, elt, N),
          // O = L.Frobenius_map(1) // = elt^(q*(12*z^3 + 6*z^2 + 4*z))
          c.call(prefix + "__frobeniusMap1", L, O),
          // P = O * N              // = elt^(q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c.call(ftmPrefix + "_mul", O, N, P),
          // Q = K.Frobenius_map(2) // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z))
          c.call(prefix + "__frobeniusMap2", K, Q),
          // R = Q * P              // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c.call(ftmPrefix + "_mul", Q, P, R),
          // S = conj(elt)          // = elt^(-1)
          c.call(ftmPrefix + "_conjugate", elt, S),
          // T = S * L              // = elt^(12*z^3 + 6*z^2 + 4*z - 1)
          c.call(ftmPrefix + "_mul", S, L, T),
          // U = T.Frobenius_map(3) // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1))
          c.call(prefix + "__frobeniusMap3", T, U),
          // V = U * R              // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1) + q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c.call(ftmPrefix + "_mul", U, R, result)
          // result = V
        );
      }
      function buildFinalExponentiation() {
        buildFinalExponentiationFirstChunk();
        buildFinalExponentiationLastChunk();
        const f = module3.addFunction(prefix + "_finalExponentiation");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const result = c.getLocal("r");
        const eltToFirstChunk = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          c.call(prefix + "__finalExponentiationFirstChunk", elt, eltToFirstChunk),
          c.call(prefix + "__finalExponentiationLastChunk", eltToFirstChunk, result)
        );
      }
      function buildFinalExponentiationOld() {
        const f = module3.addFunction(prefix + "_finalExponentiationOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const exponent = 552484233613224096312617126783173147097382103762957654188882734314196910839907541213974502761540629817009608548654680343627701153829446747810907373256841551006201639677726139946029199968412598804882391702273019083653272047566316584365559776493027495458238373902875937659943504873220554161550525926302303331747463515644711876653177129578303191095900909191624817826566688241804408081892785725967931714097716709526092261278071952560171111444072049229123565057483750161460024353346284167282452756217662335528813519139808291170539072125381230815729071544861602750936964829313608137325426383735122175229541155376346436093930287402089517426973178917569713384748081827255472576937471496195752727188261435633271238710131736096299798168852925540549342330775279877006784354801422249722573783561685179618816480037695005515426162362431072245638324744480n;
        const pExponent = module3.alloc(utils2.bigInt2BytesLE(exponent, 352));
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(ftmPrefix + "_exp", c.getLocal("x"), c.i32_const(pExponent), c.i32_const(352), c.getLocal("r"))
        );
      }
      const pPreP = module3.alloc(prePSize);
      const pPreQ = module3.alloc(preQSize);
      function buildPairingEquation(nPairings) {
        const f = module3.addFunction(prefix + "_pairingEq" + nPairings);
        for (let i = 0; i < nPairings; i++) {
          f.addParam("p_" + i, "i32");
          f.addParam("q_" + i, "i32");
        }
        f.addParam("c", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        const auxT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(ftmPrefix + "_one", resT));
        for (let i = 0; i < nPairings; i++) {
          f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p_" + i), c.i32_const(pPreP)));
          f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q_" + i), c.i32_const(pPreQ)));
          f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), auxT));
          f.addCode(c.call(ftmPrefix + "_mul", resT, auxT, resT));
        }
        f.addCode(c.call(prefix + "_finalExponentiation", resT, resT));
        f.addCode(c.call(ftmPrefix + "_eq", resT, c.getLocal("c")));
      }
      function buildPairing4() {
        const f = module3.addFunction(prefix + "_pairing");
        f.addParam("p", "i32");
        f.addParam("q", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p"), c.i32_const(pPreP)));
        f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q"), c.i32_const(pPreQ)));
        f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), resT));
        f.addCode(c.call(prefix + "_finalExponentiation", resT, c.getLocal("r")));
      }
      buildPrepAddStep();
      buildPrepDoubleStep();
      buildPrepareG1();
      buildPrepareG2();
      buildMulBy024();
      buildMulBy024Old();
      buildMillerLoop();
      for (let i = 0; i < 10; i++) {
        buildFrobeniusMap(i);
        module3.exportFunction(prefix + "__frobeniusMap" + i);
      }
      buildFinalExponentiationOld();
      buildFinalExponentiation();
      for (let i = 1; i <= 5; i++) {
        buildPairingEquation(i);
        module3.exportFunction(prefix + "_pairingEq" + i);
      }
      buildPairing4();
      module3.exportFunction(prefix + "_pairing");
      module3.exportFunction(prefix + "_prepareG1");
      module3.exportFunction(prefix + "_prepareG2");
      module3.exportFunction(prefix + "_millerLoop");
      module3.exportFunction(prefix + "_finalExponentiation");
      module3.exportFunction(prefix + "_finalExponentiationOld");
      module3.exportFunction(prefix + "__mulBy024");
      module3.exportFunction(prefix + "__mulBy024Old");
      module3.exportFunction(prefix + "__cyclotomicSquare");
      module3.exportFunction(prefix + "__cyclotomicExp_w0");
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/src/bls12381/build_bls12381.js
var require_build_bls123812 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/src/bls12381/build_bls12381.js"(exports, module2) {
    "use strict";
    var utils2 = require_utils2();
    var buildF1m = require_build_f1m2();
    var buildF1 = require_build_f12();
    var buildF2m = require_build_f2m2();
    var buildF3m = require_build_f3m2();
    var buildCurve = require_build_curve_jacobian_a02();
    var buildFFT4 = require_build_fft2();
    var buildPol = require_build_pol2();
    var buildQAP = require_build_qap2();
    var buildApplyKey = require_build_applykey2();
    var { bitLength: bitLength5, isOdd: isOdd4, isNegative: isNegative5 } = require_bigint2();
    module2.exports = function buildBLS12381(module3, _prefix) {
      const prefix = _prefix || "bls12381";
      if (module3.modules[prefix])
        return prefix;
      const q = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
      const r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;
      const n64q = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n8q = n64q * 8;
      const f1size = n8q;
      const f2size = f1size * 2;
      const ftsize = f1size * 12;
      const n64r = Math.floor((bitLength5(r - 1n) - 1) / 64) + 1;
      const n8r = n64r * 8;
      const frsize = n8r;
      const pr = module3.alloc(utils2.bigInt2BytesLE(r, frsize));
      const f1mPrefix = buildF1m(module3, q, "f1m", "intq");
      buildF1(module3, r, "fr", "frm", "intr");
      const pG1b = module3.alloc(utils2.bigInt2BytesLE(toMontgomery(4n), f1size));
      const g1mPrefix = buildCurve(module3, "g1m", "f1m", pG1b);
      buildFFT4(module3, "frm", "frm", "frm", "frm_mul");
      buildPol(module3, "pol", "frm");
      buildQAP(module3, "qap", "frm");
      const f2mPrefix = buildF2m(module3, "f1m_neg", "f2m", "f1m");
      const pG2b = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(4n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(4n), f1size)
      ]);
      const g2mPrefix = buildCurve(module3, "g2m", "f2m", pG2b);
      function buildGTimesFr(fnName, opMul) {
        const f = module3.addFunction(fnName);
        f.addParam("pG", "i32");
        f.addParam("pFr", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8r));
        f.addCode(
          c.call("frm_fromMontgomery", c.getLocal("pFr"), AUX),
          c.call(
            opMul,
            c.getLocal("pG"),
            AUX,
            c.i32_const(n8r),
            c.getLocal("pr")
          )
        );
        module3.exportFunction(fnName);
      }
      buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
      buildFFT4(module3, "g1m", "g1m", "frm", "g1m_timesFr");
      buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
      buildFFT4(module3, "g2m", "g2m", "frm", "g2m_timesFr");
      buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
      buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
      buildApplyKey(module3, "frm_batchApplyKey", "fmr", "frm", n8r, n8r, n8r, "frm_mul");
      buildApplyKey(module3, "g1m_batchApplyKey", "g1m", "frm", n8q * 3, n8q * 3, n8r, "g1m_timesFr");
      buildApplyKey(module3, "g1m_batchApplyKeyMixed", "g1m", "frm", n8q * 2, n8q * 3, n8r, "g1m_timesFrAffine");
      buildApplyKey(module3, "g2m_batchApplyKey", "g2m", "frm", n8q * 2 * 3, n8q * 3 * 2, n8r, "g2m_timesFr");
      buildApplyKey(module3, "g2m_batchApplyKeyMixed", "g2m", "frm", n8q * 2 * 2, n8q * 3 * 2, n8r, "g2m_timesFrAffine");
      function toMontgomery(a) {
        return BigInt(a) * (1n << BigInt(f1size * 8)) % q;
      }
      const G1gen = [
        3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507n,
        1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569n,
        1n
      ];
      const pG1gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
        ]
      );
      const G1zero = [
        0n,
        1n,
        0n
      ];
      const pG1zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
        ]
      );
      const G2gen = [
        [
          352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160n,
          3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758n
        ],
        [
          1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905n,
          927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582n
        ],
        [
          1n,
          0n
        ]
      ];
      const pG2gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
        ]
      );
      const G2zero = [
        [
          0n,
          0n
        ],
        [
          1n,
          0n
        ],
        [
          0n,
          0n
        ]
      ];
      const pG2zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
        ]
      );
      const pOneT = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size)
      ]);
      const pBls12381Twist = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size)
      ]);
      function build_mulNR2() {
        const f = module3.addFunction(f2mPrefix + "_mulNR");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x0c = c.i32_const(module3.alloc(f1size));
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1size));
        const r0 = c.getLocal("pr");
        const r1 = c.i32_add(c.getLocal("pr"), c.i32_const(f1size));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, x0c),
          c.call(f1mPrefix + "_sub", x0, x1, r0),
          c.call(f1mPrefix + "_add", x0c, x1, r1)
        );
      }
      build_mulNR2();
      const f6mPrefix = buildF3m(module3, f2mPrefix + "_mulNR", "f6m", "f2m");
      function build_mulNR6() {
        const f = module3.addFunction(f6mPrefix + "_mulNR");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const c0copy = c.i32_const(module3.alloc(f1size * 2));
        f.addCode(
          c.call(
            f2mPrefix + "_copy",
            c.getLocal("x"),
            c0copy
          ),
          c.call(
            f2mPrefix + "_mulNR",
            c.i32_add(c.getLocal("x"), c.i32_const(n8q * 4)),
            c.getLocal("pr")
          ),
          c.call(
            f2mPrefix + "_copy",
            c.i32_add(c.getLocal("x"), c.i32_const(n8q * 2)),
            c.i32_add(c.getLocal("pr"), c.i32_const(n8q * 4))
          ),
          c.call(
            f2mPrefix + "_copy",
            c0copy,
            c.i32_add(c.getLocal("pr"), c.i32_const(n8q * 2))
          )
        );
      }
      build_mulNR6();
      const ftmPrefix = buildF2m(module3, f6mPrefix + "_mulNR", "ftm", f6mPrefix);
      const ateLoopCount = 0xd201000000010000n;
      const ateLoopBitBytes = bits4(ateLoopCount);
      const pAteLoopBitBytes = module3.alloc(ateLoopBitBytes);
      const isLoopNegative = true;
      const ateCoefSize = 3 * f2size;
      const ateNDblCoefs = ateLoopBitBytes.length - 1;
      const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) => acc + (b != 0 ? 1 : 0), 0);
      const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
      const prePSize = 3 * 2 * n8q;
      const preQSize = 3 * n8q * 2 + ateNCoefs * ateCoefSize;
      const finalExpIsNegative = true;
      const finalExpZ = 15132376222941642752n;
      module3.modules[prefix] = {
        n64q,
        n64r,
        n8q,
        n8r,
        pG1gen,
        pG1zero,
        pG1b,
        pG2gen,
        pG2zero,
        pG2b,
        pq: module3.modules["f1m"].pq,
        pr,
        pOneT,
        r,
        q,
        prePSize,
        preQSize
      };
      function naf4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            const z = 2 - Number(E % 4n);
            res.push(z);
            E = E - BigInt(z);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function bits4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            res.push(1);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function buildPrepareG1() {
        const f = module3.addFunction(prefix + "_prepareG1");
        f.addParam("pP", "i32");
        f.addParam("ppreP", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(g1mPrefix + "_normalize", c.getLocal("pP"), c.getLocal("ppreP"))
          // TODO Remove if already in affine
        );
      }
      function buildPrepDoubleStep() {
        const f = module3.addFunction(prefix + "_prepDblStep");
        f.addParam("R", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const Rx = c.getLocal("R");
        const Ry = c.i32_add(c.getLocal("R"), c.i32_const(2 * n8q));
        const Rz = c.i32_add(c.getLocal("R"), c.i32_const(4 * n8q));
        const t0 = c.getLocal("r");
        const t3 = c.i32_add(c.getLocal("r"), c.i32_const(2 * n8q));
        const t6 = c.i32_add(c.getLocal("r"), c.i32_const(4 * n8q));
        const zsquared = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // tmp0 = r.x.square();
          c.call(f2mPrefix + "_square", Rx, t0),
          // tmp1 = r.y.square();
          c.call(f2mPrefix + "_square", Ry, t1),
          // tmp2 = tmp1.square();
          c.call(f2mPrefix + "_square", t1, t2),
          // tmp3 = (tmp1 + r.x).square() - tmp0 - tmp2;
          c.call(f2mPrefix + "_add", t1, Rx, t3),
          c.call(f2mPrefix + "_square", t3, t3),
          c.call(f2mPrefix + "_sub", t3, t0, t3),
          c.call(f2mPrefix + "_sub", t3, t2, t3),
          // tmp3 = tmp3 + tmp3;
          c.call(f2mPrefix + "_add", t3, t3, t3),
          // tmp4 = tmp0 + tmp0 + tmp0;
          c.call(f2mPrefix + "_add", t0, t0, t4),
          c.call(f2mPrefix + "_add", t4, t0, t4),
          // tmp6 = r.x + tmp4;
          c.call(f2mPrefix + "_add", Rx, t4, t6),
          // tmp5 = tmp4.square();
          c.call(f2mPrefix + "_square", t4, t5),
          // zsquared = r.z.square();
          c.call(f2mPrefix + "_square", Rz, zsquared),
          // r.x = tmp5 - tmp3 - tmp3;
          c.call(f2mPrefix + "_sub", t5, t3, Rx),
          c.call(f2mPrefix + "_sub", Rx, t3, Rx),
          // r.z = (r.z + r.y).square() - tmp1 - zsquared;
          c.call(f2mPrefix + "_add", Rz, Ry, Rz),
          c.call(f2mPrefix + "_square", Rz, Rz),
          c.call(f2mPrefix + "_sub", Rz, t1, Rz),
          c.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
          // r.y = (tmp3 - r.x) * tmp4;
          c.call(f2mPrefix + "_sub", t3, Rx, Ry),
          c.call(f2mPrefix + "_mul", Ry, t4, Ry),
          // tmp2 = tmp2 + tmp2;
          c.call(f2mPrefix + "_add", t2, t2, t2),
          // tmp2 = tmp2 + tmp2;
          c.call(f2mPrefix + "_add", t2, t2, t2),
          // tmp2 = tmp2 + tmp2;
          c.call(f2mPrefix + "_add", t2, t2, t2),
          // r.y -= tmp2;
          c.call(f2mPrefix + "_sub", Ry, t2, Ry),
          // tmp3 = tmp4 * zsquared;
          c.call(f2mPrefix + "_mul", t4, zsquared, t3),
          // tmp3 = tmp3 + tmp3;
          c.call(f2mPrefix + "_add", t3, t3, t3),
          // tmp3 = -tmp3;
          c.call(f2mPrefix + "_neg", t3, t3),
          // tmp6 = tmp6.square() - tmp0 - tmp5;
          c.call(f2mPrefix + "_square", t6, t6),
          c.call(f2mPrefix + "_sub", t6, t0, t6),
          c.call(f2mPrefix + "_sub", t6, t5, t6),
          // tmp1 = tmp1 + tmp1;
          c.call(f2mPrefix + "_add", t1, t1, t1),
          // tmp1 = tmp1 + tmp1;
          c.call(f2mPrefix + "_add", t1, t1, t1),
          // tmp6 = tmp6 - tmp1;
          c.call(f2mPrefix + "_sub", t6, t1, t6),
          // tmp0 = r.z * zsquared;
          c.call(f2mPrefix + "_mul", Rz, zsquared, t0),
          // tmp0 = tmp0 + tmp0;
          c.call(f2mPrefix + "_add", t0, t0, t0)
        );
      }
      function buildPrepAddStep() {
        const f = module3.addFunction(prefix + "_prepAddStep");
        f.addParam("R", "i32");
        f.addParam("Q", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const Rx = c.getLocal("R");
        const Ry = c.i32_add(c.getLocal("R"), c.i32_const(2 * n8q));
        const Rz = c.i32_add(c.getLocal("R"), c.i32_const(4 * n8q));
        const Qx = c.getLocal("Q");
        const Qy = c.i32_add(c.getLocal("Q"), c.i32_const(2 * n8q));
        const t10 = c.getLocal("r");
        const t1 = c.i32_add(c.getLocal("r"), c.i32_const(2 * n8q));
        const t9 = c.i32_add(c.getLocal("r"), c.i32_const(4 * n8q));
        const zsquared = c.i32_const(module3.alloc(f2size));
        const ysquared = c.i32_const(module3.alloc(f2size));
        const ztsquared = c.i32_const(module3.alloc(f2size));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t3 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        const t6 = c.i32_const(module3.alloc(f2size));
        const t7 = c.i32_const(module3.alloc(f2size));
        const t8 = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // zsquared = r.z.square();
          c.call(f2mPrefix + "_square", Rz, zsquared),
          // ysquared = q.y.square();
          c.call(f2mPrefix + "_square", Qy, ysquared),
          // t0 = zsquared * q.x;
          c.call(f2mPrefix + "_mul", zsquared, Qx, t0),
          // t1 = ((q.y + r.z).square() - ysquared - zsquared) * zsquared;
          c.call(f2mPrefix + "_add", Qy, Rz, t1),
          c.call(f2mPrefix + "_square", t1, t1),
          c.call(f2mPrefix + "_sub", t1, ysquared, t1),
          c.call(f2mPrefix + "_sub", t1, zsquared, t1),
          c.call(f2mPrefix + "_mul", t1, zsquared, t1),
          // t2 = t0 - r.x;
          c.call(f2mPrefix + "_sub", t0, Rx, t2),
          // t3 = t2.square();
          c.call(f2mPrefix + "_square", t2, t3),
          // t4 = t3 + t3;
          c.call(f2mPrefix + "_add", t3, t3, t4),
          // t4 = t4 + t4;
          c.call(f2mPrefix + "_add", t4, t4, t4),
          // t5 = t4 * t2;
          c.call(f2mPrefix + "_mul", t4, t2, t5),
          // t6 = t1 - r.y - r.y;
          c.call(f2mPrefix + "_sub", t1, Ry, t6),
          c.call(f2mPrefix + "_sub", t6, Ry, t6),
          // t9 = t6 * q.x;
          c.call(f2mPrefix + "_mul", t6, Qx, t9),
          // t7 = t4 * r.x;
          c.call(f2mPrefix + "_mul", t4, Rx, t7),
          // r.x = t6.square() - t5 - t7 - t7;
          c.call(f2mPrefix + "_square", t6, Rx),
          c.call(f2mPrefix + "_sub", Rx, t5, Rx),
          c.call(f2mPrefix + "_sub", Rx, t7, Rx),
          c.call(f2mPrefix + "_sub", Rx, t7, Rx),
          // r.z = (r.z + t2).square() - zsquared - t3;
          c.call(f2mPrefix + "_add", Rz, t2, Rz),
          c.call(f2mPrefix + "_square", Rz, Rz),
          c.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
          c.call(f2mPrefix + "_sub", Rz, t3, Rz),
          // t10 = q.y + r.z;
          c.call(f2mPrefix + "_add", Qy, Rz, t10),
          // t8 = (t7 - r.x) * t6;
          c.call(f2mPrefix + "_sub", t7, Rx, t8),
          c.call(f2mPrefix + "_mul", t8, t6, t8),
          // t0 = r.y * t5;
          c.call(f2mPrefix + "_mul", Ry, t5, t0),
          // t0 = t0 + t0;
          c.call(f2mPrefix + "_add", t0, t0, t0),
          // r.y = t8 - t0;
          c.call(f2mPrefix + "_sub", t8, t0, Ry),
          // t10 = t10.square() - ysquared;
          c.call(f2mPrefix + "_square", t10, t10),
          c.call(f2mPrefix + "_sub", t10, ysquared, t10),
          // ztsquared = r.z.square();
          c.call(f2mPrefix + "_square", Rz, ztsquared),
          // t10 = t10 - ztsquared;
          c.call(f2mPrefix + "_sub", t10, ztsquared, t10),
          // t9 = t9 + t9 - t10;
          c.call(f2mPrefix + "_add", t9, t9, t9),
          c.call(f2mPrefix + "_sub", t9, t10, t9),
          // t10 = r.z + r.z;
          c.call(f2mPrefix + "_add", Rz, Rz, t10),
          // t6 = -t6;
          c.call(f2mPrefix + "_neg", t6, t6),
          // t1 = t6 + t6;
          c.call(f2mPrefix + "_add", t6, t6, t1)
        );
      }
      function buildPrepareG2() {
        const f = module3.addFunction(prefix + "_prepareG2");
        f.addParam("pQ", "i32");
        f.addParam("ppreQ", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const Q = c.getLocal("pQ");
        const pR = module3.alloc(f2size * 3);
        const R = c.i32_const(pR);
        const base = c.getLocal("ppreQ");
        f.addCode(
          c.call(g2mPrefix + "_normalize", Q, base),
          c.if(
            c.call(g2mPrefix + "_isZero", base),
            c.ret([])
          ),
          c.call(g2mPrefix + "_copy", base, R),
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3)))
        );
        f.addCode(
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "_prepDblStep", R, c.getLocal("pCoef")),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(prefix + "_prepAddStep", R, base, c.getLocal("pCoef")),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildF6Mul1() {
        const f = module3.addFunction(f6mPrefix + "_mul1");
        f.addParam("pA", "i32");
        f.addParam("pC1", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const A_c0 = c.getLocal("pA");
        const A_c1 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 2));
        const A_c2 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 4));
        const c1 = c.getLocal("pC1");
        const t1 = c.getLocal("pR");
        const t2 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 2));
        const b_b = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 4));
        const Ac0_Ac1 = c.i32_const(module3.alloc(f1size * 2));
        const Ac1_Ac2 = c.i32_const(module3.alloc(f1size * 2));
        f.addCode(
          c.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
          c.call(f2mPrefix + "_add", A_c1, A_c2, Ac1_Ac2),
          // let b_b = self.c1 * c1;
          c.call(f2mPrefix + "_mul", A_c1, c1, b_b),
          // let t1 = (self.c1 + self.c2) * c1 - b_b;
          c.call(f2mPrefix + "_mul", Ac1_Ac2, c1, t1),
          c.call(f2mPrefix + "_sub", t1, b_b, t1),
          // let t1 = t1.mul_by_nonresidue();
          c.call(f2mPrefix + "_mulNR", t1, t1),
          // let t2 = (self.c0 + self.c1) * c1 - b_b;
          c.call(f2mPrefix + "_mul", Ac0_Ac1, c1, t2),
          c.call(f2mPrefix + "_sub", t2, b_b, t2)
        );
      }
      buildF6Mul1();
      function buildF6Mul01() {
        const f = module3.addFunction(f6mPrefix + "_mul01");
        f.addParam("pA", "i32");
        f.addParam("pC0", "i32");
        f.addParam("pC1", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const A_c0 = c.getLocal("pA");
        const A_c1 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 2));
        const A_c2 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 4));
        const c0 = c.getLocal("pC0");
        const c1 = c.getLocal("pC1");
        const t1 = c.getLocal("pR");
        const t2 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 2));
        const t3 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 4));
        const a_a = c.i32_const(module3.alloc(f1size * 2));
        const b_b = c.i32_const(module3.alloc(f1size * 2));
        const Ac0_Ac1 = c.i32_const(module3.alloc(f1size * 2));
        const Ac0_Ac2 = c.i32_const(module3.alloc(f1size * 2));
        f.addCode(
          // let a_a = self.c0 * c0;
          c.call(f2mPrefix + "_mul", A_c0, c0, a_a),
          // let b_b = self.c1 * c1;
          c.call(f2mPrefix + "_mul", A_c1, c1, b_b),
          c.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
          c.call(f2mPrefix + "_add", A_c0, A_c2, Ac0_Ac2),
          // let t1 = (self.c1 + self.c2) * c1 - b_b;
          c.call(f2mPrefix + "_add", A_c1, A_c2, t1),
          c.call(f2mPrefix + "_mul", t1, c1, t1),
          c.call(f2mPrefix + "_sub", t1, b_b, t1),
          // let t1 = t1.mul_by_nonresidue() + a_a;
          c.call(f2mPrefix + "_mulNR", t1, t1),
          c.call(f2mPrefix + "_add", t1, a_a, t1),
          // let t2 = (c0 + c1) * (self.c0 + self.c1) - a_a - b_b;
          c.call(f2mPrefix + "_add", c0, c1, t2),
          c.call(f2mPrefix + "_mul", t2, Ac0_Ac1, t2),
          c.call(f2mPrefix + "_sub", t2, a_a, t2),
          c.call(f2mPrefix + "_sub", t2, b_b, t2),
          // let t3 = (self.c0 + self.c2) * c0 - a_a + b_b;
          c.call(f2mPrefix + "_mul", Ac0_Ac2, c0, t3),
          c.call(f2mPrefix + "_sub", t3, a_a, t3),
          c.call(f2mPrefix + "_add", t3, b_b, t3)
        );
      }
      buildF6Mul01();
      function buildF12Mul014() {
        const f = module3.addFunction(ftmPrefix + "_mul014");
        f.addParam("pA", "i32");
        f.addParam("pC0", "i32");
        f.addParam("pC1", "i32");
        f.addParam("pC4", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const A_c0 = c.getLocal("pA");
        const A_c1 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 6));
        const c0 = c.getLocal("pC0");
        const c1 = c.getLocal("pC1");
        const c4 = c.getLocal("pC4");
        const aa = c.i32_const(module3.alloc(f1size * 6));
        const bb = c.i32_const(module3.alloc(f1size * 6));
        const o = c.i32_const(module3.alloc(f1size * 2));
        const R_c0 = c.getLocal("pR");
        const R_c1 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 6));
        f.addCode(
          // let aa = self.c0.mul_by_01(c0, c1);
          c.call(f6mPrefix + "_mul01", A_c0, c0, c1, aa),
          // let bb = self.c1.mul_by_1(c4);
          c.call(f6mPrefix + "_mul1", A_c1, c4, bb),
          // let o = c1 + c4;
          c.call(f2mPrefix + "_add", c1, c4, o),
          // let c1 = self.c1 + self.c0;
          c.call(f6mPrefix + "_add", A_c1, A_c0, R_c1),
          // let c1 = c1.mul_by_01(c0, &o);
          c.call(f6mPrefix + "_mul01", R_c1, c0, o, R_c1),
          // let c1 = c1 - aa - bb;
          c.call(f6mPrefix + "_sub", R_c1, aa, R_c1),
          c.call(f6mPrefix + "_sub", R_c1, bb, R_c1),
          // let c0 = bb;
          c.call(f6mPrefix + "_copy", bb, R_c0),
          // let c0 = c0.mul_by_nonresidue();
          c.call(f6mPrefix + "_mulNR", R_c0, R_c0),
          // let c0 = c0 + aa;
          c.call(f6mPrefix + "_add", R_c0, aa, R_c0)
        );
      }
      buildF12Mul014();
      function buildELL() {
        const f = module3.addFunction(prefix + "_ell");
        f.addParam("pP", "i32");
        f.addParam("pCoefs", "i32");
        f.addParam("pF", "i32");
        const c = f.getCodeBuilder();
        const Px = c.getLocal("pP");
        const Py = c.i32_add(c.getLocal("pP"), c.i32_const(n8q));
        const F = c.getLocal("pF");
        const coef0_0 = c.getLocal("pCoefs");
        const coef0_1 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size));
        const coef1_0 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size * 2));
        const coef1_1 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size * 3));
        const coef2 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size * 4));
        const pc0 = module3.alloc(f1size * 2);
        const c0 = c.i32_const(pc0);
        const c0_c0 = c.i32_const(pc0);
        const c0_c1 = c.i32_const(pc0 + f1size);
        const pc1 = module3.alloc(f1size * 2);
        const c1 = c.i32_const(pc1);
        const c1_c0 = c.i32_const(pc1);
        const c1_c1 = c.i32_const(pc1 + f1size);
        f.addCode(
          //     let mut c0 = coeffs.0;
          //     let mut c1 = coeffs.1;
          //
          //    c0.c0 *= p.y;
          //    c0.c1 *= p.y;
          //
          //    c1.c0 *= p.x;
          //    c1.c1 *= p.x;
          //
          //     f.mul_by_014(&coeffs.2, &c1, &c0)
          c.call(f1mPrefix + "_mul", coef0_0, Py, c0_c0),
          c.call(f1mPrefix + "_mul", coef0_1, Py, c0_c1),
          c.call(f1mPrefix + "_mul", coef1_0, Px, c1_c0),
          c.call(f1mPrefix + "_mul", coef1_1, Px, c1_c1),
          c.call(ftmPrefix + "_mul014", F, coef2, c1, c0, F)
        );
      }
      buildELL();
      function buildMillerLoop() {
        const f = module3.addFunction(prefix + "_millerLoop");
        f.addParam("ppreP", "i32");
        f.addParam("ppreQ", "i32");
        f.addParam("r", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const preP = c.getLocal("ppreP");
        const coefs = c.getLocal("pCoef");
        const F = c.getLocal("r");
        f.addCode(
          c.call(ftmPrefix + "_one", F),
          c.if(
            c.call(g1mPrefix + "_isZero", preP),
            c.ret([])
          ),
          c.if(
            c.call(g1mPrefix + "_isZero", c.getLocal("ppreQ")),
            c.ret([])
          ),
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3))),
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "_ell", preP, coefs, F),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(prefix + "_ell", preP, coefs, F),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.call(ftmPrefix + "_square", F, F),
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.i32_const(1))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          )),
          c.call(prefix + "_ell", preP, coefs, F)
        );
        if (isLoopNegative) {
          f.addCode(
            c.call(ftmPrefix + "_conjugate", F, F)
          );
        }
      }
      function buildFrobeniusMap(n) {
        const F12 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n, 151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],
            [2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n, 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n, 877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n],
            [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
            [151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n, 3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n, 2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
            [877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n, 3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n]
          ]
        ];
        const F6 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [0n, 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [0n, 1n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [0n, 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n]
          ],
          [
            [1n, 0n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n]
          ]
        ];
        const f = module3.addFunction(ftmPrefix + "_frobeniusMap" + n);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < 6; i++) {
          const X = i == 0 ? c.getLocal("x") : c.i32_add(c.getLocal("x"), c.i32_const(i * f2size));
          const Xc0 = X;
          const Xc1 = c.i32_add(c.getLocal("x"), c.i32_const(i * f2size + f1size));
          const R = i == 0 ? c.getLocal("r") : c.i32_add(c.getLocal("r"), c.i32_const(i * f2size));
          const Rc0 = R;
          const Rc1 = c.i32_add(c.getLocal("r"), c.i32_const(i * f2size + f1size));
          const coef = mul22(F12[Math.floor(i / 3)][n % 12], F6[i % 3][n % 6]);
          const pCoef = module3.alloc([
            ...utils2.bigInt2BytesLE(toMontgomery(coef[0]), n8q),
            ...utils2.bigInt2BytesLE(toMontgomery(coef[1]), n8q)
          ]);
          if (n % 2 == 1) {
            f.addCode(
              c.call(f1mPrefix + "_copy", Xc0, Rc0),
              c.call(f1mPrefix + "_neg", Xc1, Rc1),
              c.call(f2mPrefix + "_mul", R, c.i32_const(pCoef), R)
            );
          } else {
            f.addCode(c.call(f2mPrefix + "_mul", X, c.i32_const(pCoef), R));
          }
        }
        function mul22(a, b) {
          const ac0 = a[0];
          const ac1 = a[1];
          const bc0 = b[0];
          const bc1 = b[1];
          const res = [
            (ac0 * bc0 - ac1 * bc1) % q,
            (ac0 * bc1 + ac1 * bc0) % q
          ];
          if (isNegative5(res[0]))
            res[0] = res[0] + q;
          return res;
        }
      }
      function buildCyclotomicSquare() {
        const f = module3.addFunction(prefix + "__cyclotomicSquare");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x4 = c.i32_add(c.getLocal("x"), c.i32_const(f2size));
        const x3 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f2size));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(3 * f2size));
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(4 * f2size));
        const x5 = c.i32_add(c.getLocal("x"), c.i32_const(5 * f2size));
        const r0 = c.getLocal("r");
        const r4 = c.i32_add(c.getLocal("r"), c.i32_const(f2size));
        const r3 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f2size));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(3 * f2size));
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(4 * f2size));
        const r5 = c.i32_add(c.getLocal("r"), c.i32_const(5 * f2size));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t3 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        const tmp = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          //    // t0 + t1*y = (z0 + z1*y)^2 = a^2
          //    tmp = z0 * z1;
          //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;
          //    t1 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x0, x1, tmp),
          c.call(f2mPrefix + "_mulNR", x1, t0),
          c.call(f2mPrefix + "_add", x0, t0, t0),
          c.call(f2mPrefix + "_add", x0, x1, AUX),
          c.call(f2mPrefix + "_mul", AUX, t0, t0),
          c.call(f2mPrefix + "_mulNR", tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t0, AUX, t0),
          c.call(f2mPrefix + "_add", tmp, tmp, t1),
          //  // t2 + t3*y = (z2 + z3*y)^2 = b^2
          //  tmp = z2 * z3;
          //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;
          //  t3 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x2, x3, tmp),
          c.call(f2mPrefix + "_mulNR", x3, t2),
          c.call(f2mPrefix + "_add", x2, t2, t2),
          c.call(f2mPrefix + "_add", x2, x3, AUX),
          c.call(f2mPrefix + "_mul", AUX, t2, t2),
          c.call(f2mPrefix + "_mulNR", tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t2, AUX, t2),
          c.call(f2mPrefix + "_add", tmp, tmp, t3),
          //  // t4 + t5*y = (z4 + z5*y)^2 = c^2
          //  tmp = z4 * z5;
          //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;
          //  t5 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x4, x5, tmp),
          c.call(f2mPrefix + "_mulNR", x5, t4),
          c.call(f2mPrefix + "_add", x4, t4, t4),
          c.call(f2mPrefix + "_add", x4, x5, AUX),
          c.call(f2mPrefix + "_mul", AUX, t4, t4),
          c.call(f2mPrefix + "_mulNR", tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t4, AUX, t4),
          c.call(f2mPrefix + "_add", tmp, tmp, t5),
          // For A
          // z0 = 3 * t0 - 2 * z0
          c.call(f2mPrefix + "_sub", t0, x0, r0),
          c.call(f2mPrefix + "_add", r0, r0, r0),
          c.call(f2mPrefix + "_add", t0, r0, r0),
          // z1 = 3 * t1 + 2 * z1
          c.call(f2mPrefix + "_add", t1, x1, r1),
          c.call(f2mPrefix + "_add", r1, r1, r1),
          c.call(f2mPrefix + "_add", t1, r1, r1),
          // For B
          // z2 = 3 * (xi * t5) + 2 * z2
          c.call(f2mPrefix + "_mul", t5, c.i32_const(pBls12381Twist), AUX),
          c.call(f2mPrefix + "_add", AUX, x2, r2),
          c.call(f2mPrefix + "_add", r2, r2, r2),
          c.call(f2mPrefix + "_add", AUX, r2, r2),
          // z3 = 3 * t4 - 2 * z3
          c.call(f2mPrefix + "_sub", t4, x3, r3),
          c.call(f2mPrefix + "_add", r3, r3, r3),
          c.call(f2mPrefix + "_add", t4, r3, r3),
          // For C
          // z4 = 3 * t2 - 2 * z4
          c.call(f2mPrefix + "_sub", t2, x4, r4),
          c.call(f2mPrefix + "_add", r4, r4, r4),
          c.call(f2mPrefix + "_add", t2, r4, r4),
          // z5 = 3 * t3 + 2 * z5
          c.call(f2mPrefix + "_add", t3, x5, r5),
          c.call(f2mPrefix + "_add", r5, r5, r5),
          c.call(f2mPrefix + "_add", t3, r5, r5)
        );
      }
      function buildCyclotomicExp(exponent, isExpNegative, fnName) {
        const exponentNafBytes = naf4(exponent).map((b) => b == -1 ? 255 : b);
        const pExponentNafBytes = module3.alloc(exponentNafBytes);
        const f = module3.addFunction(prefix + "__cyclotomicExp_" + fnName);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("bit", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("x");
        const res = c.getLocal("r");
        const inverse = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          c.call(ftmPrefix + "_conjugate", x, inverse),
          c.call(ftmPrefix + "_one", res),
          c.if(
            c.teeLocal("bit", c.i32_load8_s(c.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
            c.if(
              c.i32_eq(
                c.getLocal("bit"),
                c.i32_const(1)
              ),
              c.call(ftmPrefix + "_mul", res, x, res),
              c.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c.setLocal("i", c.i32_const(exponentNafBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "__cyclotomicSquare", res, res),
            c.if(
              c.teeLocal("bit", c.i32_load8_s(c.getLocal("i"), pExponentNafBytes)),
              c.if(
                c.i32_eq(
                  c.getLocal("bit"),
                  c.i32_const(1)
                ),
                c.call(ftmPrefix + "_mul", res, x, res),
                c.call(ftmPrefix + "_mul", res, inverse, res)
              )
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
        if (isExpNegative) {
          f.addCode(
            c.call(ftmPrefix + "_conjugate", res, res)
          );
        }
      }
      function buildFinalExponentiation() {
        buildCyclotomicSquare();
        buildCyclotomicExp(finalExpZ, finalExpIsNegative, "w0");
        const f = module3.addFunction(prefix + "_finalExponentiation");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const res = c.getLocal("r");
        const t0 = c.i32_const(module3.alloc(ftsize));
        const t1 = c.i32_const(module3.alloc(ftsize));
        const t2 = c.i32_const(module3.alloc(ftsize));
        const t3 = c.i32_const(module3.alloc(ftsize));
        const t4 = c.i32_const(module3.alloc(ftsize));
        const t5 = c.i32_const(module3.alloc(ftsize));
        const t6 = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          // let mut t0 = f.frobenius_map(6)
          c.call(ftmPrefix + "_frobeniusMap6", elt, t0),
          // let t1 = f.invert()
          c.call(ftmPrefix + "_inverse", elt, t1),
          // let mut t2 = t0 * t1;
          c.call(ftmPrefix + "_mul", t0, t1, t2),
          // t1 = t2.clone();
          c.call(ftmPrefix + "_copy", t2, t1),
          // t2 = t2.frobenius_map().frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap2", t2, t2),
          // t2 *= t1;
          c.call(ftmPrefix + "_mul", t2, t1, t2),
          // t1 = cyclotomic_square(t2).conjugate();
          c.call(prefix + "__cyclotomicSquare", t2, t1),
          c.call(ftmPrefix + "_conjugate", t1, t1),
          // let mut t3 = cycolotomic_exp(t2);
          c.call(prefix + "__cyclotomicExp_w0", t2, t3),
          // let mut t4 = cyclotomic_square(t3);
          c.call(prefix + "__cyclotomicSquare", t3, t4),
          // let mut t5 = t1 * t3;
          c.call(ftmPrefix + "_mul", t1, t3, t5),
          // t1 = cycolotomic_exp(t5);
          c.call(prefix + "__cyclotomicExp_w0", t5, t1),
          // t0 = cycolotomic_exp(t1);
          c.call(prefix + "__cyclotomicExp_w0", t1, t0),
          // let mut t6 = cycolotomic_exp(t0);
          c.call(prefix + "__cyclotomicExp_w0", t0, t6),
          // t6 *= t4;
          c.call(ftmPrefix + "_mul", t6, t4, t6),
          // t4 = cycolotomic_exp(t6);
          c.call(prefix + "__cyclotomicExp_w0", t6, t4),
          // t5 = t5.conjugate();
          c.call(ftmPrefix + "_conjugate", t5, t5),
          // t4 *= t5 * t2;
          c.call(ftmPrefix + "_mul", t4, t5, t4),
          c.call(ftmPrefix + "_mul", t4, t2, t4),
          // t5 = t2.conjugate();
          c.call(ftmPrefix + "_conjugate", t2, t5),
          // t1 *= t2;
          c.call(ftmPrefix + "_mul", t1, t2, t1),
          // t1 = t1.frobenius_map().frobenius_map().frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap3", t1, t1),
          // t6 *= t5;
          c.call(ftmPrefix + "_mul", t6, t5, t6),
          // t6 = t6.frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap1", t6, t6),
          // t3 *= t0;
          c.call(ftmPrefix + "_mul", t3, t0, t3),
          // t3 = t3.frobenius_map().frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap2", t3, t3),
          // t3 *= t1;
          c.call(ftmPrefix + "_mul", t3, t1, t3),
          // t3 *= t6;
          c.call(ftmPrefix + "_mul", t3, t6, t3),
          // f = t3 * t4;
          c.call(ftmPrefix + "_mul", t3, t4, res)
        );
      }
      function buildFinalExponentiationOld() {
        const f = module3.addFunction(prefix + "_finalExponentiationOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const exponent = 322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n;
        const pExponent = module3.alloc(utils2.bigInt2BytesLE(exponent, 544));
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(ftmPrefix + "_exp", c.getLocal("x"), c.i32_const(pExponent), c.i32_const(544), c.getLocal("r"))
        );
      }
      const pPreP = module3.alloc(prePSize);
      const pPreQ = module3.alloc(preQSize);
      function buildPairingEquation(nPairings) {
        const f = module3.addFunction(prefix + "_pairingEq" + nPairings);
        for (let i = 0; i < nPairings; i++) {
          f.addParam("p_" + i, "i32");
          f.addParam("q_" + i, "i32");
        }
        f.addParam("c", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        const auxT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(ftmPrefix + "_one", resT));
        for (let i = 0; i < nPairings; i++) {
          f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p_" + i), c.i32_const(pPreP)));
          f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q_" + i), c.i32_const(pPreQ)));
          f.addCode(
            c.if(
              c.i32_eqz(c.call(g1mPrefix + "_inGroupAffine", c.i32_const(pPreP))),
              c.ret(c.i32_const(0))
            ),
            c.if(
              c.i32_eqz(c.call(g2mPrefix + "_inGroupAffine", c.i32_const(pPreQ))),
              c.ret(c.i32_const(0))
            )
          );
          f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), auxT));
          f.addCode(c.call(ftmPrefix + "_mul", resT, auxT, resT));
        }
        f.addCode(c.call(prefix + "_finalExponentiation", resT, resT));
        f.addCode(c.call(ftmPrefix + "_eq", resT, c.getLocal("c")));
      }
      function buildPairing4() {
        const f = module3.addFunction(prefix + "_pairing");
        f.addParam("p", "i32");
        f.addParam("q", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p"), c.i32_const(pPreP)));
        f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q"), c.i32_const(pPreQ)));
        f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), resT));
        f.addCode(c.call(prefix + "_finalExponentiation", resT, c.getLocal("r")));
      }
      function buildInGroupG2() {
        const f = module3.addFunction(g2mPrefix + "_inGroupAffine");
        f.addParam("p", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const WINV = [
          2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279894n,
          2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893n
        ];
        const FROB2X = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
        const FROB3Y = [
          2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,
          2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n
        ];
        const wInv = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery(WINV[0]), n8q),
          ...utils2.bigInt2BytesLE(toMontgomery(WINV[1]), n8q)
        ]));
        const frob2X = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(FROB2X), n8q)));
        const frob3Y = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery(FROB3Y[0]), n8q),
          ...utils2.bigInt2BytesLE(toMontgomery(FROB3Y[1]), n8q)
        ]));
        const z = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(finalExpZ, 8)));
        const px = c.getLocal("p");
        const py = c.i32_add(c.getLocal("p"), c.i32_const(f2size));
        const aux = c.i32_const(module3.alloc(f1size));
        const x_winv = c.i32_const(module3.alloc(f2size));
        const y_winv = c.i32_const(module3.alloc(f2size));
        const pf2 = module3.alloc(f2size * 2);
        const f2 = c.i32_const(pf2);
        const f2x = c.i32_const(pf2);
        const f2x_c1 = c.i32_const(pf2);
        const f2x_c2 = c.i32_const(pf2 + f1size);
        const f2y = c.i32_const(pf2 + f2size);
        const f2y_c1 = c.i32_const(pf2 + f2size);
        const f2y_c2 = c.i32_const(pf2 + f2size + f1size);
        const pf3 = module3.alloc(f2size * 3);
        const f3 = c.i32_const(pf3);
        const f3x = c.i32_const(pf3);
        const f3x_c1 = c.i32_const(pf3);
        const f3x_c2 = c.i32_const(pf3 + f1size);
        const f3y = c.i32_const(pf3 + f2size);
        const f3y_c1 = c.i32_const(pf3 + f2size);
        const f3y_c2 = c.i32_const(pf3 + f2size + f1size);
        const f3z = c.i32_const(pf3 + f2size * 2);
        f.addCode(
          c.if(
            c.call(g2mPrefix + "_isZeroAffine", c.getLocal("p")),
            c.ret(c.i32_const(1))
          ),
          c.if(
            c.i32_eqz(c.call(g2mPrefix + "_inCurveAffine", c.getLocal("p"))),
            c.ret(c.i32_const(0))
          ),
          c.call(f2mPrefix + "_mul", px, wInv, x_winv),
          c.call(f2mPrefix + "_mul", py, wInv, y_winv),
          c.call(f2mPrefix + "_mul1", x_winv, frob2X, f2x),
          c.call(f2mPrefix + "_neg", y_winv, f2y),
          c.call(f2mPrefix + "_neg", x_winv, f3x),
          c.call(f2mPrefix + "_mul", y_winv, frob3Y, f3y),
          c.call(f1mPrefix + "_sub", f2x_c1, f2x_c2, aux),
          c.call(f1mPrefix + "_add", f2x_c1, f2x_c2, f2x_c2),
          c.call(f1mPrefix + "_copy", aux, f2x_c1),
          c.call(f1mPrefix + "_sub", f2y_c1, f2y_c2, aux),
          c.call(f1mPrefix + "_add", f2y_c1, f2y_c2, f2y_c2),
          c.call(f1mPrefix + "_copy", aux, f2y_c1),
          c.call(f1mPrefix + "_add", f3x_c1, f3x_c2, aux),
          c.call(f1mPrefix + "_sub", f3x_c1, f3x_c2, f3x_c2),
          c.call(f1mPrefix + "_copy", aux, f3x_c1),
          c.call(f1mPrefix + "_sub", f3y_c2, f3y_c1, aux),
          c.call(f1mPrefix + "_add", f3y_c1, f3y_c2, f3y_c2),
          c.call(f1mPrefix + "_copy", aux, f3y_c1),
          c.call(f2mPrefix + "_one", f3z),
          c.call(g2mPrefix + "_timesScalar", f3, z, c.i32_const(8), f3),
          c.call(g2mPrefix + "_addMixed", f3, f2, f3),
          c.ret(
            c.call(g2mPrefix + "_eqMixed", f3, c.getLocal("p"))
          )
        );
        const fInGroup = module3.addFunction(g2mPrefix + "_inGroup");
        fInGroup.addParam("pIn", "i32");
        fInGroup.setReturnType("i32");
        const c2 = fInGroup.getCodeBuilder();
        const aux2 = c2.i32_const(module3.alloc(f2size * 2));
        fInGroup.addCode(
          c2.call(g2mPrefix + "_toAffine", c2.getLocal("pIn"), aux2),
          c2.ret(
            c2.call(g2mPrefix + "_inGroupAffine", aux2)
          )
        );
      }
      function buildInGroupG1() {
        const f = module3.addFunction(g1mPrefix + "_inGroupAffine");
        f.addParam("p", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const BETA = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
        const BETA2 = 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n;
        const Z2M1D3 = (finalExpZ * finalExpZ - 1n) / 3n;
        const beta = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(BETA), n8q)));
        const beta2 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(BETA2), n8q)));
        const z2m1d3 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(Z2M1D3, 16)));
        const px = c.getLocal("p");
        const py = c.i32_add(c.getLocal("p"), c.i32_const(f1size));
        const psp = module3.alloc(f1size * 3);
        const sp = c.i32_const(psp);
        const spx = c.i32_const(psp);
        const spy = c.i32_const(psp + f1size);
        const ps2p = module3.alloc(f1size * 2);
        const s2p = c.i32_const(ps2p);
        const s2px = c.i32_const(ps2p);
        const s2py = c.i32_const(ps2p + f1size);
        f.addCode(
          c.if(
            c.call(g1mPrefix + "_isZeroAffine", c.getLocal("p")),
            c.ret(c.i32_const(1))
          ),
          c.if(
            c.i32_eqz(c.call(g1mPrefix + "_inCurveAffine", c.getLocal("p"))),
            c.ret(c.i32_const(0))
          ),
          c.call(f1mPrefix + "_mul", px, beta, spx),
          c.call(f1mPrefix + "_copy", py, spy),
          c.call(f1mPrefix + "_mul", px, beta2, s2px),
          c.call(f1mPrefix + "_copy", py, s2py),
          c.call(g1mPrefix + "_doubleAffine", sp, sp),
          c.call(g1mPrefix + "_subMixed", sp, c.getLocal("p"), sp),
          c.call(g1mPrefix + "_subMixed", sp, s2p, sp),
          c.call(g1mPrefix + "_timesScalar", sp, z2m1d3, c.i32_const(16), sp),
          c.ret(
            c.call(g1mPrefix + "_eqMixed", sp, s2p)
          )
        );
        const fInGroup = module3.addFunction(g1mPrefix + "_inGroup");
        fInGroup.addParam("pIn", "i32");
        fInGroup.setReturnType("i32");
        const c2 = fInGroup.getCodeBuilder();
        const aux2 = c2.i32_const(module3.alloc(f1size * 2));
        fInGroup.addCode(
          c2.call(g1mPrefix + "_toAffine", c2.getLocal("pIn"), aux2),
          c2.ret(
            c2.call(g1mPrefix + "_inGroupAffine", aux2)
          )
        );
      }
      for (let i = 0; i < 10; i++) {
        buildFrobeniusMap(i);
        module3.exportFunction(ftmPrefix + "_frobeniusMap" + i);
      }
      buildInGroupG1();
      buildInGroupG2();
      buildPrepAddStep();
      buildPrepDoubleStep();
      buildPrepareG1();
      buildPrepareG2();
      buildMillerLoop();
      buildFinalExponentiationOld();
      buildFinalExponentiation();
      for (let i = 1; i <= 5; i++) {
        buildPairingEquation(i);
        module3.exportFunction(prefix + "_pairingEq" + i);
      }
      buildPairing4();
      module3.exportFunction(prefix + "_pairing");
      module3.exportFunction(prefix + "_prepareG1");
      module3.exportFunction(prefix + "_prepareG2");
      module3.exportFunction(prefix + "_millerLoop");
      module3.exportFunction(prefix + "_finalExponentiation");
      module3.exportFunction(prefix + "_finalExponentiationOld");
      module3.exportFunction(prefix + "__cyclotomicSquare");
      module3.exportFunction(prefix + "__cyclotomicExp_w0");
      module3.exportFunction(f6mPrefix + "_mul1");
      module3.exportFunction(f6mPrefix + "_mul01");
      module3.exportFunction(ftmPrefix + "_mul014");
      module3.exportFunction(g1mPrefix + "_inGroupAffine");
      module3.exportFunction(g1mPrefix + "_inGroup");
      module3.exportFunction(g2mPrefix + "_inGroupAffine");
      module3.exportFunction(g2mPrefix + "_inGroup");
    };
  }
});

// ../../node_modules/snarkjs/node_modules/wasmcurves/index.js
var require_wasmcurves2 = __commonJS({
  "../../node_modules/snarkjs/node_modules/wasmcurves/index.js"(exports, module2) {
    "use strict";
    module2.exports.buildBn128 = require_build_bn1282();
    module2.exports.buildBls12381 = require_build_bls123812();
    module2.exports.buildF1m = require_build_f1m2();
  }
});

// ../../node_modules/nanoassert/index.js
var require_nanoassert = __commonJS({
  "../../node_modules/nanoassert/index.js"(exports, module2) {
    "use strict";
    module2.exports = assert;
    var AssertionError = class extends Error {
    };
    AssertionError.prototype.name = "AssertionError";
    function assert(t, m) {
      if (!t) {
        var err = new AssertionError(m);
        if (Error.captureStackTrace)
          Error.captureStackTrace(err, assert);
        throw err;
      }
    }
  }
});

// ../../node_modules/b4a/index.js
var require_b4a = __commonJS({
  "../../node_modules/b4a/index.js"(exports, module2) {
    "use strict";
    function isBuffer2(value) {
      return Buffer.isBuffer(value) || value instanceof Uint8Array;
    }
    function isEncoding(encoding) {
      return Buffer.isEncoding(encoding);
    }
    function alloc(size, fill2, encoding) {
      return Buffer.alloc(size, fill2, encoding);
    }
    function allocUnsafe(size) {
      return Buffer.allocUnsafe(size);
    }
    function allocUnsafeSlow(size) {
      return Buffer.allocUnsafeSlow(size);
    }
    function byteLength(string2, encoding) {
      return Buffer.byteLength(string2, encoding);
    }
    function compare(a, b) {
      return Buffer.compare(a, b);
    }
    function concat(buffers, totalLength) {
      return Buffer.concat(buffers, totalLength);
    }
    function copy(source, target, targetStart, start, end) {
      return toBuffer(source).copy(target, targetStart, start, end);
    }
    function equals(a, b) {
      return toBuffer(a).equals(b);
    }
    function fill(buffer, value, offset, end, encoding) {
      return toBuffer(buffer).fill(value, offset, end, encoding);
    }
    function from(value, encodingOrOffset, length) {
      return Buffer.from(value, encodingOrOffset, length);
    }
    function includes(buffer, value, byteOffset, encoding) {
      return toBuffer(buffer).includes(value, byteOffset, encoding);
    }
    function indexOf(buffer, value, byfeOffset, encoding) {
      return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
    }
    function lastIndexOf(buffer, value, byteOffset, encoding) {
      return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
    }
    function swap16(buffer) {
      return toBuffer(buffer).swap16();
    }
    function swap32(buffer) {
      return toBuffer(buffer).swap32();
    }
    function swap64(buffer) {
      return toBuffer(buffer).swap64();
    }
    function toBuffer(buffer) {
      if (Buffer.isBuffer(buffer))
        return buffer;
      return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    function toString6(buffer, encoding, start, end) {
      return toBuffer(buffer).toString(encoding, start, end);
    }
    function write2(buffer, string2, offset, length, encoding) {
      return toBuffer(buffer).write(string2, offset, length, encoding);
    }
    function writeDoubleLE(buffer, value, offset) {
      return toBuffer(buffer).writeDoubleLE(value, offset);
    }
    function writeFloatLE(buffer, value, offset) {
      return toBuffer(buffer).writeFloatLE(value, offset);
    }
    function writeUInt32LE(buffer, value, offset) {
      return toBuffer(buffer).writeUInt32LE(value, offset);
    }
    function writeInt32LE(buffer, value, offset) {
      return toBuffer(buffer).writeInt32LE(value, offset);
    }
    function readDoubleLE(buffer, offset) {
      return toBuffer(buffer).readDoubleLE(offset);
    }
    function readFloatLE(buffer, offset) {
      return toBuffer(buffer).readFloatLE(offset);
    }
    function readUInt32LE(buffer, offset) {
      return toBuffer(buffer).readUInt32LE(offset);
    }
    function readInt32LE(buffer, offset) {
      return toBuffer(buffer).readInt32LE(offset);
    }
    module2.exports = {
      isBuffer: isBuffer2,
      isEncoding,
      alloc,
      allocUnsafe,
      allocUnsafeSlow,
      byteLength,
      compare,
      concat,
      copy,
      equals,
      fill,
      from,
      includes,
      indexOf,
      lastIndexOf,
      swap16,
      swap32,
      swap64,
      toBuffer,
      toString: toString6,
      write: write2,
      writeDoubleLE,
      writeFloatLE,
      writeUInt32LE,
      writeInt32LE,
      readDoubleLE,
      readFloatLE,
      readUInt32LE,
      readInt32LE
    };
  }
});

// ../../node_modules/blake2b-wasm/blake2b.js
var require_blake2b = __commonJS({
  "../../node_modules/blake2b-wasm/blake2b.js"(exports, module2) {
    "use strict";
    var __commonJS2 = (cb, mod4) => function __require() {
      return mod4 || (0, cb[Object.keys(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
    };
    var __toBinary = /* @__PURE__ */ (() => {
      var table = new Uint8Array(128);
      for (var i = 0; i < 64; i++)
        table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
      return (base64) => {
        var n = base64.length, bytes2 = new Uint8Array((n - (base64[n - 1] == "=") - (base64[n - 2] == "=")) * 3 / 4 | 0);
        for (var i2 = 0, j = 0; i2 < n; ) {
          var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
          var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
          bytes2[j++] = c0 << 2 | c1 >> 4;
          bytes2[j++] = c1 << 4 | c2 >> 2;
          bytes2[j++] = c2 << 6 | c3;
        }
        return bytes2;
      };
    })();
    var require_blake2b2 = __commonJS2({
      "wasm-binary:./blake2b.wat"(exports2, module22) {
        module22.exports = __toBinary("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMKvz8EwAIAIABCADcDACAAQgA3AwggAEIANwMQIABCADcDGCAAQgA3AyAgAEIANwMoIABCADcDMCAAQgA3AzggAEIANwNAIABCADcDSCAAQgA3A1AgAEIANwNYIABCADcDYCAAQgA3A2ggAEIANwNwIABCADcDeCAAQoiS853/zPmE6gBBACkDAIU3A4ABIABCu86qptjQ67O7f0EIKQMAhTcDiAEgAEKr8NP0r+68tzxBECkDAIU3A5ABIABC8e30+KWn/aelf0EYKQMAhTcDmAEgAELRhZrv+s+Uh9EAQSApAwCFNwOgASAAQp/Y+dnCkdqCm39BKCkDAIU3A6gBIABC6/qG2r+19sEfQTApAwCFNwOwASAAQvnC+JuRo7Pw2wBBOCkDAIU3A7gBIABCADcDwAEgAEIANwPIASAAQgA3A9ABC20BA38gAEHAAWohAyAAQcgBaiEEIAQpAwCnIQUCQANAIAEgAkYNASAFQYABRgRAIAMgAykDACAFrXw3AwBBACEFIAAQAwsgACAFaiABLQAAOgAAIAVBAWohBSABQQFqIQEMAAsLIAQgBa03AwALYQEDfyAAQcABaiEBIABByAFqIQIgASABKQMAIAIpAwB8NwMAIABCfzcD0AEgAikDAKchAwJAA0AgA0GAAUYNASAAIANqQQA6AAAgA0EBaiEDDAALCyACIAOtNwMAIAAQAwuqOwIgfgl/IABBgAFqISEgAEGIAWohIiAAQZABaiEjIABBmAFqISQgAEGgAWohJSAAQagBaiEmIABBsAFqIScgAEG4AWohKCAhKQMAIQEgIikDACECICMpAwAhAyAkKQMAIQQgJSkDACEFICYpAwAhBiAnKQMAIQcgKCkDACEIQoiS853/zPmE6gAhCUK7zqqm2NDrs7t/IQpCq/DT9K/uvLc8IQtC8e30+KWn/aelfyEMQtGFmu/6z5SH0QAhDUKf2PnZwpHagpt/IQ5C6/qG2r+19sEfIQ9C+cL4m5Gjs/DbACEQIAApAwAhESAAKQMIIRIgACkDECETIAApAxghFCAAKQMgIRUgACkDKCEWIAApAzAhFyAAKQM4IRggACkDQCEZIAApA0ghGiAAKQNQIRsgACkDWCEcIAApA2AhHSAAKQNoIR4gACkDcCEfIAApA3ghICANIAApA8ABhSENIA8gACkD0AGFIQ8gASAFIBF8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSASfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgE3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBR8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAVfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBd8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAYfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgGXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBp8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAbfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgHHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIB18fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAefHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgH3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFICB8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAffHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgG3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBV8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAZfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHICB8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAefHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggF3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBJ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAdfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgEXx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBN8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAcfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGHx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBZ8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAUfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHHx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBl8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAdfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgEXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBZ8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByATfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggIHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIB58fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAbfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgH3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBR8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAXfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBJ8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAafHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFXx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBh8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAafHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFHx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBJ8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAefHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHXx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBx8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAffHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgE3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBd8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAWfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgG3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBV8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCARfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgIHx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBl8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAafHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEXx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBZ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAYfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgE3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBV8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAbfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggIHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIB98fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiASfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgHHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB18fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAXfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBR8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAefHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgE3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIB18fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAXfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgG3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBF8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAcfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggGXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBR8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAVfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBh8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAWfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggIHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB98fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSASfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgGnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB18fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAWfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgEnx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGICB8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAffHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBV8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAbfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBh8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAXfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBp8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCATfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGXx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBx8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAefHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgHHx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBh8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAffHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBJ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAUfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBZ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiARfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgIHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBV8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAZfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggF3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBN8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAbfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgF3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFICB8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAffHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGnx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBx8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAUfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggEXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBl8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAdfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgE3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIB58fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAYfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggEnx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBV8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAbfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBt8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSATfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgGXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBV8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAYfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgF3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBJ8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAWfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgIHx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBx8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAafHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgH3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBR8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAdfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgHnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBF8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgISAhKQMAIAEgCYWFNwMAICIgIikDACACIAqFhTcDACAjICMpAwAgAyALhYU3AwAgJCAkKQMAIAQgDIWFNwMAICUgJSkDACAFIA2FhTcDACAmICYpAwAgBiAOhYU3AwAgJyAnKQMAIAcgD4WFNwMAICggKCkDACAIIBCFhTcDAAs=");
      }
    });
    var bytes = require_blake2b2();
    var compiled = WebAssembly.compile(bytes);
    module2.exports = async (imports) => {
      const instance = await WebAssembly.instantiate(await compiled, imports);
      return instance.exports;
    };
  }
});

// ../../node_modules/blake2b-wasm/index.js
var require_blake2b_wasm = __commonJS({
  "../../node_modules/blake2b-wasm/index.js"(exports, module2) {
    "use strict";
    var assert = require_nanoassert();
    var b4a = require_b4a();
    var wasm = null;
    var wasmPromise = typeof WebAssembly !== "undefined" && require_blake2b()().then((mod4) => {
      wasm = mod4;
    });
    var head = 64;
    var freeList = [];
    module2.exports = Blake2b16;
    var BYTES_MIN = module2.exports.BYTES_MIN = 16;
    var BYTES_MAX = module2.exports.BYTES_MAX = 64;
    var BYTES = module2.exports.BYTES = 32;
    var KEYBYTES_MIN = module2.exports.KEYBYTES_MIN = 16;
    var KEYBYTES_MAX = module2.exports.KEYBYTES_MAX = 64;
    var KEYBYTES = module2.exports.KEYBYTES = 32;
    var SALTBYTES = module2.exports.SALTBYTES = 16;
    var PERSONALBYTES = module2.exports.PERSONALBYTES = 16;
    function Blake2b16(digestLength, key, salt, personal, noAssert) {
      if (!(this instanceof Blake2b16))
        return new Blake2b16(digestLength, key, salt, personal, noAssert);
      if (!wasm)
        throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");
      if (!digestLength)
        digestLength = 32;
      if (noAssert !== true) {
        assert(digestLength >= BYTES_MIN, "digestLength must be at least " + BYTES_MIN + ", was given " + digestLength);
        assert(digestLength <= BYTES_MAX, "digestLength must be at most " + BYTES_MAX + ", was given " + digestLength);
        if (key != null) {
          assert(key instanceof Uint8Array, "key must be Uint8Array or Buffer");
          assert(key.length >= KEYBYTES_MIN, "key must be at least " + KEYBYTES_MIN + ", was given " + key.length);
          assert(key.length <= KEYBYTES_MAX, "key must be at least " + KEYBYTES_MAX + ", was given " + key.length);
        }
        if (salt != null) {
          assert(salt instanceof Uint8Array, "salt must be Uint8Array or Buffer");
          assert(salt.length === SALTBYTES, "salt must be exactly " + SALTBYTES + ", was given " + salt.length);
        }
        if (personal != null) {
          assert(personal instanceof Uint8Array, "personal must be Uint8Array or Buffer");
          assert(personal.length === PERSONALBYTES, "personal must be exactly " + PERSONALBYTES + ", was given " + personal.length);
        }
      }
      if (!freeList.length) {
        freeList.push(head);
        head += 216;
      }
      this.digestLength = digestLength;
      this.finalized = false;
      this.pointer = freeList.pop();
      this._memory = new Uint8Array(wasm.memory.buffer);
      this._memory.fill(0, 0, 64);
      this._memory[0] = this.digestLength;
      this._memory[1] = key ? key.length : 0;
      this._memory[2] = 1;
      this._memory[3] = 1;
      if (salt)
        this._memory.set(salt, 32);
      if (personal)
        this._memory.set(personal, 48);
      if (this.pointer + 216 > this._memory.length)
        this._realloc(this.pointer + 216);
      wasm.blake2b_init(this.pointer, this.digestLength);
      if (key) {
        this.update(key);
        this._memory.fill(0, head, head + key.length);
        this._memory[this.pointer + 200] = 128;
      }
    }
    Blake2b16.prototype._realloc = function(size) {
      wasm.memory.grow(Math.max(0, Math.ceil(Math.abs(size - this._memory.length) / 65536)));
      this._memory = new Uint8Array(wasm.memory.buffer);
    };
    Blake2b16.prototype.update = function(input) {
      assert(this.finalized === false, "Hash instance finalized");
      assert(input instanceof Uint8Array, "input must be Uint8Array or Buffer");
      if (head + input.length > this._memory.length)
        this._realloc(head + input.length);
      this._memory.set(input, head);
      wasm.blake2b_update(this.pointer, head, head + input.length);
      return this;
    };
    Blake2b16.prototype.digest = function(enc) {
      assert(this.finalized === false, "Hash instance finalized");
      this.finalized = true;
      freeList.push(this.pointer);
      wasm.blake2b_final(this.pointer);
      if (!enc || enc === "binary") {
        return this._memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
      }
      if (typeof enc === "string") {
        return b4a.toString(this._memory, enc, this.pointer + 128, this.pointer + 128 + this.digestLength);
      }
      assert(enc instanceof Uint8Array && enc.length >= this.digestLength, "input must be Uint8Array or Buffer");
      for (var i = 0; i < this.digestLength; i++) {
        enc[i] = this._memory[this.pointer + 128 + i];
      }
      return enc;
    };
    Blake2b16.prototype.final = Blake2b16.prototype.digest;
    Blake2b16.WASM = wasm;
    Blake2b16.SUPPORTED = typeof WebAssembly !== "undefined";
    Blake2b16.ready = function(cb) {
      if (!cb)
        cb = noop2;
      if (!wasmPromise)
        return cb(new Error("WebAssembly not supported"));
      return wasmPromise.then(() => cb(), cb);
    };
    Blake2b16.prototype.ready = Blake2b16.ready;
    Blake2b16.prototype.getPartialHash = function() {
      return this._memory.slice(this.pointer, this.pointer + 216);
    };
    Blake2b16.prototype.setPartialHash = function(ph) {
      this._memory.set(ph, this.pointer);
    };
    function noop2() {
    }
  }
});

// ../../node_modules/wasmcurves/src/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/wasmcurves/src/utils.js"(exports) {
    "use strict";
    exports.bigInt2BytesLE = function bigInt2BytesLE(_a, len) {
      const b = Array(len);
      let v = BigInt(_a);
      for (let i = 0; i < len; i++) {
        b[i] = Number(v & 0xFFn);
        v = v >> 8n;
      }
      return b;
    };
    exports.bigInt2U32LE = function bigInt2BytesLE(_a, len) {
      const b = Array(len);
      let v = BigInt(_a);
      for (let i = 0; i < len; i++) {
        b[i] = Number(v & 0xFFFFFFFFn);
        v = v >> 32n;
      }
      return b;
    };
    exports.isOcamNum = function(a) {
      if (!Array.isArray(a))
        return false;
      if (a.length != 3)
        return false;
      if (typeof a[0] !== "number")
        return false;
      if (typeof a[1] !== "number")
        return false;
      if (!Array.isArray(a[2]))
        return false;
      return true;
    };
  }
});

// ../../node_modules/wasmcurves/src/build_int.js
var require_build_int3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_int.js"(exports, module2) {
    "use strict";
    module2.exports = function buildInt(module3, n64, _prefix) {
      const prefix = _prefix || "int";
      if (module3.modules[prefix])
        return prefix;
      module3.modules[prefix] = {};
      const n32 = n64 * 2;
      const n8 = n64 * 8;
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("px", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pr"),
              i * 8,
              c.i64_load(
                c.getLocal("px"),
                i * 8
              )
            )
          );
        }
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pr"),
              i * 8,
              c.i64_const(0)
            )
          );
        }
      }
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.i64_store(
            c.getLocal("pr"),
            0,
            c.i64_const(1)
          )
        );
        for (let i = 1; i < n64; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pr"),
              i * 8,
              c.i64_const(0)
            )
          );
        }
      }
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("px", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c.ret(c.i64_eqz(
              c.i64_load(c.getLocal("px"))
            ));
          }
          return c.if(
            c.i64_eqz(
              c.i64_load(c.getLocal("px"), n * 8)
            ),
            getCompCode(n - 1),
            c.ret(c.i32_const(0))
          );
        }
        f.addCode(getCompCode(n64 - 1));
        f.addCode(c.ret(c.i32_const(0)));
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("px", "i32");
        f.addParam("py", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c.ret(c.i64_eq(
              c.i64_load(c.getLocal("px")),
              c.i64_load(c.getLocal("py"))
            ));
          }
          return c.if(
            c.i64_eq(
              c.i64_load(c.getLocal("px"), n * 8),
              c.i64_load(c.getLocal("py"), n * 8)
            ),
            getCompCode(n - 1),
            c.ret(c.i32_const(0))
          );
        }
        f.addCode(getCompCode(n64 - 1));
        f.addCode(c.ret(c.i32_const(0)));
      }
      function buildGte() {
        const f = module3.addFunction(prefix + "_gte");
        f.addParam("px", "i32");
        f.addParam("py", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c.ret(c.i64_ge_u(
              c.i64_load(c.getLocal("px")),
              c.i64_load(c.getLocal("py"))
            ));
          }
          return c.if(
            c.i64_lt_u(
              c.i64_load(c.getLocal("px"), n * 8),
              c.i64_load(c.getLocal("py"), n * 8)
            ),
            c.ret(c.i32_const(0)),
            c.if(
              c.i64_gt_u(
                c.i64_load(c.getLocal("px"), n * 8),
                c.i64_load(c.getLocal("py"), n * 8)
              ),
              c.ret(c.i32_const(1)),
              getCompCode(n - 1)
            )
          );
        }
        f.addCode(getCompCode(n64 - 1));
        f.addCode(c.ret(c.i32_const(0)));
      }
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.setReturnType("i32");
        f.addLocal("c", "i64");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal(
          "c",
          c.i64_add(
            c.i64_load32_u(c.getLocal("x")),
            c.i64_load32_u(c.getLocal("y"))
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("r"),
          c.getLocal("c")
        ));
        for (let i = 1; i < n32; i++) {
          f.addCode(c.setLocal(
            "c",
            c.i64_add(
              c.i64_add(
                c.i64_load32_u(c.getLocal("x"), 4 * i),
                c.i64_load32_u(c.getLocal("y"), 4 * i)
              ),
              c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
            )
          ));
          f.addCode(c.i64_store32(
            c.getLocal("r"),
            i * 4,
            c.getLocal("c")
          ));
        }
        f.addCode(c.i32_wrap_i64(c.i64_shr_u(c.getLocal("c"), c.i64_const(32))));
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.setReturnType("i32");
        f.addLocal("c", "i64");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal(
          "c",
          c.i64_sub(
            c.i64_load32_u(c.getLocal("x")),
            c.i64_load32_u(c.getLocal("y"))
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("r"),
          c.i64_and(
            c.getLocal("c"),
            c.i64_const("0xFFFFFFFF")
          )
        ));
        for (let i = 1; i < n32; i++) {
          f.addCode(c.setLocal(
            "c",
            c.i64_add(
              c.i64_sub(
                c.i64_load32_u(c.getLocal("x"), 4 * i),
                c.i64_load32_u(c.getLocal("y"), 4 * i)
              ),
              c.i64_shr_s(c.getLocal("c"), c.i64_const(32))
            )
          ));
          f.addCode(c.i64_store32(
            c.getLocal("r"),
            i * 4,
            c.i64_and(c.getLocal("c"), c.i64_const("0xFFFFFFFF"))
          ));
        }
        f.addCode(c.i32_wrap_i64(c.i64_shr_s(c.getLocal("c"), c.i64_const(32))));
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
          f.addLocal("y" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const loadX = [];
        const loadY = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadY[j]) {
            Y = c.teeLocal("y" + j, c.i64_load32_u(c.getLocal("y"), j * 4));
            loadY[j] = true;
          } else {
            Y = c.getLocal("y" + j);
          }
          return c.i64_mul(X, Y);
        }
        let c0 = "c0";
        let c1 = "c1";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          for (let i = Math.max(0, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          f.addCode(
            c.i64_store32(
              c.getLocal("r"),
              k * 4,
              c.getLocal(c0)
            )
          );
          [c0, c1] = [c1, c0];
          f.addCode(
            c.setLocal(
              c1,
              c.i64_shr_u(
                c.getLocal(c0),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 * 2 - 4,
            c.getLocal(c0)
          )
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        f.addLocal("c0_old", "i64");
        f.addLocal("c1_old", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const loadX = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadX[j]) {
            Y = c.teeLocal("x" + j, c.i64_load32_u(c.getLocal("x"), j * 4));
            loadX[j] = true;
          } else {
            Y = c.getLocal("x" + j);
          }
          return c.i64_mul(X, Y);
        }
        let c0 = "c0";
        let c1 = "c1";
        let c0_old = "c0_old";
        let c1_old = "c1_old";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          f.addCode(
            c.setLocal(c0, c.i64_const(0)),
            c.setLocal(c1, c.i64_const(0))
          );
          for (let i = Math.max(0, k - n32 + 1); i < k + 1 >> 1 && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          f.addCode(
            c.setLocal(
              c0,
              c.i64_shl(
                c.i64_and(
                  c.getLocal(c0),
                  c.i64_const(4294967295)
                ),
                c.i64_const(1)
              )
            )
          );
          f.addCode(
            c.setLocal(
              c1,
              c.i64_add(
                c.i64_shl(
                  c.getLocal(c1),
                  c.i64_const(1)
                ),
                c.i64_shr_u(
                  c.getLocal(c0),
                  c.i64_const(32)
                )
              )
            )
          );
          if (k % 2 == 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(k >> 1, k >> 1)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k > 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  c.i64_and(
                    c.getLocal(c0_old),
                    c.i64_const(4294967295)
                  )
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.i64_add(
                    c.getLocal(c1),
                    c.i64_shr_u(
                      c.getLocal(c0),
                      c.i64_const(32)
                    )
                  ),
                  c.getLocal(c1_old)
                )
              )
            );
          }
          f.addCode(
            c.i64_store32(
              c.getLocal("r"),
              k * 4,
              c.getLocal(c0)
            )
          );
          f.addCode(
            c.setLocal(
              c0_old,
              c.getLocal(c1)
            ),
            c.setLocal(
              c1_old,
              c.i64_shr_u(
                c.getLocal(c0_old),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 * 2 - 4,
            c.getLocal(c0_old)
          )
        );
      }
      function buildSquareOld() {
        const f = module3.addFunction(prefix + "_squareOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.getLocal("x"), c.getLocal("r")));
      }
      function _buildMul1() {
        const f = module3.addFunction(prefix + "__mul1");
        f.addParam("px", "i32");
        f.addParam("y", "i64");
        f.addParam("pr", "i32");
        f.addLocal("c", "i64");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal(
          "c",
          c.i64_mul(
            c.i64_load32_u(c.getLocal("px"), 0, 0),
            c.getLocal("y")
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("pr"),
          0,
          0,
          c.getLocal("c")
        ));
        for (let i = 1; i < n32; i++) {
          f.addCode(c.setLocal(
            "c",
            c.i64_add(
              c.i64_mul(
                c.i64_load32_u(c.getLocal("px"), 4 * i, 0),
                c.getLocal("y")
              ),
              c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
            )
          ));
          f.addCode(c.i64_store32(
            c.getLocal("pr"),
            i * 4,
            0,
            c.getLocal("c")
          ));
        }
      }
      function _buildAdd1() {
        const f = module3.addFunction(prefix + "__add1");
        f.addParam("x", "i32");
        f.addParam("y", "i64");
        f.addLocal("c", "i64");
        f.addLocal("px", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.setLocal("px", c.getLocal("x")));
        f.addCode(c.setLocal(
          "c",
          c.i64_add(
            c.i64_load32_u(c.getLocal("px"), 0, 0),
            c.getLocal("y")
          )
        ));
        f.addCode(c.i64_store32(
          c.getLocal("px"),
          0,
          0,
          c.getLocal("c")
        ));
        f.addCode(c.setLocal(
          "c",
          c.i64_shr_u(
            c.getLocal("c"),
            c.i64_const(32)
          )
        ));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.i64_eqz(c.getLocal("c"))
          ),
          c.setLocal(
            "px",
            c.i32_add(
              c.getLocal("px"),
              c.i32_const(4)
            )
          ),
          c.setLocal(
            "c",
            c.i64_add(
              c.i64_load32_u(c.getLocal("px"), 0, 0),
              c.getLocal("c")
            )
          ),
          c.i64_store32(
            c.getLocal("px"),
            0,
            0,
            c.getLocal("c")
          ),
          c.setLocal(
            "c",
            c.i64_shr_u(
              c.getLocal("c"),
              c.i64_const(32)
            )
          ),
          c.br(0)
        )));
      }
      function buildDiv() {
        _buildMul1();
        _buildAdd1();
        const f = module3.addFunction(prefix + "_div");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("c", "i32");
        f.addParam("r", "i32");
        f.addLocal("rr", "i32");
        f.addLocal("cc", "i32");
        f.addLocal("eX", "i32");
        f.addLocal("eY", "i32");
        f.addLocal("sy", "i64");
        f.addLocal("sx", "i64");
        f.addLocal("ec", "i32");
        const c = f.getCodeBuilder();
        const Y = c.i32_const(module3.alloc(n8));
        const Caux = c.i32_const(module3.alloc(n8));
        const Raux = c.i32_const(module3.alloc(n8));
        const C = c.getLocal("cc");
        const R = c.getLocal("rr");
        const pr1 = module3.alloc(n8 * 2);
        const R1 = c.i32_const(pr1);
        const R2 = c.i32_const(pr1 + n8);
        f.addCode(c.if(
          c.getLocal("c"),
          c.setLocal("cc", c.getLocal("c")),
          c.setLocal("cc", Caux)
        ));
        f.addCode(c.if(
          c.getLocal("r"),
          c.setLocal("rr", c.getLocal("r")),
          c.setLocal("rr", Raux)
        ));
        f.addCode(c.call(prefix + "_copy", c.getLocal("x"), R));
        f.addCode(c.call(prefix + "_copy", c.getLocal("y"), Y));
        f.addCode(c.call(prefix + "_zero", C));
        f.addCode(c.call(prefix + "_zero", R1));
        f.addCode(c.setLocal("eX", c.i32_const(n8 - 1)));
        f.addCode(c.setLocal("eY", c.i32_const(n8 - 1)));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.i32_or(
              c.i32_load8_u(
                c.i32_add(Y, c.getLocal("eY")),
                0,
                0
              ),
              c.i32_eq(
                c.getLocal("eY"),
                c.i32_const(3)
              )
            )
          ),
          c.setLocal("eY", c.i32_sub(c.getLocal("eY"), c.i32_const(1))),
          c.br(0)
        )));
        f.addCode(
          c.setLocal(
            "sy",
            c.i64_add(
              c.i64_load32_u(
                c.i32_sub(
                  c.i32_add(Y, c.getLocal("eY")),
                  c.i32_const(3)
                ),
                0,
                0
              ),
              c.i64_const(1)
            )
          )
        );
        f.addCode(
          c.if(
            c.i64_eq(
              c.getLocal("sy"),
              c.i64_const(1)
            ),
            c.drop(c.i64_div_u(c.i64_const(0), c.i64_const(0)))
          )
        );
        f.addCode(c.block(c.loop(
          // while (eX>7)&&(Y[eX]==0) ex--;
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_or(
                c.i32_load8_u(
                  c.i32_add(R, c.getLocal("eX")),
                  0,
                  0
                ),
                c.i32_eq(
                  c.getLocal("eX"),
                  c.i32_const(7)
                )
              )
            ),
            c.setLocal("eX", c.i32_sub(c.getLocal("eX"), c.i32_const(1))),
            c.br(0)
          )),
          c.setLocal(
            "sx",
            c.i64_load(
              c.i32_sub(
                c.i32_add(R, c.getLocal("eX")),
                c.i32_const(7)
              ),
              0,
              0
            )
          ),
          c.setLocal(
            "sx",
            c.i64_div_u(
              c.getLocal("sx"),
              c.getLocal("sy")
            )
          ),
          c.setLocal(
            "ec",
            c.i32_sub(
              c.i32_sub(
                c.getLocal("eX"),
                c.getLocal("eY")
              ),
              c.i32_const(4)
            )
          ),
          // While greater than 32 bits or ec is neg, shr and inc exp
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_and(
                c.i64_eqz(
                  c.i64_and(
                    c.getLocal("sx"),
                    c.i64_const("0xFFFFFFFF00000000")
                  )
                ),
                c.i32_ge_s(
                  c.getLocal("ec"),
                  c.i32_const(0)
                )
              )
            ),
            c.setLocal(
              "sx",
              c.i64_shr_u(
                c.getLocal("sx"),
                c.i64_const(8)
              )
            ),
            c.setLocal(
              "ec",
              c.i32_add(
                c.getLocal("ec"),
                c.i32_const(1)
              )
            ),
            c.br(0)
          )),
          c.if(
            c.i64_eqz(c.getLocal("sx")),
            [
              ...c.br_if(
                2,
                c.i32_eqz(c.call(prefix + "_gte", R, Y))
              ),
              ...c.setLocal("sx", c.i64_const(1)),
              ...c.setLocal("ec", c.i32_const(0))
            ]
          ),
          c.call(prefix + "__mul1", Y, c.getLocal("sx"), R2),
          c.drop(c.call(
            prefix + "_sub",
            R,
            c.i32_sub(R2, c.getLocal("ec")),
            R
          )),
          c.call(
            prefix + "__add1",
            c.i32_add(C, c.getLocal("ec")),
            c.getLocal("sx")
          ),
          c.br(0)
        )));
      }
      function buildInverseMod() {
        const f = module3.addFunction(prefix + "_inverseMod");
        f.addParam("px", "i32");
        f.addParam("pm", "i32");
        f.addParam("pr", "i32");
        f.addLocal("t", "i32");
        f.addLocal("newt", "i32");
        f.addLocal("r", "i32");
        f.addLocal("qq", "i32");
        f.addLocal("qr", "i32");
        f.addLocal("newr", "i32");
        f.addLocal("swp", "i32");
        f.addLocal("x", "i32");
        f.addLocal("signt", "i32");
        f.addLocal("signnewt", "i32");
        f.addLocal("signx", "i32");
        const c = f.getCodeBuilder();
        const aux1 = c.i32_const(module3.alloc(n8));
        const aux2 = c.i32_const(module3.alloc(n8));
        const aux3 = c.i32_const(module3.alloc(n8));
        const aux4 = c.i32_const(module3.alloc(n8));
        const aux5 = c.i32_const(module3.alloc(n8));
        const aux6 = c.i32_const(module3.alloc(n8));
        const mulBuff = c.i32_const(module3.alloc(n8 * 2));
        const aux7 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("t", aux1),
          c.call(prefix + "_zero", aux1),
          c.setLocal("signt", c.i32_const(0))
        );
        f.addCode(
          c.setLocal("r", aux2),
          c.call(prefix + "_copy", c.getLocal("pm"), aux2)
        );
        f.addCode(
          c.setLocal("newt", aux3),
          c.call(prefix + "_one", aux3),
          c.setLocal("signnewt", c.i32_const(0))
        );
        f.addCode(
          c.setLocal("newr", aux4),
          c.call(prefix + "_copy", c.getLocal("px"), aux4)
        );
        f.addCode(c.setLocal("qq", aux5));
        f.addCode(c.setLocal("qr", aux6));
        f.addCode(c.setLocal("x", aux7));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.call(prefix + "_isZero", c.getLocal("newr"))
          ),
          c.call(prefix + "_div", c.getLocal("r"), c.getLocal("newr"), c.getLocal("qq"), c.getLocal("qr")),
          c.call(prefix + "_mul", c.getLocal("qq"), c.getLocal("newt"), mulBuff),
          c.if(
            c.getLocal("signt"),
            c.if(
              c.getLocal("signnewt"),
              c.if(
                c.call(prefix + "_gte", mulBuff, c.getLocal("t")),
                [
                  ...c.drop(c.call(prefix + "_sub", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(0))
                ],
                [
                  ...c.drop(c.call(prefix + "_sub", c.getLocal("t"), mulBuff, c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(1))
                ]
              ),
              [
                ...c.drop(c.call(prefix + "_add", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                ...c.setLocal("signx", c.i32_const(1))
              ]
            ),
            c.if(
              c.getLocal("signnewt"),
              [
                ...c.drop(c.call(prefix + "_add", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                ...c.setLocal("signx", c.i32_const(0))
              ],
              c.if(
                c.call(prefix + "_gte", c.getLocal("t"), mulBuff),
                [
                  ...c.drop(c.call(prefix + "_sub", c.getLocal("t"), mulBuff, c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(0))
                ],
                [
                  ...c.drop(c.call(prefix + "_sub", mulBuff, c.getLocal("t"), c.getLocal("x"))),
                  ...c.setLocal("signx", c.i32_const(1))
                ]
              )
            )
          ),
          c.setLocal("swp", c.getLocal("t")),
          c.setLocal("t", c.getLocal("newt")),
          c.setLocal("newt", c.getLocal("x")),
          c.setLocal("x", c.getLocal("swp")),
          c.setLocal("signt", c.getLocal("signnewt")),
          c.setLocal("signnewt", c.getLocal("signx")),
          c.setLocal("swp", c.getLocal("r")),
          c.setLocal("r", c.getLocal("newr")),
          c.setLocal("newr", c.getLocal("qr")),
          c.setLocal("qr", c.getLocal("swp")),
          c.br(0)
        )));
        f.addCode(c.if(
          c.getLocal("signt"),
          c.drop(c.call(prefix + "_sub", c.getLocal("pm"), c.getLocal("t"), c.getLocal("pr"))),
          c.call(prefix + "_copy", c.getLocal("t"), c.getLocal("pr"))
        ));
      }
      buildCopy();
      buildZero();
      buildIsZero();
      buildOne();
      buildEq();
      buildGte();
      buildAdd();
      buildSub();
      buildMul();
      buildSquare();
      buildSquareOld();
      buildDiv();
      buildInverseMod();
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_gte");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_squareOld");
      module3.exportFunction(prefix + "_div");
      module3.exportFunction(prefix + "_inverseMod");
      return prefix;
    };
  }
});

// ../../node_modules/wasmcurves/src/build_timesscalar.js
var require_build_timesscalar3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_timesscalar.js"(exports, module2) {
    "use strict";
    module2.exports = function buildTimesScalar(module3, fnName, elementLen, opAB, opAA, opCopy, opInit) {
      const f = module3.addFunction(fnName);
      f.addParam("base", "i32");
      f.addParam("scalar", "i32");
      f.addParam("scalarLength", "i32");
      f.addParam("r", "i32");
      f.addLocal("i", "i32");
      f.addLocal("b", "i32");
      const c = f.getCodeBuilder();
      const aux = c.i32_const(module3.alloc(elementLen));
      f.addCode(
        c.if(
          c.i32_eqz(c.getLocal("scalarLength")),
          [
            ...c.call(opInit, c.getLocal("r")),
            ...c.ret([])
          ]
        )
      );
      f.addCode(c.call(opCopy, c.getLocal("base"), aux));
      f.addCode(c.call(opInit, c.getLocal("r")));
      f.addCode(c.setLocal("i", c.getLocal("scalarLength")));
      f.addCode(c.block(c.loop(
        c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
        c.setLocal(
          "b",
          c.i32_load8_u(
            c.i32_add(
              c.getLocal("scalar"),
              c.getLocal("i")
            )
          )
        ),
        ...innerLoop(),
        c.br_if(1, c.i32_eqz(c.getLocal("i"))),
        c.br(0)
      )));
      function innerLoop() {
        const code = [];
        for (let i = 0; i < 8; i++) {
          code.push(
            ...c.call(opAA, c.getLocal("r"), c.getLocal("r")),
            ...c.if(
              c.i32_ge_u(c.getLocal("b"), c.i32_const(128 >> i)),
              [
                ...c.setLocal(
                  "b",
                  c.i32_sub(
                    c.getLocal("b"),
                    c.i32_const(128 >> i)
                  )
                ),
                ...c.call(opAB, c.getLocal("r"), aux, c.getLocal("r"))
              ]
            )
          );
        }
        return code;
      }
    };
  }
});

// ../../node_modules/wasmcurves/src/build_batchinverse.js
var require_build_batchinverse3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_batchinverse.js"(exports, module2) {
    "use strict";
    module2.exports = buildBatchInverse;
    function buildBatchInverse(module3, prefix) {
      const n8 = module3.modules[prefix].n64 * 8;
      const f = module3.addFunction(prefix + "_batchInverse");
      f.addParam("pIn", "i32");
      f.addParam("inStep", "i32");
      f.addParam("n", "i32");
      f.addParam("pOut", "i32");
      f.addParam("outStep", "i32");
      f.addLocal("itAux", "i32");
      f.addLocal("itIn", "i32");
      f.addLocal("itOut", "i32");
      f.addLocal("i", "i32");
      const c = f.getCodeBuilder();
      const AUX = c.i32_const(module3.alloc(n8));
      f.addCode(
        c.setLocal("itAux", c.i32_load(c.i32_const(0))),
        c.i32_store(
          c.i32_const(0),
          c.i32_add(
            c.getLocal("itAux"),
            c.i32_mul(
              c.i32_add(
                c.getLocal("n"),
                c.i32_const(1)
              ),
              c.i32_const(n8)
            )
          )
        )
      );
      f.addCode(
        // aux[0] = a;
        c.call(prefix + "_one", c.getLocal("itAux")),
        // for (i=0;i<n;i++) aux[i] = aux[i-1]*in[i]
        c.setLocal("itIn", c.getLocal("pIn")),
        c.setLocal("itAux", c.i32_add(c.getLocal("itAux"), c.i32_const(n8))),
        c.setLocal("i", c.i32_const(0)),
        c.block(c.loop(
          c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("itIn")),
            c.call(
              prefix + "_copy",
              c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)),
              c.getLocal("itAux")
            ),
            c.call(
              prefix + "_mul",
              c.getLocal("itIn"),
              c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)),
              c.getLocal("itAux")
            )
          ),
          c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.getLocal("inStep"))),
          c.setLocal("itAux", c.i32_add(c.getLocal("itAux"), c.i32_const(n8))),
          c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        )),
        // point to the last
        c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.getLocal("inStep"))),
        c.setLocal("itAux", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))),
        // itOut = pOut + (n-1)*stepOut   // Point to the last
        c.setLocal(
          "itOut",
          c.i32_add(
            c.getLocal("pOut"),
            c.i32_mul(
              c.i32_sub(c.getLocal("n"), c.i32_const(1)),
              c.getLocal("outStep")
            )
          )
        ),
        // aux[n-1] = 1/aux[n-1]
        c.call(prefix + "_inverse", c.getLocal("itAux"), c.getLocal("itAux")),
        c.block(c.loop(
          c.br_if(1, c.i32_eqz(c.getLocal("i"))),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("itIn")),
            [
              ...c.call(
                prefix + "_copy",
                c.getLocal("itAux"),
                c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))
              ),
              ...c.call(
                prefix + "_zero",
                c.getLocal("itOut")
              )
            ],
            [
              ...c.call(prefix + "_copy", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)), AUX),
              ...c.call(
                prefix + "_mul",
                c.getLocal("itAux"),
                c.getLocal("itIn"),
                c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))
              ),
              ...c.call(
                prefix + "_mul",
                c.getLocal("itAux"),
                AUX,
                c.getLocal("itOut")
              )
            ]
          ),
          c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.getLocal("inStep"))),
          c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.getLocal("outStep"))),
          c.setLocal("itAux", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))),
          c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        ))
      );
      f.addCode(
        c.i32_store(
          c.i32_const(0),
          c.getLocal("itAux")
        )
      );
    }
  }
});

// ../../node_modules/wasmcurves/src/build_batchconvertion.js
var require_build_batchconvertion3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_batchconvertion.js"(exports, module2) {
    "use strict";
    module2.exports = buildBatchConvertion;
    function buildBatchConvertion(module3, fnName, internalFnName, sizeIn, sizeOut, reverse) {
      if (typeof reverse === "undefined") {
        if (sizeIn < sizeOut) {
          reverse = true;
        } else {
          reverse = false;
        }
      }
      const f = module3.addFunction(fnName);
      f.addParam("pIn", "i32");
      f.addParam("n", "i32");
      f.addParam("pOut", "i32");
      f.addLocal("i", "i32");
      f.addLocal("itIn", "i32");
      f.addLocal("itOut", "i32");
      const c = f.getCodeBuilder();
      if (reverse) {
        f.addCode(
          c.setLocal(
            "itIn",
            c.i32_add(
              c.getLocal("pIn"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeIn)
              )
            )
          ),
          c.setLocal(
            "itOut",
            c.i32_add(
              c.getLocal("pOut"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeOut)
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn"), c.getLocal("itOut")),
            c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      } else {
        f.addCode(
          c.setLocal("itIn", c.getLocal("pIn")),
          c.setLocal("itOut", c.getLocal("pOut")),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn"), c.getLocal("itOut")),
            c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_add(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
    }
  }
});

// ../../node_modules/wasmcurves/src/build_batchop.js
var require_build_batchop3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_batchop.js"(exports, module2) {
    "use strict";
    module2.exports = buildBatchConvertion;
    function buildBatchConvertion(module3, fnName, internalFnName, sizeIn, sizeOut, reverse) {
      if (typeof reverse === "undefined") {
        if (sizeIn < sizeOut) {
          reverse = true;
        } else {
          reverse = false;
        }
      }
      const f = module3.addFunction(fnName);
      f.addParam("pIn1", "i32");
      f.addParam("pIn2", "i32");
      f.addParam("n", "i32");
      f.addParam("pOut", "i32");
      f.addLocal("i", "i32");
      f.addLocal("itIn1", "i32");
      f.addLocal("itIn2", "i32");
      f.addLocal("itOut", "i32");
      const c = f.getCodeBuilder();
      if (reverse) {
        f.addCode(
          c.setLocal(
            "itIn1",
            c.i32_add(
              c.getLocal("pIn1"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeIn)
              )
            )
          ),
          c.setLocal(
            "itIn2",
            c.i32_add(
              c.getLocal("pIn2"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeIn)
              )
            )
          ),
          c.setLocal(
            "itOut",
            c.i32_add(
              c.getLocal("pOut"),
              c.i32_mul(
                c.i32_sub(
                  c.getLocal("n"),
                  c.i32_const(1)
                ),
                c.i32_const(sizeOut)
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn1"), c.getLocal("itIn2"), c.getLocal("itOut")),
            c.setLocal("itIn1", c.i32_sub(c.getLocal("itIn1"), c.i32_const(sizeIn))),
            c.setLocal("itIn2", c.i32_sub(c.getLocal("itIn2"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      } else {
        f.addCode(
          c.setLocal("itIn1", c.getLocal("pIn1")),
          c.setLocal("itIn2", c.getLocal("pIn2")),
          c.setLocal("itOut", c.getLocal("pOut")),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.call(internalFnName, c.getLocal("itIn1"), c.getLocal("itIn2"), c.getLocal("itOut")),
            c.setLocal("itIn1", c.i32_add(c.getLocal("itIn1"), c.i32_const(sizeIn))),
            c.setLocal("itIn2", c.i32_add(c.getLocal("itIn2"), c.i32_const(sizeIn))),
            c.setLocal("itOut", c.i32_add(c.getLocal("itOut"), c.i32_const(sizeOut))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
    }
  }
});

// ../../node_modules/wasmcurves/src/bigint.js
var require_bigint3 = __commonJS({
  "../../node_modules/wasmcurves/src/bigint.js"(exports, module2) {
    "use strict";
    function compare(a, b) {
      return a === b ? 0 : a > b ? 1 : -1;
    }
    function square4(n) {
      return n * n;
    }
    function isOdd4(n) {
      return n % 2n !== 0n;
    }
    function isEven(n) {
      return n % 2n === 0n;
    }
    function isNegative5(n) {
      return n < 0n;
    }
    function isPositive(n) {
      return n > 0n;
    }
    function bitLength5(n) {
      if (isNegative5(n)) {
        return n.toString(2).length - 1;
      } else {
        return n.toString(2).length;
      }
    }
    function abs4(n) {
      return n < 0n ? -n : n;
    }
    function isUnit(n) {
      return abs4(n) === 1n;
    }
    function modInv(a, n) {
      var t = 0n, newT = 1n, r = n, newR = abs4(a), q, lastT, lastR;
      while (newR !== 0n) {
        q = r / newR;
        lastT = t;
        lastR = r;
        t = newT;
        r = newR;
        newT = lastT - q * newT;
        newR = lastR - q * newR;
      }
      if (!isUnit(r))
        throw new Error(a.toString() + " and " + n.toString() + " are not co-prime");
      if (compare(t, 0n) === -1) {
        t = t + n;
      }
      if (isNegative5(a)) {
        return -t;
      }
      return t;
    }
    function modPow(n, exp7, mod4) {
      if (mod4 === 0n)
        throw new Error("Cannot take modPow with modulus 0");
      var r = 1n, base = n % mod4;
      if (isNegative5(exp7)) {
        exp7 = exp7 * -1n;
        base = modInv(base, mod4);
      }
      while (isPositive(exp7)) {
        if (base === 0n)
          return 0n;
        if (isOdd4(exp7))
          r = r * base % mod4;
        exp7 = exp7 / 2n;
        base = square4(base) % mod4;
      }
      return r;
    }
    function compareAbs(a, b) {
      a = a >= 0n ? a : -a;
      b = b >= 0n ? b : -b;
      return a === b ? 0 : a > b ? 1 : -1;
    }
    function isDivisibleBy(a, n) {
      if (n === 0n)
        return false;
      if (isUnit(n))
        return true;
      if (compareAbs(n, 2n) === 0)
        return isEven(a);
      return a % n === 0n;
    }
    function isBasicPrime(v) {
      var n = abs4(v);
      if (isUnit(n))
        return false;
      if (n === 2n || n === 3n || n === 5n)
        return true;
      if (isEven(n) || isDivisibleBy(n, 3n) || isDivisibleBy(n, 5n))
        return false;
      if (n < 49n)
        return true;
    }
    function prev(n) {
      return n - 1n;
    }
    function millerRabinTest(n, a) {
      var nPrev = prev(n), b = nPrev, r = 0, d, i, x;
      while (isEven(b))
        b = b / 2n, r++;
      next:
        for (i = 0; i < a.length; i++) {
          if (n < a[i])
            continue;
          x = modPow(BigInt(a[i]), b, n);
          if (isUnit(x) || x === nPrev)
            continue;
          for (d = r - 1; d != 0; d--) {
            x = square4(x) % n;
            if (isUnit(x))
              return false;
            if (x === nPrev)
              continue next;
          }
          return false;
        }
      return true;
    }
    function isPrime(p) {
      var isPrime2 = isBasicPrime(p);
      if (isPrime2 !== void 0)
        return isPrime2;
      var n = abs4(p);
      var bits4 = bitLength5(n);
      if (bits4 <= 64)
        return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
      var logN = Math.log(2) * Number(bits4);
      var t = Math.ceil(logN);
      for (var a = [], i = 0; i < t; i++) {
        a.push(BigInt(i + 2));
      }
      return millerRabinTest(n, a);
    }
    module2.exports.bitLength = bitLength5;
    module2.exports.isOdd = isOdd4;
    module2.exports.isNegative = isNegative5;
    module2.exports.abs = abs4;
    module2.exports.isUnit = isUnit;
    module2.exports.compare = compare;
    module2.exports.modInv = modInv;
    module2.exports.modPow = modPow;
    module2.exports.isPrime = isPrime;
    module2.exports.square = square4;
  }
});

// ../../node_modules/wasmcurves/src/build_f1m.js
var require_build_f1m3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_f1m.js"(exports, module2) {
    "use strict";
    var buildInt = require_build_int3();
    var utils2 = require_utils3();
    var buildExp = require_build_timesscalar3();
    var buildBatchInverse = require_build_batchinverse3();
    var buildBatchConvertion = require_build_batchconvertion3();
    var buildBatchOp = require_build_batchop3();
    var { bitLength: bitLength5, modInv, modPow, isPrime, isOdd: isOdd4, square: square4 } = require_bigint3();
    module2.exports = function buildF1m(module3, _q, _prefix, _intPrefix) {
      const q = BigInt(_q);
      const n64 = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n32 = n64 * 2;
      const n8 = n64 * 8;
      const prefix = _prefix || "f1m";
      if (module3.modules[prefix])
        return prefix;
      const intPrefix = buildInt(module3, n64, _intPrefix);
      const pq = module3.alloc(n8, utils2.bigInt2BytesLE(q, n8));
      const pR2 = module3.alloc(utils2.bigInt2BytesLE(square4(1n << BigInt(n64 * 64)) % q, n8));
      const pOne = module3.alloc(utils2.bigInt2BytesLE((1n << BigInt(n64 * 64)) % q, n8));
      const pZero = module3.alloc(utils2.bigInt2BytesLE(0n, n8));
      const _minusOne = q - 1n;
      const _e = _minusOne >> 1n;
      const pe = module3.alloc(n8, utils2.bigInt2BytesLE(_e, n8));
      const _ePlusOne = _e + 1n;
      const pePlusOne = module3.alloc(n8, utils2.bigInt2BytesLE(_ePlusOne, n8));
      module3.modules[prefix] = {
        pq,
        pR2,
        n64,
        q,
        pOne,
        pZero,
        pePlusOne
      };
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(intPrefix + "_copy", c.i32_const(pOne), c.getLocal("pr")));
      }
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.call(intPrefix + "_add", c.getLocal("x"), c.getLocal("y"), c.getLocal("r")),
            c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r"))),
            c.if(
              c.call(intPrefix + "_gte", c.getLocal("r"), c.i32_const(pq)),
              c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
            )
          )
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.call(intPrefix + "_sub", c.getLocal("x"), c.getLocal("y"), c.getLocal("r")),
            c.drop(c.call(intPrefix + "_add", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
          )
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(prefix + "_sub", c.i32_const(pZero), c.getLocal("x"), c.getLocal("r"))
        );
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call(prefix + "_fromMontgomery", c.getLocal("x"), AUX),
          c.call(intPrefix + "_gte", AUX, c.i32_const(pePlusOne))
        );
      }
      function buildSign() {
        const f = module3.addFunction(prefix + "_sign");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(intPrefix + "_isZero", c.getLocal("x")),
            c.ret(c.i32_const(0))
          ),
          c.call(prefix + "_fromMontgomery", c.getLocal("x"), AUX),
          c.if(
            c.call(intPrefix + "_gte", AUX, c.i32_const(pePlusOne)),
            c.ret(c.i32_const(-1))
          ),
          c.ret(c.i32_const(1))
        );
      }
      function buildMReduct() {
        const carries = module3.alloc(n32 * n32 * 8);
        const f = module3.addFunction(prefix + "_mReduct");
        f.addParam("t", "i32");
        f.addParam("r", "i32");
        f.addLocal("np32", "i64");
        f.addLocal("c", "i64");
        f.addLocal("m", "i64");
        const c = f.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f.addCode(c.setLocal("np32", c.i64_const(np32)));
        for (let i = 0; i < n32; i++) {
          f.addCode(c.setLocal("c", c.i64_const(0)));
          f.addCode(
            c.setLocal(
              "m",
              c.i64_and(
                c.i64_mul(
                  c.i64_load32_u(c.getLocal("t"), i * 4),
                  c.getLocal("np32")
                ),
                c.i64_const("0xFFFFFFFF")
              )
            )
          );
          for (let j = 0; j < n32; j++) {
            f.addCode(
              c.setLocal(
                "c",
                c.i64_add(
                  c.i64_add(
                    c.i64_load32_u(c.getLocal("t"), (i + j) * 4),
                    c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
                  ),
                  c.i64_mul(
                    c.i64_load32_u(c.i32_const(pq), j * 4),
                    c.getLocal("m")
                  )
                )
              )
            );
            f.addCode(
              c.i64_store32(
                c.getLocal("t"),
                (i + j) * 4,
                c.getLocal("c")
              )
            );
          }
          f.addCode(
            c.i64_store32(
              c.i32_const(carries),
              i * 4,
              c.i64_shr_u(c.getLocal("c"), c.i64_const(32))
            )
          );
        }
        f.addCode(
          c.call(
            prefix + "_add",
            c.i32_const(carries),
            c.i32_add(
              c.getLocal("t"),
              c.i32_const(n32 * 4)
            ),
            c.getLocal("r")
          )
        );
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        f.addLocal("np32", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
          f.addLocal("y" + i, "i64");
          f.addLocal("m" + i, "i64");
          f.addLocal("q" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f.addCode(c.setLocal("np32", c.i64_const(np32)));
        const loadX = [];
        const loadY = [];
        const loadQ = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadY[j]) {
            Y = c.teeLocal("y" + j, c.i64_load32_u(c.getLocal("y"), j * 4));
            loadY[j] = true;
          } else {
            Y = c.getLocal("y" + j);
          }
          return c.i64_mul(X, Y);
        }
        function mulqm(i, j) {
          let Q, M;
          if (!loadQ[i]) {
            Q = c.teeLocal("q" + i, c.i64_load32_u(c.i32_const(0), pq + i * 4));
            loadQ[i] = true;
          } else {
            Q = c.getLocal("q" + i);
          }
          M = c.getLocal("m" + j);
          return c.i64_mul(Q, M);
        }
        let c0 = "c0";
        let c1 = "c1";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          for (let i = Math.max(0, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          for (let i = Math.max(1, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k < n32) {
            f.addCode(
              c.setLocal(
                "m" + k,
                c.i64_and(
                  c.i64_mul(
                    c.i64_and(
                      c.getLocal(c0),
                      c.i64_const(4294967295)
                    ),
                    c.getLocal("np32")
                  ),
                  c.i64_const("0xFFFFFFFF")
                )
              )
            );
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(0, k)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k >= n32) {
            f.addCode(
              c.i64_store32(
                c.getLocal("r"),
                (k - n32) * 4,
                c.getLocal(c0)
              )
            );
          }
          [c0, c1] = [c1, c0];
          f.addCode(
            c.setLocal(
              c1,
              c.i64_shr_u(
                c.getLocal(c0),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 - 4,
            c.getLocal(c0)
          )
        );
        f.addCode(
          c.if(
            c.i32_wrap_i64(c.getLocal(c1)),
            c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r"))),
            c.if(
              c.call(intPrefix + "_gte", c.getLocal("r"), c.i32_const(pq)),
              c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
            )
          )
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("c0", "i64");
        f.addLocal("c1", "i64");
        f.addLocal("c0_old", "i64");
        f.addLocal("c1_old", "i64");
        f.addLocal("np32", "i64");
        for (let i = 0; i < n32; i++) {
          f.addLocal("x" + i, "i64");
          f.addLocal("m" + i, "i64");
          f.addLocal("q" + i, "i64");
        }
        const c = f.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f.addCode(c.setLocal("np32", c.i64_const(np32)));
        const loadX = [];
        const loadQ = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c.teeLocal("x" + i, c.i64_load32_u(c.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c.getLocal("x" + i);
          }
          if (!loadX[j]) {
            Y = c.teeLocal("x" + j, c.i64_load32_u(c.getLocal("x"), j * 4));
            loadX[j] = true;
          } else {
            Y = c.getLocal("x" + j);
          }
          return c.i64_mul(X, Y);
        }
        function mulqm(i, j) {
          let Q, M;
          if (!loadQ[i]) {
            Q = c.teeLocal("q" + i, c.i64_load32_u(c.i32_const(0), pq + i * 4));
            loadQ[i] = true;
          } else {
            Q = c.getLocal("q" + i);
          }
          M = c.getLocal("m" + j);
          return c.i64_mul(Q, M);
        }
        let c0 = "c0";
        let c1 = "c1";
        let c0_old = "c0_old";
        let c1_old = "c1_old";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          f.addCode(
            c.setLocal(c0, c.i64_const(0)),
            c.setLocal(c1, c.i64_const(0))
          );
          for (let i = Math.max(0, k - n32 + 1); i < k + 1 >> 1 && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          f.addCode(
            c.setLocal(
              c0,
              c.i64_shl(
                c.i64_and(
                  c.getLocal(c0),
                  c.i64_const(4294967295)
                ),
                c.i64_const(1)
              )
            )
          );
          f.addCode(
            c.setLocal(
              c1,
              c.i64_add(
                c.i64_shl(
                  c.getLocal(c1),
                  c.i64_const(1)
                ),
                c.i64_shr_u(
                  c.getLocal(c0),
                  c.i64_const(32)
                )
              )
            )
          );
          if (k % 2 == 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulij(k >> 1, k >> 1)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k > 0) {
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  c.i64_and(
                    c.getLocal(c0_old),
                    c.i64_const(4294967295)
                  )
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.i64_add(
                    c.getLocal(c1),
                    c.i64_shr_u(
                      c.getLocal(c0),
                      c.i64_const(32)
                    )
                  ),
                  c.getLocal(c1_old)
                )
              )
            );
          }
          for (let i = Math.max(1, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(i, j)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k < n32) {
            f.addCode(
              c.setLocal(
                "m" + k,
                c.i64_and(
                  c.i64_mul(
                    c.i64_and(
                      c.getLocal(c0),
                      c.i64_const(4294967295)
                    ),
                    c.getLocal("np32")
                  ),
                  c.i64_const("0xFFFFFFFF")
                )
              )
            );
            f.addCode(
              c.setLocal(
                c0,
                c.i64_add(
                  c.i64_and(
                    c.getLocal(c0),
                    c.i64_const(4294967295)
                  ),
                  mulqm(0, k)
                )
              )
            );
            f.addCode(
              c.setLocal(
                c1,
                c.i64_add(
                  c.getLocal(c1),
                  c.i64_shr_u(
                    c.getLocal(c0),
                    c.i64_const(32)
                  )
                )
              )
            );
          }
          if (k >= n32) {
            f.addCode(
              c.i64_store32(
                c.getLocal("r"),
                (k - n32) * 4,
                c.getLocal(c0)
              )
            );
          }
          f.addCode(
            c.setLocal(
              c0_old,
              c.getLocal(c1)
            ),
            c.setLocal(
              c1_old,
              c.i64_shr_u(
                c.getLocal(c0_old),
                c.i64_const(32)
              )
            )
          );
        }
        f.addCode(
          c.i64_store32(
            c.getLocal("r"),
            n32 * 4 - 4,
            c.getLocal(c0_old)
          )
        );
        f.addCode(
          c.if(
            c.i32_wrap_i64(c.getLocal(c1_old)),
            c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r"))),
            c.if(
              c.call(intPrefix + "_gte", c.getLocal("r"), c.i32_const(pq)),
              c.drop(c.call(intPrefix + "_sub", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")))
            )
          )
        );
      }
      function buildSquareOld() {
        const f = module3.addFunction(prefix + "_squareOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.getLocal("x"), c.getLocal("r")));
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.i32_const(pR2), c.getLocal("r")));
      }
      function buildFromMontgomery() {
        const pAux2 = module3.alloc(n8 * 2);
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(intPrefix + "_copy", c.getLocal("x"), c.i32_const(pAux2)));
        f.addCode(c.call(intPrefix + "_zero", c.i32_const(pAux2 + n8)));
        f.addCode(c.call(prefix + "_mReduct", c.i32_const(pAux2), c.getLocal("r")));
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_fromMontgomery", c.getLocal("x"), c.getLocal("r")));
        f.addCode(c.call(intPrefix + "_inverseMod", c.getLocal("r"), c.i32_const(pq), c.getLocal("r")));
        f.addCode(c.call(prefix + "_toMontgomery", c.getLocal("r"), c.getLocal("r")));
      }
      let _nqr = 2n;
      if (isPrime(q)) {
        while (modPow(_nqr, _e, q) !== _minusOne)
          _nqr = _nqr + 1n;
      }
      let s2 = 0;
      let _t = _minusOne;
      while (!isOdd4(_t) && _t !== 0n) {
        s2++;
        _t = _t >> 1n;
      }
      const pt = module3.alloc(n8, utils2.bigInt2BytesLE(_t, n8));
      const _nqrToT = modPow(_nqr, _t, q);
      const pNqrToT = module3.alloc(utils2.bigInt2BytesLE((_nqrToT << BigInt(n64 * 64)) % q, n8));
      const _tPlusOneOver2 = _t + 1n >> 1n;
      const ptPlusOneOver2 = module3.alloc(n8, utils2.bigInt2BytesLE(_tPlusOneOver2, n8));
      function buildSqrt4() {
        const f = module3.addFunction(prefix + "_sqrt");
        f.addParam("n", "i32");
        f.addParam("r", "i32");
        f.addLocal("m", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        const c = f.getCodeBuilder();
        const ONE = c.i32_const(pOne);
        const C = c.i32_const(module3.alloc(n8));
        const T = c.i32_const(module3.alloc(n8));
        const R = c.i32_const(module3.alloc(n8));
        const SQ = c.i32_const(module3.alloc(n8));
        const B = c.i32_const(module3.alloc(n8));
        f.addCode(
          // If (n==0) return 0
          c.if(
            c.call(prefix + "_isZero", c.getLocal("n")),
            c.ret(
              c.call(prefix + "_zero", c.getLocal("r"))
            )
          ),
          c.setLocal("m", c.i32_const(s2)),
          c.call(prefix + "_copy", c.i32_const(pNqrToT), C),
          c.call(prefix + "_exp", c.getLocal("n"), c.i32_const(pt), c.i32_const(n8), T),
          c.call(prefix + "_exp", c.getLocal("n"), c.i32_const(ptPlusOneOver2), c.i32_const(n8), R),
          c.block(c.loop(
            c.br_if(1, c.call(prefix + "_eq", T, ONE)),
            c.call(prefix + "_square", T, SQ),
            c.setLocal("i", c.i32_const(1)),
            c.block(c.loop(
              c.br_if(1, c.call(prefix + "_eq", SQ, ONE)),
              c.call(prefix + "_square", SQ, SQ),
              c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
              c.br(0)
            )),
            c.call(prefix + "_copy", C, B),
            c.setLocal("j", c.i32_sub(c.i32_sub(c.getLocal("m"), c.getLocal("i")), c.i32_const(1))),
            c.block(c.loop(
              c.br_if(1, c.i32_eqz(c.getLocal("j"))),
              c.call(prefix + "_square", B, B),
              c.setLocal("j", c.i32_sub(c.getLocal("j"), c.i32_const(1))),
              c.br(0)
            )),
            c.setLocal("m", c.getLocal("i")),
            c.call(prefix + "_square", B, C),
            c.call(prefix + "_mul", T, C, T),
            c.call(prefix + "_mul", R, B, R),
            c.br(0)
          )),
          c.if(
            c.call(prefix + "_isNegative", R),
            c.call(prefix + "_neg", R, c.getLocal("r")),
            c.call(prefix + "_copy", R, c.getLocal("r"))
          )
        );
      }
      function buildIsSquare() {
        const f = module3.addFunction(prefix + "_isSquare");
        f.addParam("n", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const ONE = c.i32_const(pOne);
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("n")),
            c.ret(c.i32_const(1))
          ),
          c.call(prefix + "_exp", c.getLocal("n"), c.i32_const(pe), c.i32_const(n8), AUX),
          c.call(prefix + "_eq", AUX, ONE)
        );
      }
      function buildLoad() {
        const f = module3.addFunction(prefix + "_load");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        f.addLocal("p", "i32");
        f.addLocal("l", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        const c = f.getCodeBuilder();
        const R = c.i32_const(module3.alloc(n8));
        const pAux = module3.alloc(n8);
        const AUX = c.i32_const(pAux);
        f.addCode(
          c.call(intPrefix + "_zero", c.getLocal("r")),
          c.setLocal("i", c.i32_const(n8)),
          c.setLocal("p", c.getLocal("scalar")),
          c.block(c.loop(
            c.br_if(1, c.i32_gt_u(c.getLocal("i"), c.getLocal("scalarLen"))),
            c.if(
              c.i32_eq(c.getLocal("i"), c.i32_const(n8)),
              c.call(prefix + "_one", R),
              c.call(prefix + "_mul", R, c.i32_const(pR2), R)
            ),
            c.call(prefix + "_mul", c.getLocal("p"), R, AUX),
            c.call(prefix + "_add", c.getLocal("r"), AUX, c.getLocal("r")),
            c.setLocal("p", c.i32_add(c.getLocal("p"), c.i32_const(n8))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(n8))),
            c.br(0)
          )),
          c.setLocal("l", c.i32_rem_u(c.getLocal("scalarLen"), c.i32_const(n8))),
          c.if(c.i32_eqz(c.getLocal("l")), c.ret([])),
          c.call(intPrefix + "_zero", AUX),
          c.setLocal("j", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("j"), c.getLocal("l"))),
            c.i32_store8(
              c.getLocal("j"),
              pAux,
              c.i32_load8_u(c.getLocal("p"))
            ),
            c.setLocal("p", c.i32_add(c.getLocal("p"), c.i32_const(1))),
            c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
            c.br(0)
          )),
          c.if(
            c.i32_eq(c.getLocal("i"), c.i32_const(n8)),
            c.call(prefix + "_one", R),
            c.call(prefix + "_mul", R, c.i32_const(pR2), R)
          ),
          c.call(prefix + "_mul", AUX, R, AUX),
          c.call(prefix + "_add", c.getLocal("r"), AUX, c.getLocal("r"))
        );
      }
      function buildTimesScalar() {
        const f = module3.addFunction(prefix + "_timesScalar");
        f.addParam("x", "i32");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call(prefix + "_load", c.getLocal("scalar"), c.getLocal("scalarLen"), AUX),
          c.call(prefix + "_toMontgomery", AUX, AUX),
          c.call(prefix + "_mul", c.getLocal("x"), AUX, c.getLocal("r"))
        );
      }
      function buildIsOne() {
        const f = module3.addFunction(prefix + "_isOne");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.ret(c.call(intPrefix + "_eq", c.getLocal("x"), c.i32_const(pOne)))
        );
      }
      module3.exportFunction(intPrefix + "_copy", prefix + "_copy");
      module3.exportFunction(intPrefix + "_zero", prefix + "_zero");
      module3.exportFunction(intPrefix + "_isZero", prefix + "_isZero");
      module3.exportFunction(intPrefix + "_eq", prefix + "_eq");
      buildIsOne();
      buildAdd();
      buildSub();
      buildNeg();
      buildMReduct();
      buildMul();
      buildSquare();
      buildSquareOld();
      buildToMontgomery();
      buildFromMontgomery();
      buildIsNegative();
      buildSign();
      buildInverse();
      buildOne();
      buildLoad();
      buildTimesScalar();
      buildBatchInverse(module3, prefix);
      buildBatchConvertion(module3, prefix + "_batchToMontgomery", prefix + "_toMontgomery", n8, n8);
      buildBatchConvertion(module3, prefix + "_batchFromMontgomery", prefix + "_fromMontgomery", n8, n8);
      buildBatchConvertion(module3, prefix + "_batchNeg", prefix + "_neg", n8, n8);
      buildBatchOp(module3, prefix + "_batchAdd", prefix + "_add", n8, n8);
      buildBatchOp(module3, prefix + "_batchSub", prefix + "_sub", n8, n8);
      buildBatchOp(module3, prefix + "_batchMul", prefix + "_mul", n8, n8);
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_isNegative");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_mReduct");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_squareOld");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_inverse");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_load");
      module3.exportFunction(prefix + "_timesScalar");
      buildExp(
        module3,
        prefix + "_exp",
        n8,
        prefix + "_mul",
        prefix + "_square",
        intPrefix + "_copy",
        prefix + "_one"
      );
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_batchInverse");
      if (isPrime(q)) {
        buildSqrt4();
        buildIsSquare();
        module3.exportFunction(prefix + "_sqrt");
        module3.exportFunction(prefix + "_isSquare");
      }
      module3.exportFunction(prefix + "_batchToMontgomery");
      module3.exportFunction(prefix + "_batchFromMontgomery");
      return prefix;
    };
  }
});

// ../../node_modules/wasmcurves/src/build_f1.js
var require_build_f13 = __commonJS({
  "../../node_modules/wasmcurves/src/build_f1.js"(exports, module2) {
    "use strict";
    var buildF1m = require_build_f1m3();
    var { bitLength: bitLength5 } = require_bigint3();
    module2.exports = function buildF1(module3, _q, _prefix, _f1mPrefix, _intPrefix) {
      const q = BigInt(_q);
      const n64 = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n8 = n64 * 8;
      const prefix = _prefix || "f1";
      if (module3.modules[prefix])
        return prefix;
      module3.modules[prefix] = {
        n64
      };
      const intPrefix = _intPrefix || "int";
      const f1mPrefix = buildF1m(module3, q, _f1mPrefix, intPrefix);
      const pR2 = module3.modules[f1mPrefix].pR2;
      const pq = module3.modules[f1mPrefix].pq;
      const pePlusOne = module3.modules[f1mPrefix].pePlusOne;
      function buildMul() {
        const pAux1 = module3.alloc(n8);
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(f1mPrefix + "_mul", c.getLocal("x"), c.getLocal("y"), c.i32_const(pAux1)));
        f.addCode(c.call(f1mPrefix + "_mul", c.i32_const(pAux1), c.i32_const(pR2), c.getLocal("r")));
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(prefix + "_mul", c.getLocal("x"), c.getLocal("x"), c.getLocal("r")));
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(intPrefix + "_inverseMod", c.getLocal("x"), c.i32_const(pq), c.getLocal("r")));
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(intPrefix + "_gte", c.getLocal("x"), c.i32_const(pePlusOne))
        );
      }
      buildMul();
      buildSquare();
      buildInverse();
      buildIsNegative();
      module3.exportFunction(f1mPrefix + "_add", prefix + "_add");
      module3.exportFunction(f1mPrefix + "_sub", prefix + "_sub");
      module3.exportFunction(f1mPrefix + "_neg", prefix + "_neg");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_inverse");
      module3.exportFunction(prefix + "_isNegative");
      module3.exportFunction(f1mPrefix + "_copy", prefix + "_copy");
      module3.exportFunction(f1mPrefix + "_zero", prefix + "_zero");
      module3.exportFunction(f1mPrefix + "_one", prefix + "_one");
      module3.exportFunction(f1mPrefix + "_isZero", prefix + "_isZero");
      module3.exportFunction(f1mPrefix + "_eq", prefix + "_eq");
      return prefix;
    };
  }
});

// ../../node_modules/wasmcurves/src/build_f2m.js
var require_build_f2m3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_f2m.js"(exports, module2) {
    "use strict";
    var buildExp = require_build_timesscalar3();
    var buildBatchInverse = require_build_batchinverse3();
    var utils2 = require_utils3();
    module2.exports = function buildF2m(module3, mulNonResidueFn, prefix, f1mPrefix) {
      if (module3.modules[prefix])
        return prefix;
      const f1n8 = module3.modules[f1mPrefix].n64 * 8;
      const q = module3.modules[f1mPrefix].q;
      module3.modules[prefix] = {
        n64: module3.modules[f1mPrefix].n64 * 2
      };
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_add", x0, y0, r0),
          c.call(f1mPrefix + "_add", x1, y1, r1)
        );
      }
      function buildTimesScalar() {
        const f = module3.addFunction(prefix + "_timesScalar");
        f.addParam("x", "i32");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_timesScalar", x0, c.getLocal("scalar"), c.getLocal("scalarLen"), r0),
          c.call(f1mPrefix + "_timesScalar", x1, c.getLocal("scalar"), c.getLocal("scalarLen"), r1)
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_sub", x0, y0, r0),
          c.call(f1mPrefix + "_sub", x1, y1, r1)
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_neg", x0, r0),
          c.call(f1mPrefix + "_neg", x1, r1)
        );
      }
      function buildConjugate() {
        const f = module3.addFunction(prefix + "_conjugate");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, r0),
          c.call(f1mPrefix + "_neg", x1, r1)
        );
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.if(
            c.call(f1mPrefix + "_isZero", x1),
            c.ret(c.call(f1mPrefix + "_isNegative", x0))
          ),
          c.ret(c.call(f1mPrefix + "_isNegative", x1))
        );
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const A = c.i32_const(module3.alloc(f1n8));
        const B = c.i32_const(module3.alloc(f1n8));
        const C = c.i32_const(module3.alloc(f1n8));
        const D = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_mul", x0, y0, A),
          // A = x0*y0
          c.call(f1mPrefix + "_mul", x1, y1, B),
          // B = x1*y1
          c.call(f1mPrefix + "_add", x0, x1, C),
          // C = x0 + x1
          c.call(f1mPrefix + "_add", y0, y1, D),
          // D = y0 + y1
          c.call(f1mPrefix + "_mul", C, D, C),
          // C = (x0 + x1)*(y0 + y1) = x0*y0+x0*y1+x1*y0+x1*y1
          //  c.call(f1mPrefix + "_mul", B, c.i32_const(pNonResidue), r0),  // r0 = nr*(x1*y1)
          c.call(mulNonResidueFn, B, r0),
          // r0 = nr*(x1*y1)
          c.call(f1mPrefix + "_add", A, r0, r0),
          // r0 = x0*y0 + nr*(x1*y1)
          c.call(f1mPrefix + "_add", A, B, r1),
          // r1 = x0*y0+x1*y1
          c.call(f1mPrefix + "_sub", C, r1, r1)
          // r1 = x0*y0+x0*y1+x1*y0+x1*y1 - x0*y0+x1*y1 = x0*y1+x1*y0
        );
      }
      function buildMul1() {
        const f = module3.addFunction(prefix + "_mul1");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y = c.getLocal("y");
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_mul", x0, y, r0),
          // A = x0*y
          c.call(f1mPrefix + "_mul", x1, y, r1)
          // B = x1*y
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const AB = c.i32_const(module3.alloc(f1n8));
        const APB = c.i32_const(module3.alloc(f1n8));
        const APNB = c.i32_const(module3.alloc(f1n8));
        const ABPNAB = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          // AB = x0*y1
          c.call(f1mPrefix + "_mul", x0, x1, AB),
          // APB = x0+y1
          c.call(f1mPrefix + "_add", x0, x1, APB),
          // APBN0 = x0 + nr*x1
          c.call(mulNonResidueFn, x1, APNB),
          c.call(f1mPrefix + "_add", x0, APNB, APNB),
          // ABPNAB = ab + nr*ab
          c.call(mulNonResidueFn, AB, ABPNAB),
          c.call(f1mPrefix + "_add", ABPNAB, AB, ABPNAB),
          // r0 = APB * APNB - ABPNAB
          c.call(f1mPrefix + "_mul", APB, APNB, r0),
          c.call(f1mPrefix + "_sub", r0, ABPNAB, r0),
          // r1 = AB + AB
          c.call(f1mPrefix + "_add", AB, AB, r1)
        );
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_toMontgomery", x0, r0),
          c.call(f1mPrefix + "_toMontgomery", x1, r1)
        );
      }
      function buildFromMontgomery() {
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_fromMontgomery", x0, r0),
          c.call(f1mPrefix + "_fromMontgomery", x1, r1)
        );
      }
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, r0),
          c.call(f1mPrefix + "_copy", x1, r1)
        );
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_zero", x0),
          c.call(f1mPrefix + "_zero", x1)
        );
      }
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_one", x0),
          c.call(f1mPrefix + "_zero", x1)
        );
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        f.addCode(
          c.i32_and(
            c.call(f1mPrefix + "_eq", x0, y0),
            c.call(f1mPrefix + "_eq", x1, y1)
          )
        );
      }
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.i32_and(
            c.call(f1mPrefix + "_isZero", x0),
            c.call(f1mPrefix + "_isZero", x1)
          )
        );
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const t0 = c.i32_const(module3.alloc(f1n8));
        const t1 = c.i32_const(module3.alloc(f1n8));
        const t2 = c.i32_const(module3.alloc(f1n8));
        const t3 = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_square", x0, t0),
          c.call(f1mPrefix + "_square", x1, t1),
          // c.call(f1mPrefix+"_mul", t1, c.i32_const(pNonResidue), t2),
          c.call(mulNonResidueFn, t1, t2),
          c.call(f1mPrefix + "_sub", t0, t2, t2),
          c.call(f1mPrefix + "_inverse", t2, t3),
          c.call(f1mPrefix + "_mul", x0, t3, r0),
          c.call(f1mPrefix + "_mul", x1, t3, r1),
          c.call(f1mPrefix + "_neg", r1, r1)
        );
      }
      function buildSign() {
        const f = module3.addFunction(prefix + "_sign");
        f.addParam("x", "i32");
        f.addLocal("s", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.setLocal("s", c.call(f1mPrefix + "_sign", x1)),
          c.if(
            c.getLocal("s"),
            c.ret(c.getLocal("s"))
          ),
          c.ret(c.call(f1mPrefix + "_sign", x0))
        );
      }
      function buildIsOne() {
        const f = module3.addFunction(prefix + "_isOne");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        f.addCode(
          c.ret(c.i32_and(
            c.call(f1mPrefix + "_isOne", x0),
            c.call(f1mPrefix + "_isZero", x1)
          ))
        );
      }
      function buildSqrt4() {
        const f = module3.addFunction(prefix + "_sqrt");
        f.addParam("a", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const e34 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8)));
        const e12 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 1n) / 2n, f1n8)));
        const a = c.getLocal("a");
        const a1 = c.i32_const(module3.alloc(f1n8 * 2));
        const alpha = c.i32_const(module3.alloc(f1n8 * 2));
        const a0 = c.i32_const(module3.alloc(f1n8 * 2));
        const pn1 = module3.alloc(f1n8 * 2);
        const n1 = c.i32_const(pn1);
        const n1a = c.i32_const(pn1);
        const n1b = c.i32_const(pn1 + f1n8);
        const x0 = c.i32_const(module3.alloc(f1n8 * 2));
        const b = c.i32_const(module3.alloc(f1n8 * 2));
        f.addCode(
          c.call(prefix + "_one", n1),
          c.call(prefix + "_neg", n1, n1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_exp", a, e34, c.i32_const(f1n8), a1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_square", a1, alpha),
          c.call(prefix + "_mul", a, alpha, alpha),
          // const a0 = F.mul(F.frobenius(1, alfa), alfa);
          c.call(prefix + "_conjugate", alpha, a0),
          c.call(prefix + "_mul", a0, alpha, a0),
          // if (F.eq(a0, F.negone)) return null;
          c.if(c.call(prefix + "_eq", a0, n1), c.unreachable()),
          // const x0 = F.mul(a1, a);
          c.call(prefix + "_mul", a1, a, x0),
          // if (F.eq(alfa, F.negone)) {
          c.if(
            c.call(prefix + "_eq", alpha, n1),
            [
              // x = F.mul(x0, [F.F.zero, F.F.one]);
              ...c.call(f1mPrefix + "_zero", n1a),
              ...c.call(f1mPrefix + "_one", n1b),
              ...c.call(prefix + "_mul", n1, x0, c.getLocal("pr"))
            ],
            [
              // const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);
              ...c.call(prefix + "_one", b),
              ...c.call(prefix + "_add", b, alpha, b),
              ...c.call(prefix + "_exp", b, e12, c.i32_const(f1n8), b),
              // x = F.mul(b, x0);
              ...c.call(prefix + "_mul", b, x0, c.getLocal("pr"))
            ]
          )
        );
      }
      function buildIsSquare() {
        const f = module3.addFunction(prefix + "_isSquare");
        f.addParam("a", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const e34 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8)));
        const a = c.getLocal("a");
        const a1 = c.i32_const(module3.alloc(f1n8 * 2));
        const alpha = c.i32_const(module3.alloc(f1n8 * 2));
        const a0 = c.i32_const(module3.alloc(f1n8 * 2));
        const pn1 = module3.alloc(f1n8 * 2);
        const n1 = c.i32_const(pn1);
        f.addCode(
          c.call(prefix + "_one", n1),
          c.call(prefix + "_neg", n1, n1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_exp", a, e34, c.i32_const(f1n8), a1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c.call(prefix + "_square", a1, alpha),
          c.call(prefix + "_mul", a, alpha, alpha),
          // const a0 = F.mul(F.frobenius(1, alfa), alfa);
          c.call(prefix + "_conjugate", alpha, a0),
          c.call(prefix + "_mul", a0, alpha, a0),
          // if (F.eq(a0, F.negone)) return null;
          c.if(
            c.call(
              prefix + "_eq",
              a0,
              n1
            ),
            c.ret(c.i32_const(0))
          ),
          c.ret(c.i32_const(1))
        );
      }
      buildIsZero();
      buildIsOne();
      buildZero();
      buildOne();
      buildCopy();
      buildMul();
      buildMul1();
      buildSquare();
      buildAdd();
      buildSub();
      buildNeg();
      buildConjugate();
      buildToMontgomery();
      buildFromMontgomery();
      buildEq();
      buildInverse();
      buildTimesScalar();
      buildSign();
      buildIsNegative();
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_mul1");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_conjugate");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_inverse");
      buildBatchInverse(module3, prefix);
      buildExp(
        module3,
        prefix + "_exp",
        f1n8 * 2,
        prefix + "_mul",
        prefix + "_square",
        prefix + "_copy",
        prefix + "_one"
      );
      buildSqrt4();
      buildIsSquare();
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_batchInverse");
      module3.exportFunction(prefix + "_sqrt");
      module3.exportFunction(prefix + "_isSquare");
      module3.exportFunction(prefix + "_isNegative");
      return prefix;
    };
  }
});

// ../../node_modules/wasmcurves/src/build_f3m.js
var require_build_f3m3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_f3m.js"(exports, module2) {
    "use strict";
    var buildExp = require_build_timesscalar3();
    var buildBatchInverse = require_build_batchinverse3();
    module2.exports = function buildF3m(module3, mulNonResidueFn, prefix, f1mPrefix) {
      if (module3.modules[prefix])
        return prefix;
      const f1n8 = module3.modules[f1mPrefix].n64 * 8;
      module3.modules[prefix] = {
        n64: module3.modules[f1mPrefix].n64 * 3
      };
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const y2 = c.i32_add(c.getLocal("y"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_add", x0, y0, r0),
          c.call(f1mPrefix + "_add", x1, y1, r1),
          c.call(f1mPrefix + "_add", x2, y2, r2)
        );
      }
      function buildTimesScalar() {
        const f = module3.addFunction(prefix + "_timesScalar");
        f.addParam("x", "i32");
        f.addParam("scalar", "i32");
        f.addParam("scalarLen", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_timesScalar", x0, c.getLocal("scalar"), c.getLocal("scalarLen"), r0),
          c.call(f1mPrefix + "_timesScalar", x1, c.getLocal("scalar"), c.getLocal("scalarLen"), r1),
          c.call(f1mPrefix + "_timesScalar", x2, c.getLocal("scalar"), c.getLocal("scalarLen"), r2)
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const y2 = c.i32_add(c.getLocal("y"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_sub", x0, y0, r0),
          c.call(f1mPrefix + "_sub", x1, y1, r1),
          c.call(f1mPrefix + "_sub", x2, y2, r2)
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_neg", x0, r0),
          c.call(f1mPrefix + "_neg", x1, r1),
          c.call(f1mPrefix + "_neg", x2, r2)
        );
      }
      function buildIsNegative() {
        const f = module3.addFunction(prefix + "_isNegative");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.if(
            c.call(f1mPrefix + "_isZero", x2),
            c.if(
              c.call(f1mPrefix + "_isZero", x1),
              c.ret(c.call(f1mPrefix + "_isNegative", x0)),
              c.ret(c.call(f1mPrefix + "_isNegative", x1))
            )
          ),
          c.ret(c.call(f1mPrefix + "_isNegative", x2))
        );
      }
      function buildMul() {
        const f = module3.addFunction(prefix + "_mul");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");
        const cd = f.getCodeBuilder();
        const a = cd.getLocal("x");
        const b = cd.i32_add(cd.getLocal("x"), cd.i32_const(f1n8));
        const c = cd.i32_add(cd.getLocal("x"), cd.i32_const(2 * f1n8));
        const A = cd.getLocal("y");
        const B = cd.i32_add(cd.getLocal("y"), cd.i32_const(f1n8));
        const C = cd.i32_add(cd.getLocal("y"), cd.i32_const(2 * f1n8));
        const r0 = cd.getLocal("r");
        const r1 = cd.i32_add(cd.getLocal("r"), cd.i32_const(f1n8));
        const r2 = cd.i32_add(cd.getLocal("r"), cd.i32_const(2 * f1n8));
        const aA = cd.i32_const(module3.alloc(f1n8));
        const bB = cd.i32_const(module3.alloc(f1n8));
        const cC = cd.i32_const(module3.alloc(f1n8));
        const a_b = cd.i32_const(module3.alloc(f1n8));
        const A_B = cd.i32_const(module3.alloc(f1n8));
        const a_c = cd.i32_const(module3.alloc(f1n8));
        const A_C = cd.i32_const(module3.alloc(f1n8));
        const b_c = cd.i32_const(module3.alloc(f1n8));
        const B_C = cd.i32_const(module3.alloc(f1n8));
        const aA_bB = cd.i32_const(module3.alloc(f1n8));
        const aA_cC = cd.i32_const(module3.alloc(f1n8));
        const bB_cC = cd.i32_const(module3.alloc(f1n8));
        const AUX = cd.i32_const(module3.alloc(f1n8));
        f.addCode(
          cd.call(f1mPrefix + "_mul", a, A, aA),
          cd.call(f1mPrefix + "_mul", b, B, bB),
          cd.call(f1mPrefix + "_mul", c, C, cC),
          cd.call(f1mPrefix + "_add", a, b, a_b),
          cd.call(f1mPrefix + "_add", A, B, A_B),
          cd.call(f1mPrefix + "_add", a, c, a_c),
          cd.call(f1mPrefix + "_add", A, C, A_C),
          cd.call(f1mPrefix + "_add", b, c, b_c),
          cd.call(f1mPrefix + "_add", B, C, B_C),
          cd.call(f1mPrefix + "_add", aA, bB, aA_bB),
          cd.call(f1mPrefix + "_add", aA, cC, aA_cC),
          cd.call(f1mPrefix + "_add", bB, cC, bB_cC),
          cd.call(f1mPrefix + "_mul", b_c, B_C, r0),
          cd.call(f1mPrefix + "_sub", r0, bB_cC, r0),
          cd.call(mulNonResidueFn, r0, r0),
          cd.call(f1mPrefix + "_add", aA, r0, r0),
          cd.call(f1mPrefix + "_mul", a_b, A_B, r1),
          cd.call(f1mPrefix + "_sub", r1, aA_bB, r1),
          cd.call(mulNonResidueFn, cC, AUX),
          cd.call(f1mPrefix + "_add", r1, AUX, r1),
          cd.call(f1mPrefix + "_mul", a_c, A_C, r2),
          cd.call(f1mPrefix + "_sub", r2, aA_cC, r2),
          cd.call(f1mPrefix + "_add", r2, bB, r2)
        );
      }
      function buildSquare() {
        const f = module3.addFunction(prefix + "_square");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const A = c.getLocal("x");
        const B = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const C = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        const s0 = c.i32_const(module3.alloc(f1n8));
        const ab = c.i32_const(module3.alloc(f1n8));
        const s1 = c.i32_const(module3.alloc(f1n8));
        const s2 = c.i32_const(module3.alloc(f1n8));
        const bc = c.i32_const(module3.alloc(f1n8));
        const s3 = c.i32_const(module3.alloc(f1n8));
        const s4 = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_square", A, s0),
          c.call(f1mPrefix + "_mul", A, B, ab),
          c.call(f1mPrefix + "_add", ab, ab, s1),
          c.call(f1mPrefix + "_sub", A, B, s2),
          c.call(f1mPrefix + "_add", s2, C, s2),
          c.call(f1mPrefix + "_square", s2, s2),
          c.call(f1mPrefix + "_mul", B, C, bc),
          c.call(f1mPrefix + "_add", bc, bc, s3),
          c.call(f1mPrefix + "_square", C, s4),
          c.call(mulNonResidueFn, s3, r0),
          c.call(f1mPrefix + "_add", s0, r0, r0),
          c.call(mulNonResidueFn, s4, r1),
          c.call(f1mPrefix + "_add", s1, r1, r1),
          c.call(f1mPrefix + "_add", s0, s4, r2),
          c.call(f1mPrefix + "_sub", s3, r2, r2),
          c.call(f1mPrefix + "_add", s2, r2, r2),
          c.call(f1mPrefix + "_add", s1, r2, r2)
        );
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_toMontgomery", x0, r0),
          c.call(f1mPrefix + "_toMontgomery", x1, r1),
          c.call(f1mPrefix + "_toMontgomery", x2, r2)
        );
      }
      function buildFromMontgomery() {
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_fromMontgomery", x0, r0),
          c.call(f1mPrefix + "_fromMontgomery", x1, r1),
          c.call(f1mPrefix + "_fromMontgomery", x2, r2)
        );
      }
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, r0),
          c.call(f1mPrefix + "_copy", x1, r1),
          c.call(f1mPrefix + "_copy", x2, r2)
        );
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_zero", x0),
          c.call(f1mPrefix + "_zero", x1),
          c.call(f1mPrefix + "_zero", x2)
        );
      }
      function buildOne() {
        const f = module3.addFunction(prefix + "_one");
        f.addParam("x", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.call(f1mPrefix + "_one", x0),
          c.call(f1mPrefix + "_zero", x1),
          c.call(f1mPrefix + "_zero", x2)
        );
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const y0 = c.getLocal("y");
        const y1 = c.i32_add(c.getLocal("y"), c.i32_const(f1n8));
        const y2 = c.i32_add(c.getLocal("y"), c.i32_const(2 * f1n8));
        f.addCode(
          c.i32_and(
            c.i32_and(
              c.call(f1mPrefix + "_eq", x0, y0),
              c.call(f1mPrefix + "_eq", x1, y1)
            ),
            c.call(f1mPrefix + "_eq", x2, y2)
          )
        );
      }
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.i32_and(
            c.i32_and(
              c.call(f1mPrefix + "_isZero", x0),
              c.call(f1mPrefix + "_isZero", x1)
            ),
            c.call(f1mPrefix + "_isZero", x2)
          )
        );
      }
      function buildInverse() {
        const f = module3.addFunction(prefix + "_inverse");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        const r0 = c.getLocal("r");
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(f1n8));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f1n8));
        const t0 = c.i32_const(module3.alloc(f1n8));
        const t1 = c.i32_const(module3.alloc(f1n8));
        const t2 = c.i32_const(module3.alloc(f1n8));
        const t3 = c.i32_const(module3.alloc(f1n8));
        const t4 = c.i32_const(module3.alloc(f1n8));
        const t5 = c.i32_const(module3.alloc(f1n8));
        const c0 = c.i32_const(module3.alloc(f1n8));
        const c1 = c.i32_const(module3.alloc(f1n8));
        const c2 = c.i32_const(module3.alloc(f1n8));
        const t6 = c.i32_const(module3.alloc(f1n8));
        const AUX = c.i32_const(module3.alloc(f1n8));
        f.addCode(
          c.call(f1mPrefix + "_square", x0, t0),
          c.call(f1mPrefix + "_square", x1, t1),
          c.call(f1mPrefix + "_square", x2, t2),
          c.call(f1mPrefix + "_mul", x0, x1, t3),
          c.call(f1mPrefix + "_mul", x0, x2, t4),
          c.call(f1mPrefix + "_mul", x1, x2, t5),
          c.call(mulNonResidueFn, t5, c0),
          c.call(f1mPrefix + "_sub", t0, c0, c0),
          c.call(mulNonResidueFn, t2, c1),
          c.call(f1mPrefix + "_sub", c1, t3, c1),
          c.call(f1mPrefix + "_sub", t1, t4, c2),
          c.call(f1mPrefix + "_mul", x2, c1, t6),
          c.call(f1mPrefix + "_mul", x1, c2, AUX),
          c.call(f1mPrefix + "_add", t6, AUX, t6),
          c.call(mulNonResidueFn, t6, t6),
          c.call(f1mPrefix + "_mul", x0, c0, AUX),
          c.call(f1mPrefix + "_add", AUX, t6, t6),
          c.call(f1mPrefix + "_inverse", t6, t6),
          c.call(f1mPrefix + "_mul", t6, c0, r0),
          c.call(f1mPrefix + "_mul", t6, c1, r1),
          c.call(f1mPrefix + "_mul", t6, c2, r2)
        );
      }
      function buildSign() {
        const f = module3.addFunction(prefix + "_sign");
        f.addParam("x", "i32");
        f.addLocal("s", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f1n8));
        f.addCode(
          c.setLocal("s", c.call(f1mPrefix + "_sign", x2)),
          c.if(
            c.getLocal("s"),
            c.ret(c.getLocal("s"))
          ),
          c.setLocal("s", c.call(f1mPrefix + "_sign", x1)),
          c.if(
            c.getLocal("s"),
            c.ret(c.getLocal("s"))
          ),
          c.ret(c.call(f1mPrefix + "_sign", x0))
        );
      }
      function buildIsOne() {
        const f = module3.addFunction(prefix + "_isOne");
        f.addParam("x", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(f1n8 * 2));
        f.addCode(
          c.ret(
            c.i32_and(
              c.i32_and(
                c.call(f1mPrefix + "_isOne", x0),
                c.call(f1mPrefix + "_isZero", x1)
              ),
              c.call(f1mPrefix + "_isZero", x2)
            )
          )
        );
      }
      buildIsZero();
      buildIsOne();
      buildZero();
      buildOne();
      buildCopy();
      buildMul();
      buildSquare();
      buildAdd();
      buildSub();
      buildNeg();
      buildSign();
      buildToMontgomery();
      buildFromMontgomery();
      buildEq();
      buildInverse();
      buildTimesScalar();
      buildIsNegative();
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_inverse");
      buildBatchInverse(module3, prefix);
      buildExp(
        module3,
        prefix + "_exp",
        f1n8 * 3,
        prefix + "_mul",
        prefix + "_square",
        prefix + "_copy",
        prefix + "_one"
      );
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_batchInverse");
      module3.exportFunction(prefix + "_isNegative");
      return prefix;
    };
  }
});

// ../../node_modules/wasmcurves/src/build_timesscalarnaf.js
var require_build_timesscalarnaf3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_timesscalarnaf.js"(exports, module2) {
    "use strict";
    module2.exports = function buildTimesScalarNAF(module3, fnName, elementLen, opAB, opAA, opAmB, opCopy, opInit) {
      const f = module3.addFunction(fnName);
      f.addParam("base", "i32");
      f.addParam("scalar", "i32");
      f.addParam("scalarLength", "i32");
      f.addParam("r", "i32");
      f.addLocal("old0", "i32");
      f.addLocal("nbits", "i32");
      f.addLocal("i", "i32");
      f.addLocal("last", "i32");
      f.addLocal("cur", "i32");
      f.addLocal("carry", "i32");
      f.addLocal("p", "i32");
      const c = f.getCodeBuilder();
      const aux = c.i32_const(module3.alloc(elementLen));
      function getBit(IDX) {
        return c.i32_and(
          c.i32_shr_u(
            c.i32_load(
              c.i32_add(
                c.getLocal("scalar"),
                c.i32_and(
                  c.i32_shr_u(
                    IDX,
                    c.i32_const(3)
                  ),
                  c.i32_const(4294967292)
                )
              )
            ),
            c.i32_and(
              IDX,
              c.i32_const(31)
            )
          ),
          c.i32_const(1)
        );
      }
      function pushBit(b) {
        return [
          ...c.i32_store8(
            c.getLocal("p"),
            c.i32_const(b)
          ),
          ...c.setLocal(
            "p",
            c.i32_add(
              c.getLocal("p"),
              c.i32_const(1)
            )
          )
        ];
      }
      f.addCode(
        c.if(
          c.i32_eqz(c.getLocal("scalarLength")),
          [
            ...c.call(opInit, c.getLocal("r")),
            ...c.ret([])
          ]
        ),
        c.setLocal("nbits", c.i32_shl(c.getLocal("scalarLength"), c.i32_const(3))),
        c.setLocal("old0", c.i32_load(c.i32_const(0))),
        c.setLocal("p", c.getLocal("old0")),
        c.i32_store(
          c.i32_const(0),
          c.i32_and(
            c.i32_add(
              c.i32_add(
                c.getLocal("old0"),
                c.i32_const(32)
              ),
              c.getLocal("nbits")
            ),
            c.i32_const(4294967288)
          )
        ),
        c.setLocal("i", c.i32_const(1)),
        c.setLocal("last", getBit(c.i32_const(0))),
        c.setLocal("carry", c.i32_const(0)),
        c.block(c.loop(
          c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("nbits"))),
          c.setLocal("cur", getBit(c.getLocal("i"))),
          c.if(
            c.getLocal("last"),
            c.if(
              c.getLocal("cur"),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(1)
                ],
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(255)
                ]
              ),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(255)
                ],
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(1)
                ]
              )
            ),
            c.if(
              c.getLocal("cur"),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(1)),
                  ...pushBit(0)
                ],
                [
                  ...c.setLocal("last", c.i32_const(1)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(0)
                ]
              ),
              c.if(
                c.getLocal("carry"),
                [
                  ...c.setLocal("last", c.i32_const(1)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(0)
                ],
                [
                  ...c.setLocal("last", c.i32_const(0)),
                  ...c.setLocal("carry", c.i32_const(0)),
                  ...pushBit(0)
                ]
              )
            )
          ),
          c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        )),
        c.if(
          c.getLocal("last"),
          c.if(
            c.getLocal("carry"),
            [
              ...pushBit(255),
              ...pushBit(0),
              ...pushBit(1)
            ],
            [
              ...pushBit(1)
            ]
          ),
          c.if(
            c.getLocal("carry"),
            [
              ...pushBit(0),
              ...pushBit(1)
            ]
          )
        ),
        c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
        // p already points to the last bit
        c.call(opCopy, c.getLocal("base"), aux),
        c.call(opInit, c.getLocal("r")),
        c.block(c.loop(
          c.call(opAA, c.getLocal("r"), c.getLocal("r")),
          c.setLocal(
            "cur",
            c.i32_load8_u(
              c.getLocal("p")
            )
          ),
          c.if(
            c.getLocal("cur"),
            c.if(
              c.i32_eq(c.getLocal("cur"), c.i32_const(1)),
              c.call(opAB, c.getLocal("r"), aux, c.getLocal("r")),
              c.call(opAmB, c.getLocal("r"), aux, c.getLocal("r"))
            )
          ),
          c.br_if(1, c.i32_eq(c.getLocal("old0"), c.getLocal("p"))),
          c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
          c.br(0)
        )),
        c.i32_store(c.i32_const(0), c.getLocal("old0"))
      );
    };
  }
});

// ../../node_modules/wasmcurves/src/build_multiexp.js
var require_build_multiexp3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_multiexp.js"(exports, module2) {
    "use strict";
    module2.exports = function buildMultiexp4(module3, prefix, fnName, opAdd, n8b) {
      const n64g = module3.modules[prefix].n64;
      const n8g = n64g * 8;
      function buildGetChunk() {
        const f = module3.addFunction(fnName + "_getChunk");
        f.addParam("pScalar", "i32");
        f.addParam("scalarSize", "i32");
        f.addParam("startBit", "i32");
        f.addParam("chunkSize", "i32");
        f.addLocal("bitsToEnd", "i32");
        f.addLocal("mask", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "bitsToEnd",
            c.i32_sub(
              c.i32_mul(
                c.getLocal("scalarSize"),
                c.i32_const(8)
              ),
              c.getLocal("startBit")
            )
          ),
          c.if(
            c.i32_gt_s(
              c.getLocal("chunkSize"),
              c.getLocal("bitsToEnd")
            ),
            c.setLocal(
              "mask",
              c.i32_sub(
                c.i32_shl(
                  c.i32_const(1),
                  c.getLocal("bitsToEnd")
                ),
                c.i32_const(1)
              )
            ),
            c.setLocal(
              "mask",
              c.i32_sub(
                c.i32_shl(
                  c.i32_const(1),
                  c.getLocal("chunkSize")
                ),
                c.i32_const(1)
              )
            )
          ),
          c.i32_and(
            c.i32_shr_u(
              c.i32_load(
                c.i32_add(
                  c.getLocal("pScalar"),
                  c.i32_shr_u(
                    c.getLocal("startBit"),
                    c.i32_const(3)
                  )
                ),
                0,
                // offset
                0
                // align to byte.
              ),
              c.i32_and(
                c.getLocal("startBit"),
                c.i32_const(7)
              )
            ),
            c.getLocal("mask")
          )
        );
      }
      function buildMutiexpChunk() {
        const f = module3.addFunction(fnName + "_chunk");
        f.addParam("pBases", "i32");
        f.addParam("pScalars", "i32");
        f.addParam("scalarSize", "i32");
        f.addParam("n", "i32");
        f.addParam("startBit", "i32");
        f.addParam("chunkSize", "i32");
        f.addParam("pr", "i32");
        f.addLocal("nChunks", "i32");
        f.addLocal("itScalar", "i32");
        f.addLocal("endScalar", "i32");
        f.addLocal("itBase", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("nTable", "i32");
        f.addLocal("pTable", "i32");
        f.addLocal("idx", "i32");
        f.addLocal("pIdxTable", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.i32_eqz(c.getLocal("n")),
            [
              ...c.call(prefix + "_zero", c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          // Allocate memory
          c.setLocal(
            "nTable",
            c.i32_shl(
              c.i32_const(1),
              c.getLocal("chunkSize")
            )
          ),
          c.setLocal("pTable", c.i32_load(c.i32_const(0))),
          c.i32_store(
            c.i32_const(0),
            c.i32_add(
              c.getLocal("pTable"),
              c.i32_mul(
                c.getLocal("nTable"),
                c.i32_const(n8g)
              )
            )
          ),
          // Reset Table
          c.setLocal("j", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("j"),
                c.getLocal("nTable")
              )
            ),
            c.call(
              prefix + "_zero",
              c.i32_add(
                c.getLocal("pTable"),
                c.i32_mul(
                  c.getLocal("j"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
            c.br(0)
          )),
          // Distribute elements
          c.setLocal("itBase", c.getLocal("pBases")),
          c.setLocal("itScalar", c.getLocal("pScalars")),
          c.setLocal(
            "endScalar",
            c.i32_add(
              c.getLocal("pScalars"),
              c.i32_mul(
                c.getLocal("n"),
                c.getLocal("scalarSize")
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("itScalar"),
                c.getLocal("endScalar")
              )
            ),
            c.setLocal(
              "idx",
              c.call(
                fnName + "_getChunk",
                c.getLocal("itScalar"),
                c.getLocal("scalarSize"),
                c.getLocal("startBit"),
                c.getLocal("chunkSize")
              )
            ),
            c.if(
              c.getLocal("idx"),
              [
                ...c.setLocal(
                  "pIdxTable",
                  c.i32_add(
                    c.getLocal("pTable"),
                    c.i32_mul(
                      c.i32_sub(
                        c.getLocal("idx"),
                        c.i32_const(1)
                      ),
                      c.i32_const(n8g)
                    )
                  )
                ),
                ...c.call(
                  opAdd,
                  c.getLocal("pIdxTable"),
                  c.getLocal("itBase"),
                  c.getLocal("pIdxTable")
                )
              ]
            ),
            c.setLocal("itScalar", c.i32_add(c.getLocal("itScalar"), c.getLocal("scalarSize"))),
            c.setLocal("itBase", c.i32_add(c.getLocal("itBase"), c.i32_const(n8b))),
            c.br(0)
          )),
          c.call(fnName + "_reduceTable", c.getLocal("pTable"), c.getLocal("chunkSize")),
          c.call(
            prefix + "_copy",
            c.getLocal("pTable"),
            c.getLocal("pr")
          ),
          c.i32_store(
            c.i32_const(0),
            c.getLocal("pTable")
          )
        );
      }
      function buildMultiexp5() {
        const f = module3.addFunction(fnName);
        f.addParam("pBases", "i32");
        f.addParam("pScalars", "i32");
        f.addParam("scalarSize", "i32");
        f.addParam("n", "i32");
        f.addParam("pr", "i32");
        f.addLocal("chunkSize", "i32");
        f.addLocal("nChunks", "i32");
        f.addLocal("itScalar", "i32");
        f.addLocal("endScalar", "i32");
        f.addLocal("itBase", "i32");
        f.addLocal("itBit", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("nTable", "i32");
        f.addLocal("pTable", "i32");
        f.addLocal("idx", "i32");
        f.addLocal("pIdxTable", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8g));
        const pTSizes2 = module3.alloc([
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          16,
          16,
          15,
          14,
          13,
          13,
          12,
          11,
          10,
          9,
          8,
          7,
          7,
          6,
          5,
          4,
          3,
          2,
          1,
          1,
          1,
          1
        ]);
        f.addCode(
          c.call(prefix + "_zero", c.getLocal("pr")),
          c.if(
            c.i32_eqz(c.getLocal("n")),
            c.ret([])
          ),
          c.setLocal("chunkSize", c.i32_load8_u(c.i32_clz(c.getLocal("n")), pTSizes2)),
          c.setLocal(
            "nChunks",
            c.i32_add(
              c.i32_div_u(
                c.i32_sub(
                  c.i32_shl(
                    c.getLocal("scalarSize"),
                    c.i32_const(3)
                  ),
                  c.i32_const(1)
                ),
                c.getLocal("chunkSize")
              ),
              c.i32_const(1)
            )
          ),
          // Allocate memory
          c.setLocal(
            "itBit",
            c.i32_mul(
              c.i32_sub(
                c.getLocal("nChunks"),
                c.i32_const(1)
              ),
              c.getLocal("chunkSize")
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_lt_s(
                c.getLocal("itBit"),
                c.i32_const(0)
              )
            ),
            // Double nChunk times
            c.if(
              c.i32_eqz(c.call(prefix + "_isZero", c.getLocal("pr"))),
              [
                ...c.setLocal("j", c.i32_const(0)),
                ...c.block(c.loop(
                  c.br_if(
                    1,
                    c.i32_eq(
                      c.getLocal("j"),
                      c.getLocal("chunkSize")
                    )
                  ),
                  c.call(prefix + "_double", c.getLocal("pr"), c.getLocal("pr")),
                  c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
                  c.br(0)
                ))
              ]
            ),
            c.call(
              fnName + "_chunk",
              c.getLocal("pBases"),
              c.getLocal("pScalars"),
              c.getLocal("scalarSize"),
              c.getLocal("n"),
              c.getLocal("itBit"),
              c.getLocal("chunkSize"),
              aux
            ),
            c.call(
              prefix + "_add",
              c.getLocal("pr"),
              aux,
              c.getLocal("pr")
            ),
            c.setLocal("itBit", c.i32_sub(c.getLocal("itBit"), c.getLocal("chunkSize"))),
            c.br(0)
          ))
        );
      }
      function buildReduceTable() {
        const f = module3.addFunction(fnName + "_reduceTable");
        f.addParam("pTable", "i32");
        f.addParam("p", "i32");
        f.addLocal("half", "i32");
        f.addLocal("it1", "i32");
        f.addLocal("it2", "i32");
        f.addLocal("pAcc", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.if(
            c.i32_eq(c.getLocal("p"), c.i32_const(1)),
            c.ret([])
          ),
          c.setLocal(
            "half",
            c.i32_shl(
              c.i32_const(1),
              c.i32_sub(
                c.getLocal("p"),
                c.i32_const(1)
              )
            )
          ),
          c.setLocal("it1", c.getLocal("pTable")),
          c.setLocal(
            "it2",
            c.i32_add(
              c.getLocal("pTable"),
              c.i32_mul(
                c.getLocal("half"),
                c.i32_const(n8g)
              )
            )
          ),
          c.setLocal(
            "pAcc",
            c.i32_sub(
              c.getLocal("it2"),
              c.i32_const(n8g)
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("it1"),
                c.getLocal("pAcc")
              )
            ),
            c.call(
              prefix + "_add",
              c.getLocal("it1"),
              c.getLocal("it2"),
              c.getLocal("it1")
            ),
            c.call(
              prefix + "_add",
              c.getLocal("pAcc"),
              c.getLocal("it2"),
              c.getLocal("pAcc")
            ),
            c.setLocal("it1", c.i32_add(c.getLocal("it1"), c.i32_const(n8g))),
            c.setLocal("it2", c.i32_add(c.getLocal("it2"), c.i32_const(n8g))),
            c.br(0)
          )),
          c.call(
            fnName + "_reduceTable",
            c.getLocal("pTable"),
            c.i32_sub(
              c.getLocal("p"),
              c.i32_const(1)
            )
          ),
          c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
          c.block(c.loop(
            c.br_if(1, c.i32_eqz(c.getLocal("p"))),
            c.call(prefix + "_double", c.getLocal("pAcc"), c.getLocal("pAcc")),
            c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
            c.br(0)
          )),
          c.call(prefix + "_add", c.getLocal("pTable"), c.getLocal("pAcc"), c.getLocal("pTable"))
        );
      }
      buildGetChunk();
      buildReduceTable();
      buildMutiexpChunk();
      buildMultiexp5();
      module3.exportFunction(fnName);
      module3.exportFunction(fnName + "_chunk");
    };
  }
});

// ../../node_modules/wasmcurves/src/build_curve_jacobian_a0.js
var require_build_curve_jacobian_a03 = __commonJS({
  "../../node_modules/wasmcurves/src/build_curve_jacobian_a0.js"(exports, module2) {
    "use strict";
    var buildTimesScalarNAF = require_build_timesscalarnaf3();
    var buildBatchConvertion = require_build_batchconvertion3();
    var buildMultiexp4 = require_build_multiexp3();
    module2.exports = function buildCurve(module3, prefix, prefixField, pB) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      if (module3.modules[prefix])
        return prefix;
      module3.modules[prefix] = {
        n64: n64 * 3
      };
      function buildIsZero() {
        const f = module3.addFunction(prefix + "_isZero");
        f.addParam("p1", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_isZero",
          c.i32_add(
            c.getLocal("p1"),
            c.i32_const(n8 * 2)
          )
        ));
      }
      function buildIsZeroAffine() {
        const f = module3.addFunction(prefix + "_isZeroAffine");
        f.addParam("p1", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.i32_and(
            c.call(
              prefixField + "_isZero",
              c.getLocal("p1")
            ),
            c.call(
              prefixField + "_isZero",
              c.i32_add(
                c.getLocal("p1"),
                c.i32_const(n8)
              )
            )
          )
        );
      }
      function buildCopy() {
        const f = module3.addFunction(prefix + "_copy");
        f.addParam("ps", "i32");
        f.addParam("pd", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64 * 3; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pd"),
              i * 8,
              c.i64_load(
                c.getLocal("ps"),
                i * 8
              )
            )
          );
        }
      }
      function buildCopyAffine() {
        const f = module3.addFunction(prefix + "_copyAffine");
        f.addParam("ps", "i32");
        f.addParam("pd", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < n64 * 2; i++) {
          f.addCode(
            c.i64_store(
              c.getLocal("pd"),
              i * 8,
              c.i64_load(
                c.getLocal("ps"),
                i * 8
              )
            )
          );
        }
      }
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_zero",
          c.getLocal("pr")
        ));
        f.addCode(c.call(
          prefixField + "_one",
          c.i32_add(
            c.getLocal("pr"),
            c.i32_const(n8)
          )
        ));
        f.addCode(c.call(
          prefixField + "_zero",
          c.i32_add(
            c.getLocal("pr"),
            c.i32_const(n8 * 2)
          )
        ));
      }
      function buildZeroAffine() {
        const f = module3.addFunction(prefix + "_zeroAffine");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_zero",
          c.getLocal("pr")
        ));
        f.addCode(c.call(
          prefixField + "_zero",
          c.i32_add(
            c.getLocal("pr"),
            c.i32_const(n8)
          )
        ));
      }
      function buildEq() {
        const f = module3.addFunction(prefix + "_eq");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");
        f.addLocal("z2", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        f.addCode(c.setLocal("z2", c.i32_add(c.getLocal("p2"), c.i32_const(n8 * 2))));
        const z2 = c.getLocal("z2");
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const Z2Z2 = c.i32_const(module3.alloc(n8));
        const U1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const Z2_cubed = c.i32_const(module3.alloc(n8));
        const S1 = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            c.ret(c.call(prefix + "_isZero", c.getLocal("p2")))
          ),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p2")),
            c.ret(c.i32_const(0))
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            c.ret(c.call(prefix + "_eqMixed", c.getLocal("p2"), c.getLocal("p1")))
          ),
          c.if(
            c.call(prefixField + "_isOne", z2),
            c.ret(c.call(prefix + "_eqMixed", c.getLocal("p1"), c.getLocal("p2")))
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_square", z2, Z2Z2),
          c.call(prefixField + "_mul", x1, Z2Z2, U1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
          c.call(prefixField + "_mul", y1, Z2_cubed, S1),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", U1, U2),
            c.if(
              c.call(prefixField + "_eq", S1, S2),
              c.ret(c.i32_const(1))
            )
          ),
          c.ret(c.i32_const(0))
        );
      }
      function buildEqMixed() {
        const f = module3.addFunction(prefix + "_eqMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            c.ret(c.call(prefix + "_isZeroAffine", c.getLocal("p2")))
          ),
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
            c.ret(c.i32_const(0))
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            c.ret(c.call(prefix + "_eqAffine", c.getLocal("p1"), c.getLocal("p2")))
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", x1, U2),
            c.if(
              c.call(prefixField + "_eq", y1, S2),
              c.ret(c.i32_const(1))
            )
          ),
          c.ret(c.i32_const(0))
        );
      }
      function buildDouble() {
        const f = module3.addFunction(prefix + "_double");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const A = c.i32_const(module3.alloc(n8));
        const B = c.i32_const(module3.alloc(n8));
        const C = c.i32_const(module3.alloc(n8));
        const D = c.i32_const(module3.alloc(n8));
        const E = c.i32_const(module3.alloc(n8));
        const F = c.i32_const(module3.alloc(n8));
        const G = c.i32_const(module3.alloc(n8));
        const eightC = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z),
            [
              ...c.ret(c.call(prefix + "_doubleAffine", c.getLocal("p1"), c.getLocal("pr"))),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_square", x, A),
          c.call(prefixField + "_square", y, B),
          c.call(prefixField + "_square", B, C),
          c.call(prefixField + "_add", x, B, D),
          c.call(prefixField + "_square", D, D),
          c.call(prefixField + "_sub", D, A, D),
          c.call(prefixField + "_sub", D, C, D),
          c.call(prefixField + "_add", D, D, D),
          c.call(prefixField + "_add", A, A, E),
          c.call(prefixField + "_add", E, A, E),
          c.call(prefixField + "_square", E, F),
          c.call(prefixField + "_mul", y, z, G),
          c.call(prefixField + "_add", D, D, x3),
          c.call(prefixField + "_sub", F, x3, x3),
          c.call(prefixField + "_add", C, C, eightC),
          c.call(prefixField + "_add", eightC, eightC, eightC),
          c.call(prefixField + "_add", eightC, eightC, eightC),
          c.call(prefixField + "_sub", D, x3, y3),
          c.call(prefixField + "_mul", y3, E, y3),
          c.call(prefixField + "_sub", y3, eightC, y3),
          c.call(prefixField + "_add", G, G, z3)
        );
      }
      function buildDoubleAffine() {
        const f = module3.addFunction(prefix + "_doubleAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const XX = c.i32_const(module3.alloc(n8));
        const YY = c.i32_const(module3.alloc(n8));
        const YYYY = c.i32_const(module3.alloc(n8));
        const S = c.i32_const(module3.alloc(n8));
        const M = c.i32_const(module3.alloc(n8));
        const eightYYYY = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p1")),
            [
              ...c.call(prefix + "_toJacobian", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          // XX = X1^2
          c.call(prefixField + "_square", x, XX),
          // YY = Y1^2
          c.call(prefixField + "_square", y, YY),
          // YYYY = YY^2
          c.call(prefixField + "_square", YY, YYYY),
          // S = 2*((X1+YY)^2-XX-YYYY)
          c.call(prefixField + "_add", x, YY, S),
          c.call(prefixField + "_square", S, S),
          c.call(prefixField + "_sub", S, XX, S),
          c.call(prefixField + "_sub", S, YYYY, S),
          c.call(prefixField + "_add", S, S, S),
          // M = 3*XX+a  (Hera a=0)
          c.call(prefixField + "_add", XX, XX, M),
          c.call(prefixField + "_add", M, XX, M),
          // Z3 = 2*Y1
          c.call(prefixField + "_add", y, y, z3),
          // T = M^2-2*S
          // X3 = T
          c.call(prefixField + "_square", M, x3),
          c.call(prefixField + "_sub", x3, S, x3),
          c.call(prefixField + "_sub", x3, S, x3),
          // Y3 = M*(S-T)-8*YYYY
          c.call(prefixField + "_add", YYYY, YYYY, eightYYYY),
          c.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
          c.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
          c.call(prefixField + "_sub", S, x3, y3),
          c.call(prefixField + "_mul", y3, M, y3),
          c.call(prefixField + "_sub", y3, eightYYYY, y3)
        );
      }
      function buildEqAffine() {
        const f = module3.addFunction(prefix + "_eqAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.ret(c.i32_and(
            c.call(
              prefixField + "_eq",
              c.getLocal("p1"),
              c.getLocal("p2")
            ),
            c.call(
              prefixField + "_eq",
              c.i32_add(c.getLocal("p1"), c.i32_const(n8)),
              c.i32_add(c.getLocal("p2"), c.i32_const(n8))
            )
          ))
        );
      }
      function buildToMontgomery() {
        const f = module3.addFunction(prefix + "_toMontgomery");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_toMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 3; i++) {
          f.addCode(c.call(
            prefixField + "_toMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildToMontgomeryAffine() {
        const f = module3.addFunction(prefix + "_toMontgomeryAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_toMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 2; i++) {
          f.addCode(c.call(
            prefixField + "_toMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildFromMontgomery() {
        const f = module3.addFunction(prefix + "_fromMontgomery");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_fromMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 3; i++) {
          f.addCode(c.call(
            prefixField + "_fromMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildFromMontgomeryAffine() {
        const f = module3.addFunction(prefix + "_fromMontgomeryAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(c.call(
          prefixField + "_fromMontgomery",
          c.getLocal("p1"),
          c.getLocal("pr")
        ));
        for (let i = 1; i < 2; i++) {
          f.addCode(c.call(
            prefixField + "_fromMontgomery",
            c.i32_add(c.getLocal("p1"), c.i32_const(i * n8)),
            c.i32_add(c.getLocal("pr"), c.i32_const(i * n8))
          ));
        }
      }
      function buildAdd() {
        const f = module3.addFunction(prefix + "_add");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");
        f.addLocal("z2", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        f.addCode(c.setLocal("z2", c.i32_add(c.getLocal("p2"), c.i32_const(n8 * 2))));
        const z2 = c.getLocal("z2");
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const Z2Z2 = c.i32_const(module3.alloc(n8));
        const U1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const Z2_cubed = c.i32_const(module3.alloc(n8));
        const S1 = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        const H = c.i32_const(module3.alloc(n8));
        const S2_minus_S1 = c.i32_const(module3.alloc(n8));
        const I = c.i32_const(module3.alloc(n8));
        const J = c.i32_const(module3.alloc(n8));
        const r = c.i32_const(module3.alloc(n8));
        const r2 = c.i32_const(module3.alloc(n8));
        const V = c.i32_const(module3.alloc(n8));
        const V2 = c.i32_const(module3.alloc(n8));
        const S1_J2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p2"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p2")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            [
              ...c.call(prefix + "_addMixed", x2, x1, x3),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z2),
            [
              ...c.call(prefix + "_addMixed", x1, x2, x3),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_square", z2, Z2Z2),
          c.call(prefixField + "_mul", x1, Z2Z2, U1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
          c.call(prefixField + "_mul", y1, Z2_cubed, S1),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", U1, U2),
            c.if(
              c.call(prefixField + "_eq", S1, S2),
              [
                ...c.call(prefix + "_double", c.getLocal("p1"), c.getLocal("pr")),
                ...c.ret([])
              ]
            )
          ),
          c.call(prefixField + "_sub", U2, U1, H),
          c.call(prefixField + "_sub", S2, S1, S2_minus_S1),
          c.call(prefixField + "_add", H, H, I),
          c.call(prefixField + "_square", I, I),
          c.call(prefixField + "_mul", H, I, J),
          c.call(prefixField + "_add", S2_minus_S1, S2_minus_S1, r),
          c.call(prefixField + "_mul", U1, I, V),
          c.call(prefixField + "_square", r, r2),
          c.call(prefixField + "_add", V, V, V2),
          c.call(prefixField + "_sub", r2, J, x3),
          c.call(prefixField + "_sub", x3, V2, x3),
          c.call(prefixField + "_mul", S1, J, S1_J2),
          c.call(prefixField + "_add", S1_J2, S1_J2, S1_J2),
          c.call(prefixField + "_sub", V, x3, y3),
          c.call(prefixField + "_mul", y3, r, y3),
          c.call(prefixField + "_sub", y3, S1_J2, y3),
          c.call(prefixField + "_add", z1, z2, z3),
          c.call(prefixField + "_square", z3, z3),
          c.call(prefixField + "_sub", z3, Z1Z1, z3),
          c.call(prefixField + "_sub", z3, Z2Z2, z3),
          c.call(prefixField + "_mul", z3, H, z3)
        );
      }
      function buildAddMixed() {
        const f = module3.addFunction(prefix + "_addMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const Z1Z1 = c.i32_const(module3.alloc(n8));
        const U2 = c.i32_const(module3.alloc(n8));
        const Z1_cubed = c.i32_const(module3.alloc(n8));
        const S2 = c.i32_const(module3.alloc(n8));
        const H = c.i32_const(module3.alloc(n8));
        const HH = c.i32_const(module3.alloc(n8));
        const S2_minus_y1 = c.i32_const(module3.alloc(n8));
        const I = c.i32_const(module3.alloc(n8));
        const J = c.i32_const(module3.alloc(n8));
        const r = c.i32_const(module3.alloc(n8));
        const r2 = c.i32_const(module3.alloc(n8));
        const V = c.i32_const(module3.alloc(n8));
        const V2 = c.i32_const(module3.alloc(n8));
        const y1_J2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copyAffine", c.getLocal("p2"), c.getLocal("pr")),
              ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
            [
              ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_isOne", z1),
            [
              ...c.call(prefix + "_addAffine", x1, x2, x3),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_square", z1, Z1Z1),
          c.call(prefixField + "_mul", x2, Z1Z1, U2),
          c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c.if(
            c.call(prefixField + "_eq", x1, U2),
            c.if(
              c.call(prefixField + "_eq", y1, S2),
              [
                ...c.call(prefix + "_doubleAffine", c.getLocal("p2"), c.getLocal("pr")),
                ...c.ret([])
              ]
            )
          ),
          c.call(prefixField + "_sub", U2, x1, H),
          c.call(prefixField + "_sub", S2, y1, S2_minus_y1),
          c.call(prefixField + "_square", H, HH),
          c.call(prefixField + "_add", HH, HH, I),
          c.call(prefixField + "_add", I, I, I),
          c.call(prefixField + "_mul", H, I, J),
          c.call(prefixField + "_add", S2_minus_y1, S2_minus_y1, r),
          c.call(prefixField + "_mul", x1, I, V),
          c.call(prefixField + "_square", r, r2),
          c.call(prefixField + "_add", V, V, V2),
          c.call(prefixField + "_sub", r2, J, x3),
          c.call(prefixField + "_sub", x3, V2, x3),
          c.call(prefixField + "_mul", y1, J, y1_J2),
          c.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
          c.call(prefixField + "_sub", V, x3, y3),
          c.call(prefixField + "_mul", y3, r, y3),
          c.call(prefixField + "_sub", y3, y1_J2, y3),
          c.call(prefixField + "_add", z1, H, z3),
          c.call(prefixField + "_square", z3, z3),
          c.call(prefixField + "_sub", z3, Z1Z1, z3),
          c.call(prefixField + "_sub", z3, HH, z3)
        );
      }
      function buildAddAffine() {
        const f = module3.addFunction(prefix + "_addAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");
        const c = f.getCodeBuilder();
        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2))));
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const H = c.i32_const(module3.alloc(n8));
        const HH = c.i32_const(module3.alloc(n8));
        const y2_minus_y1 = c.i32_const(module3.alloc(n8));
        const I = c.i32_const(module3.alloc(n8));
        const J = c.i32_const(module3.alloc(n8));
        const r = c.i32_const(module3.alloc(n8));
        const r2 = c.i32_const(module3.alloc(n8));
        const V = c.i32_const(module3.alloc(n8));
        const V2 = c.i32_const(module3.alloc(n8));
        const y1_J2 = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p1")),
            [
              ...c.call(prefix + "_copyAffine", c.getLocal("p2"), c.getLocal("pr")),
              ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
            [
              ...c.call(prefix + "_copyAffine", c.getLocal("p1"), c.getLocal("pr")),
              ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))),
              ...c.ret([])
            ]
          ),
          c.if(
            c.call(prefixField + "_eq", x1, x2),
            c.if(
              c.call(prefixField + "_eq", y1, y2),
              [
                ...c.call(prefix + "_doubleAffine", c.getLocal("p2"), c.getLocal("pr")),
                ...c.ret([])
              ]
            )
          ),
          c.call(prefixField + "_sub", x2, x1, H),
          c.call(prefixField + "_sub", y2, y1, y2_minus_y1),
          c.call(prefixField + "_square", H, HH),
          c.call(prefixField + "_add", HH, HH, I),
          c.call(prefixField + "_add", I, I, I),
          c.call(prefixField + "_mul", H, I, J),
          c.call(prefixField + "_add", y2_minus_y1, y2_minus_y1, r),
          c.call(prefixField + "_mul", x1, I, V),
          c.call(prefixField + "_square", r, r2),
          c.call(prefixField + "_add", V, V, V2),
          c.call(prefixField + "_sub", r2, J, x3),
          c.call(prefixField + "_sub", x3, V2, x3),
          c.call(prefixField + "_mul", y1, J, y1_J2),
          c.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
          c.call(prefixField + "_sub", V, x3, y3),
          c.call(prefixField + "_mul", y3, r, y3),
          c.call(prefixField + "_sub", y3, y1_J2, y3),
          c.call(prefixField + "_add", H, H, z3)
        );
      }
      function buildNeg() {
        const f = module3.addFunction(prefix + "_neg");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        f.addCode(
          c.call(prefixField + "_copy", x, x3),
          c.call(prefixField + "_neg", y, y3),
          c.call(prefixField + "_copy", z, z3)
        );
      }
      function buildNegAffine() {
        const f = module3.addFunction(prefix + "_negAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        f.addCode(
          c.call(prefixField + "_copy", x, x3),
          c.call(prefixField + "_neg", y, y3)
        );
      }
      function buildSub() {
        const f = module3.addFunction(prefix + "_sub");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8 * 3));
        f.addCode(
          c.call(prefix + "_neg", c.getLocal("p2"), AUX),
          c.call(prefix + "_add", c.getLocal("p1"), AUX, c.getLocal("pr"))
        );
      }
      function buildSubMixed() {
        const f = module3.addFunction(prefix + "_subMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8 * 3));
        f.addCode(
          c.call(prefix + "_negAffine", c.getLocal("p2"), AUX),
          c.call(prefix + "_addMixed", c.getLocal("p1"), AUX, c.getLocal("pr"))
        );
      }
      function buildSubAffine() {
        const f = module3.addFunction(prefix + "_subAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8 * 3));
        f.addCode(
          c.call(prefix + "_negAffine", c.getLocal("p2"), AUX),
          c.call(prefix + "_addAffine", c.getLocal("p1"), AUX, c.getLocal("pr"))
        );
      }
      function buildNormalize() {
        const f = module3.addFunction(prefix + "_normalize");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        const Z_inv = c.i32_const(module3.alloc(n8));
        const Z2_inv = c.i32_const(module3.alloc(n8));
        const Z3_inv = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            c.call(prefix + "_zero", c.getLocal("pr")),
            [
              ...c.call(prefixField + "_inverse", z, Z_inv),
              ...c.call(prefixField + "_square", Z_inv, Z2_inv),
              ...c.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
              ...c.call(prefixField + "_mul", x, Z2_inv, x3),
              ...c.call(prefixField + "_mul", y, Z3_inv, y3),
              ...c.call(prefixField + "_one", z3)
            ]
          )
        );
      }
      function buildToAffine() {
        const f = module3.addFunction(prefix + "_toAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8 * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const Z_inv = c.i32_const(module3.alloc(n8));
        const Z2_inv = c.i32_const(module3.alloc(n8));
        const Z3_inv = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("p1")),
            [
              ...c.call(prefixField + "_zero", x3),
              ...c.call(prefixField + "_zero", y3)
            ],
            [
              ...c.call(prefixField + "_inverse", z, Z_inv),
              ...c.call(prefixField + "_square", Z_inv, Z2_inv),
              ...c.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
              ...c.call(prefixField + "_mul", x, Z2_inv, x3),
              ...c.call(prefixField + "_mul", y, Z3_inv, y3)
            ]
          )
        );
      }
      function buildToJacobian() {
        const f = module3.addFunction(prefix + "_toJacobian");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2));
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("p1")),
            c.call(prefix + "_zero", c.getLocal("pr")),
            [
              ...c.call(prefixField + "_one", z3),
              ...c.call(prefixField + "_copy", y, y3),
              ...c.call(prefixField + "_copy", x, x3)
            ]
          )
        );
      }
      function buildBatchToAffine() {
        const f = module3.addFunction(prefix + "_batchToAffine");
        f.addParam("pIn", "i32");
        f.addParam("n", "i32");
        f.addParam("pOut", "i32");
        f.addLocal("pAux", "i32");
        f.addLocal("itIn", "i32");
        f.addLocal("itAux", "i32");
        f.addLocal("itOut", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const tmp = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("pAux", c.i32_load(c.i32_const(0))),
          c.i32_store(
            c.i32_const(0),
            c.i32_add(
              c.getLocal("pAux"),
              c.i32_mul(c.getLocal("n"), c.i32_const(n8))
            )
          ),
          c.call(
            prefixField + "_batchInverse",
            c.i32_add(c.getLocal("pIn"), c.i32_const(n8 * 2)),
            c.i32_const(n8 * 3),
            c.getLocal("n"),
            c.getLocal("pAux"),
            c.i32_const(n8)
          ),
          c.setLocal("itIn", c.getLocal("pIn")),
          c.setLocal("itAux", c.getLocal("pAux")),
          c.setLocal("itOut", c.getLocal("pOut")),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
            c.if(
              c.call(prefixField + "_isZero", c.getLocal("itAux")),
              [
                ...c.call(prefixField + "_zero", c.getLocal("itOut")),
                ...c.call(prefixField + "_zero", c.i32_add(c.getLocal("itOut"), c.i32_const(n8)))
              ],
              [
                ...c.call(
                  prefixField + "_mul",
                  c.getLocal("itAux"),
                  c.i32_add(c.getLocal("itIn"), c.i32_const(n8)),
                  tmp
                ),
                ...c.call(
                  prefixField + "_square",
                  c.getLocal("itAux"),
                  c.getLocal("itAux")
                ),
                ...c.call(
                  prefixField + "_mul",
                  c.getLocal("itAux"),
                  c.getLocal("itIn"),
                  c.getLocal("itOut")
                ),
                ...c.call(
                  prefixField + "_mul",
                  c.getLocal("itAux"),
                  tmp,
                  c.i32_add(c.getLocal("itOut"), c.i32_const(n8))
                )
              ]
            ),
            c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.i32_const(n8 * 3))),
            c.setLocal("itOut", c.i32_add(c.getLocal("itOut"), c.i32_const(n8 * 2))),
            c.setLocal("itAux", c.i32_add(c.getLocal("itAux"), c.i32_const(n8))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          )),
          c.i32_store(
            c.i32_const(0),
            c.getLocal("pAux")
          )
        );
      }
      function buildReverseBytes() {
        const f = module3.addFunction(prefix + "__reverseBytes");
        f.addParam("pIn", "i32");
        f.addParam("n", "i32");
        f.addParam("pOut", "i32");
        f.addLocal("itOut", "i32");
        f.addLocal("itIn", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "itOut",
            c.i32_sub(
              c.i32_add(
                c.getLocal("pOut"),
                c.getLocal("n")
              ),
              c.i32_const(1)
            )
          ),
          c.setLocal(
            "itIn",
            c.getLocal("pIn")
          ),
          c.block(c.loop(
            c.br_if(1, c.i32_lt_s(c.getLocal("itOut"), c.getLocal("pOut"))),
            c.i32_store8(
              c.getLocal("itOut"),
              c.i32_load8_u(c.getLocal("itIn"))
            ),
            c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.i32_const(1))),
            c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildLEMtoC() {
        const f = module3.addFunction(prefix + "_LEMtoC");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        const c = f.getCodeBuilder();
        const tmp = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.if(
            c.call(prefix + "_isZero", c.getLocal("pIn")),
            [
              ...c.call(prefixField + "_zero", c.getLocal("pOut")),
              ...c.i32_store8(
                c.getLocal("pOut"),
                c.i32_const(64)
              ),
              ...c.ret([])
            ]
          ),
          c.call(prefixField + "_fromMontgomery", c.getLocal("pIn"), tmp),
          c.call(prefix + "__reverseBytes", tmp, c.i32_const(n8), c.getLocal("pOut")),
          c.if(
            c.i32_eq(
              c.call(prefixField + "_sign", c.i32_add(c.getLocal("pIn"), c.i32_const(n8))),
              c.i32_const(-1)
            ),
            c.i32_store8(
              c.getLocal("pOut"),
              c.i32_or(
                c.i32_load8_u(c.getLocal("pOut")),
                c.i32_const(128)
              )
            )
          )
        );
      }
      function buildLEMtoU() {
        const f = module3.addFunction(prefix + "_LEMtoU");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        const c = f.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmp = c.i32_const(pTmp);
        const tmpX = c.i32_const(pTmp);
        const tmpY = c.i32_const(pTmp + n8);
        f.addCode(
          c.if(
            c.call(prefix + "_isZeroAffine", c.getLocal("pIn")),
            [
              ...c.call(prefix + "_zeroAffine", c.getLocal("pOut")),
              ...c.i32_store8(
                c.getLocal("pOut"),
                c.i32_const(64)
              ),
              ...c.ret([])
            ]
          ),
          c.call(prefix + "_fromMontgomeryAffine", c.getLocal("pIn"), tmp),
          c.call(prefix + "__reverseBytes", tmpX, c.i32_const(n8), c.getLocal("pOut")),
          c.call(prefix + "__reverseBytes", tmpY, c.i32_const(n8), c.i32_add(c.getLocal("pOut"), c.i32_const(n8)))
        );
      }
      function buildUtoLEM() {
        const f = module3.addFunction(prefix + "_UtoLEM");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        const c = f.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmp = c.i32_const(pTmp);
        const tmpX = c.i32_const(pTmp);
        const tmpY = c.i32_const(pTmp + n8);
        f.addCode(
          c.if(
            c.i32_and(c.i32_load8_u(c.getLocal("pIn")), c.i32_const(64)),
            [
              ...c.call(prefix + "_zeroAffine", c.getLocal("pOut")),
              ...c.ret([])
            ]
          ),
          c.call(prefix + "__reverseBytes", c.getLocal("pIn"), c.i32_const(n8), tmpX),
          c.call(prefix + "__reverseBytes", c.i32_add(c.getLocal("pIn"), c.i32_const(n8)), c.i32_const(n8), tmpY),
          c.call(prefix + "_toMontgomeryAffine", tmp, c.getLocal("pOut"))
        );
      }
      function buildCtoLEM() {
        const f = module3.addFunction(prefix + "_CtoLEM");
        f.addParam("pIn", "i32");
        f.addParam("pOut", "i32");
        f.addLocal("firstByte", "i32");
        f.addLocal("greatest", "i32");
        const c = f.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmpX = c.i32_const(pTmp);
        const tmpY = c.i32_const(pTmp + n8);
        f.addCode(
          c.setLocal("firstByte", c.i32_load8_u(c.getLocal("pIn"))),
          c.if(
            c.i32_and(
              c.getLocal("firstByte"),
              c.i32_const(64)
            ),
            [
              ...c.call(prefix + "_zeroAffine", c.getLocal("pOut")),
              ...c.ret([])
            ]
          ),
          c.setLocal(
            "greatest",
            c.i32_and(
              c.getLocal("firstByte"),
              c.i32_const(128)
            )
          ),
          c.call(prefixField + "_copy", c.getLocal("pIn"), tmpY),
          c.i32_store8(tmpY, c.i32_and(c.getLocal("firstByte"), c.i32_const(63))),
          c.call(prefix + "__reverseBytes", tmpY, c.i32_const(n8), tmpX),
          c.call(prefixField + "_toMontgomery", tmpX, c.getLocal("pOut")),
          c.call(prefixField + "_square", c.getLocal("pOut"), tmpY),
          c.call(prefixField + "_mul", c.getLocal("pOut"), tmpY, tmpY),
          c.call(prefixField + "_add", tmpY, c.i32_const(pB), tmpY),
          c.call(prefixField + "_sqrt", tmpY, tmpY),
          c.call(prefixField + "_neg", tmpY, tmpX),
          c.if(
            c.i32_eq(
              c.call(prefixField + "_sign", tmpY),
              c.i32_const(-1)
            ),
            c.if(
              c.getLocal("greatest"),
              c.call(prefixField + "_copy", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8))),
              c.call(prefixField + "_neg", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8)))
            ),
            c.if(
              c.getLocal("greatest"),
              c.call(prefixField + "_neg", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8))),
              c.call(prefixField + "_copy", tmpY, c.i32_add(c.getLocal("pOut"), c.i32_const(n8)))
            )
          )
        );
      }
      function buildInCurveAffine() {
        const f = module3.addFunction(prefix + "_inCurveAffine");
        f.addParam("pIn", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("pIn");
        const y = c.i32_add(c.getLocal("pIn"), c.i32_const(n8));
        const y2 = c.i32_const(module3.alloc(n8));
        const x3b = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call(prefixField + "_square", y, y2),
          c.call(prefixField + "_square", x, x3b),
          c.call(prefixField + "_mul", x, x3b, x3b),
          c.call(prefixField + "_add", x3b, c.i32_const(pB), x3b),
          c.ret(
            c.call(prefixField + "_eq", y2, x3b)
          )
        );
      }
      function buildInCurve() {
        const f = module3.addFunction(prefix + "_inCurve");
        f.addParam("pIn", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8 * 2));
        f.addCode(
          c.call(prefix + "_toAffine", c.getLocal("pIn"), aux),
          c.ret(
            c.call(prefix + "_inCurveAffine", aux)
          )
        );
      }
      buildIsZeroAffine();
      buildIsZero();
      buildZeroAffine();
      buildZero();
      buildCopyAffine();
      buildCopy();
      buildToJacobian();
      buildEqAffine();
      buildEqMixed();
      buildEq();
      buildDoubleAffine();
      buildDouble();
      buildAddAffine();
      buildAddMixed();
      buildAdd();
      buildNegAffine();
      buildNeg();
      buildSubAffine();
      buildSubMixed();
      buildSub();
      buildFromMontgomeryAffine();
      buildFromMontgomery();
      buildToMontgomeryAffine();
      buildToMontgomery();
      buildToAffine();
      buildInCurveAffine();
      buildInCurve();
      buildBatchToAffine();
      buildNormalize();
      buildReverseBytes();
      buildLEMtoU();
      buildLEMtoC();
      buildUtoLEM();
      buildCtoLEM();
      buildBatchConvertion(module3, prefix + "_batchLEMtoU", prefix + "_LEMtoU", n8 * 2, n8 * 2);
      buildBatchConvertion(module3, prefix + "_batchLEMtoC", prefix + "_LEMtoC", n8 * 2, n8);
      buildBatchConvertion(module3, prefix + "_batchUtoLEM", prefix + "_UtoLEM", n8 * 2, n8 * 2);
      buildBatchConvertion(module3, prefix + "_batchCtoLEM", prefix + "_CtoLEM", n8, n8 * 2, true);
      buildBatchConvertion(module3, prefix + "_batchToJacobian", prefix + "_toJacobian", n8 * 2, n8 * 3, true);
      buildMultiexp4(module3, prefix, prefix + "_multiexp", prefix + "_add", n8 * 3);
      buildMultiexp4(module3, prefix, prefix + "_multiexpAffine", prefix + "_addMixed", n8 * 2);
      buildTimesScalarNAF(
        module3,
        prefix + "_timesScalar",
        n8 * 3,
        prefix + "_add",
        prefix + "_double",
        prefix + "_sub",
        prefix + "_copy",
        prefix + "_zero"
      );
      buildTimesScalarNAF(
        module3,
        prefix + "_timesScalarAffine",
        n8 * 2,
        prefix + "_addMixed",
        prefix + "_double",
        prefix + "_subMixed",
        prefix + "_copyAffine",
        prefix + "_zero"
      );
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isZeroAffine");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_eqMixed");
      module3.exportFunction(prefix + "_eqAffine");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_copyAffine");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_zeroAffine");
      module3.exportFunction(prefix + "_double");
      module3.exportFunction(prefix + "_doubleAffine");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_addMixed");
      module3.exportFunction(prefix + "_addAffine");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_negAffine");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_subMixed");
      module3.exportFunction(prefix + "_subAffine");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_fromMontgomeryAffine");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_toMontgomeryAffine");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_timesScalarAffine");
      module3.exportFunction(prefix + "_normalize");
      module3.exportFunction(prefix + "_LEMtoU");
      module3.exportFunction(prefix + "_LEMtoC");
      module3.exportFunction(prefix + "_UtoLEM");
      module3.exportFunction(prefix + "_CtoLEM");
      module3.exportFunction(prefix + "_batchLEMtoU");
      module3.exportFunction(prefix + "_batchLEMtoC");
      module3.exportFunction(prefix + "_batchUtoLEM");
      module3.exportFunction(prefix + "_batchCtoLEM");
      module3.exportFunction(prefix + "_toAffine");
      module3.exportFunction(prefix + "_toJacobian");
      module3.exportFunction(prefix + "_batchToAffine");
      module3.exportFunction(prefix + "_batchToJacobian");
      module3.exportFunction(prefix + "_inCurve");
      module3.exportFunction(prefix + "_inCurveAffine");
      return prefix;
    };
  }
});

// ../../node_modules/wasmcurves/src/build_fft.js
var require_build_fft3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_fft.js"(exports, module2) {
    "use strict";
    var { isOdd: isOdd4, modInv, modPow } = require_bigint3();
    var utils2 = require_utils3();
    module2.exports = function buildFFT4(module3, prefix, gPrefix, fPrefix, opGtimesF) {
      const n64f = module3.modules[fPrefix].n64;
      const n8f = n64f * 8;
      const n64g = module3.modules[gPrefix].n64;
      const n8g = n64g * 8;
      const q = module3.modules[fPrefix].q;
      let rem = q - 1n;
      let maxBits = 0;
      while (!isOdd4(rem)) {
        maxBits++;
        rem = rem >> 1n;
      }
      let nr = 2n;
      while (modPow(nr, q >> 1n, q) === 1n)
        nr = nr + 1n;
      const w = new Array(maxBits + 1);
      w[maxBits] = modPow(nr, rem, q);
      let n = maxBits - 1;
      while (n >= 0) {
        w[n] = modPow(w[n + 1], 2n, q);
        n--;
      }
      const bytes = [];
      const R = (1n << BigInt(n8f * 8)) % q;
      for (let i = 0; i < w.length; i++) {
        const m = w[i] * R % q;
        bytes.push(...utils2.bigInt2BytesLE(m, n8f));
      }
      const ROOTs = module3.alloc(bytes);
      const i2 = new Array(maxBits + 1);
      i2[0] = 1n;
      for (let i = 1; i <= maxBits; i++) {
        i2[i] = i2[i - 1] * 2n;
      }
      const bytesi2 = [];
      for (let i = 0; i <= maxBits; i++) {
        const m = modInv(i2[i], q) * R % q;
        bytesi2.push(...utils2.bigInt2BytesLE(m, n8f));
      }
      const INV2 = module3.alloc(bytesi2);
      const shift = modPow(nr, 2n, q);
      const bytesShiftToSmallM = [];
      const bytesSConst = [];
      for (let i = 0; i <= maxBits; i++) {
        const shiftToSmallM = modPow(shift, 2n ** BigInt(i), q);
        const sConst = modInv(q + 1n - shiftToSmallM, q);
        bytesShiftToSmallM.push(...utils2.bigInt2BytesLE(shiftToSmallM * R % q, n8f));
        bytesSConst.push(...utils2.bigInt2BytesLE(sConst * R % q, n8f));
      }
      const SHIFT_TO_M = module3.alloc(bytesShiftToSmallM);
      const SCONST = module3.alloc(bytesSConst);
      function rev(x) {
        let r = 0;
        for (let i = 0; i < 8; i++) {
          if (x & 1 << i) {
            r = r | 128 >> i;
          }
        }
        return r;
      }
      const rtable = Array(256);
      for (let i = 0; i < 256; i++) {
        rtable[i] = rev(i);
      }
      const REVTABLE = module3.alloc(rtable);
      function buildLog2() {
        const f = module3.addFunction(prefix + "__log2");
        f.addParam("n", "i32");
        f.setReturnType("i32");
        f.addLocal("bits", "i32");
        f.addLocal("aux", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "aux",
            c.i32_shr_u(
              c.getLocal("n"),
              c.i32_const(1)
            )
          )
        );
        f.addCode(c.setLocal("bits", c.i32_const(0)));
        f.addCode(c.block(c.loop(
          c.br_if(
            1,
            c.i32_eqz(c.getLocal("aux"))
          ),
          c.setLocal(
            "aux",
            c.i32_shr_u(
              c.getLocal("aux"),
              c.i32_const(1)
            )
          ),
          c.setLocal(
            "bits",
            c.i32_add(
              c.getLocal("bits"),
              c.i32_const(1)
            )
          ),
          c.br(0)
        )));
        f.addCode(c.if(
          c.i32_ne(
            c.getLocal("n"),
            c.i32_shl(
              c.i32_const(1),
              c.getLocal("bits")
            )
          ),
          c.unreachable()
        ));
        f.addCode(c.if(
          c.i32_gt_u(
            c.getLocal("bits"),
            c.i32_const(maxBits)
          ),
          c.unreachable()
        ));
        f.addCode(c.getLocal("bits"));
      }
      function buildFFT5() {
        const f = module3.addFunction(prefix + "_fft");
        f.addParam("px", "i32");
        f.addParam("n", "i32");
        f.addLocal("bits", "i32");
        const c = f.getCodeBuilder();
        const One = c.i32_const(module3.alloc(n8f));
        f.addCode(
          c.setLocal(
            "bits",
            c.call(
              prefix + "__log2",
              c.getLocal("n")
            )
          ),
          c.call(fPrefix + "_one", One),
          c.call(
            prefix + "_rawfft",
            c.getLocal("px"),
            c.getLocal("bits"),
            c.i32_const(0),
            One
          )
        );
      }
      function buildIFFT() {
        const f = module3.addFunction(prefix + "_ifft");
        f.addParam("px", "i32");
        f.addParam("n", "i32");
        f.addLocal("bits", "i32");
        f.addLocal("pInv2", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal(
            "bits",
            c.call(
              prefix + "__log2",
              c.getLocal("n")
            )
          ),
          c.setLocal(
            "pInv2",
            c.i32_add(
              c.i32_const(INV2),
              c.i32_mul(
                c.getLocal("bits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(
            prefix + "_rawfft",
            c.getLocal("px"),
            c.getLocal("bits"),
            c.i32_const(1),
            c.getLocal("pInv2")
          )
        );
      }
      function buildRawFFT() {
        const f = module3.addFunction(prefix + "_rawfft");
        f.addParam("px", "i32");
        f.addParam("bits", "i32");
        f.addParam("reverse", "i32");
        f.addParam("mulFactor", "i32");
        f.addLocal("s", "i32");
        f.addLocal("k", "i32");
        f.addLocal("j", "i32");
        f.addLocal("m", "i32");
        f.addLocal("mdiv2", "i32");
        f.addLocal("n", "i32");
        f.addLocal("pwm", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const T = c.i32_const(module3.alloc(n8g));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.call(prefix + "__reversePermutation", c.getLocal("px"), c.getLocal("bits")),
          c.setLocal("n", c.i32_shl(c.i32_const(1), c.getLocal("bits"))),
          c.setLocal("s", c.i32_const(1)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_gt_u(
                c.getLocal("s"),
                c.getLocal("bits")
              )
            ),
            c.setLocal("m", c.i32_shl(c.i32_const(1), c.getLocal("s"))),
            c.setLocal(
              "pwm",
              c.i32_add(
                c.i32_const(ROOTs),
                c.i32_mul(
                  c.getLocal("s"),
                  c.i32_const(n8f)
                )
              )
            ),
            c.setLocal("k", c.i32_const(0)),
            c.block(c.loop(
              c.br_if(
                1,
                c.i32_ge_u(
                  c.getLocal("k"),
                  c.getLocal("n")
                )
              ),
              c.call(fPrefix + "_one", W),
              c.setLocal("mdiv2", c.i32_shr_u(c.getLocal("m"), c.i32_const(1))),
              c.setLocal("j", c.i32_const(0)),
              c.block(c.loop(
                c.br_if(
                  1,
                  c.i32_ge_u(
                    c.getLocal("j"),
                    c.getLocal("mdiv2")
                  )
                ),
                c.setLocal(
                  "idx1",
                  c.i32_add(
                    c.getLocal("px"),
                    c.i32_mul(
                      c.i32_add(
                        c.getLocal("k"),
                        c.getLocal("j")
                      ),
                      c.i32_const(n8g)
                    )
                  )
                ),
                c.setLocal(
                  "idx2",
                  c.i32_add(
                    c.getLocal("idx1"),
                    c.i32_mul(
                      c.getLocal("mdiv2"),
                      c.i32_const(n8g)
                    )
                  )
                ),
                c.call(
                  opGtimesF,
                  c.getLocal("idx2"),
                  W,
                  T
                ),
                c.call(
                  gPrefix + "_copy",
                  c.getLocal("idx1"),
                  U
                ),
                c.call(
                  gPrefix + "_add",
                  U,
                  T,
                  c.getLocal("idx1")
                ),
                c.call(
                  gPrefix + "_sub",
                  U,
                  T,
                  c.getLocal("idx2")
                ),
                c.call(
                  fPrefix + "_mul",
                  W,
                  c.getLocal("pwm"),
                  W
                ),
                c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
                c.br(0)
              )),
              c.setLocal("k", c.i32_add(c.getLocal("k"), c.getLocal("m"))),
              c.br(0)
            )),
            c.setLocal("s", c.i32_add(c.getLocal("s"), c.i32_const(1))),
            c.br(0)
          )),
          c.call(
            prefix + "__fftFinal",
            c.getLocal("px"),
            c.getLocal("bits"),
            c.getLocal("reverse"),
            c.getLocal("mulFactor")
          )
        );
      }
      function buildFinalInverse() {
        const f = module3.addFunction(prefix + "__fftFinal");
        f.addParam("px", "i32");
        f.addParam("bits", "i32");
        f.addParam("reverse", "i32");
        f.addParam("mulFactor", "i32");
        f.addLocal("n", "i32");
        f.addLocal("ndiv2", "i32");
        f.addLocal("pInv2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("mask", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        const c = f.getCodeBuilder();
        const T = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.if(
            c.i32_and(
              c.i32_eqz(c.getLocal("reverse")),
              c.call(fPrefix + "_isOne", c.getLocal("mulFactor"))
            ),
            c.ret([])
          ),
          c.setLocal("n", c.i32_shl(c.i32_const(1), c.getLocal("bits"))),
          c.setLocal("mask", c.i32_sub(c.getLocal("n"), c.i32_const(1))),
          c.setLocal("i", c.i32_const(1)),
          c.setLocal(
            "ndiv2",
            c.i32_shr_u(
              c.getLocal("n"),
              c.i32_const(1)
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_ge_u(
                c.getLocal("i"),
                c.getLocal("ndiv2")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.i32_sub(
                    c.getLocal("n"),
                    c.getLocal("i")
                  ),
                  c.i32_const(n8g)
                )
              )
            ),
            c.if(
              c.getLocal("reverse"),
              c.if(
                c.call(fPrefix + "_isOne", c.getLocal("mulFactor")),
                [
                  ...c.call(gPrefix + "_copy", c.getLocal("idx1"), T),
                  ...c.call(gPrefix + "_copy", c.getLocal("idx2"), c.getLocal("idx1")),
                  ...c.call(gPrefix + "_copy", T, c.getLocal("idx2"))
                ],
                [
                  ...c.call(gPrefix + "_copy", c.getLocal("idx1"), T),
                  ...c.call(opGtimesF, c.getLocal("idx2"), c.getLocal("mulFactor"), c.getLocal("idx1")),
                  ...c.call(opGtimesF, T, c.getLocal("mulFactor"), c.getLocal("idx2"))
                ]
              ),
              c.if(
                c.call(fPrefix + "_isOne", c.getLocal("mulFactor")),
                [
                  // Do nothing (It should not be here)
                ],
                [
                  ...c.call(opGtimesF, c.getLocal("idx1"), c.getLocal("mulFactor"), c.getLocal("idx1")),
                  ...c.call(opGtimesF, c.getLocal("idx2"), c.getLocal("mulFactor"), c.getLocal("idx2"))
                ]
              )
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          )),
          c.if(
            c.call(fPrefix + "_isOne", c.getLocal("mulFactor")),
            [
              // Do nothing (It should not be here)
            ],
            [
              ...c.call(opGtimesF, c.getLocal("px"), c.getLocal("mulFactor"), c.getLocal("px")),
              ...c.setLocal(
                "idx2",
                c.i32_add(
                  c.getLocal("px"),
                  c.i32_mul(
                    c.getLocal("ndiv2"),
                    c.i32_const(n8g)
                  )
                )
              ),
              ...c.call(opGtimesF, c.getLocal("idx2"), c.getLocal("mulFactor"), c.getLocal("idx2"))
            ]
          )
        );
      }
      function buildReversePermutation() {
        const f = module3.addFunction(prefix + "__reversePermutation");
        f.addParam("px", "i32");
        f.addParam("bits", "i32");
        f.addLocal("n", "i32");
        f.addLocal("i", "i32");
        f.addLocal("ri", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        const c = f.getCodeBuilder();
        const T = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal("n", c.i32_shl(c.i32_const(1), c.getLocal("bits"))),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal("ri", c.call(prefix + "__rev", c.getLocal("i"), c.getLocal("bits"))),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("px"),
                c.i32_mul(
                  c.getLocal("ri"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.if(
              c.i32_lt_u(
                c.getLocal("i"),
                c.getLocal("ri")
              ),
              [
                ...c.call(gPrefix + "_copy", c.getLocal("idx1"), T),
                ...c.call(gPrefix + "_copy", c.getLocal("idx2"), c.getLocal("idx1")),
                ...c.call(gPrefix + "_copy", T, c.getLocal("idx2"))
              ]
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildRev() {
        const f = module3.addFunction(prefix + "__rev");
        f.addParam("x", "i32");
        f.addParam("bits", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.i32_rotl(
            c.i32_add(
              c.i32_add(
                c.i32_shl(
                  c.i32_load8_u(
                    c.i32_and(
                      c.getLocal("x"),
                      c.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c.i32_const(24)
                ),
                c.i32_shl(
                  c.i32_load8_u(
                    c.i32_and(
                      c.i32_shr_u(
                        c.getLocal("x"),
                        c.i32_const(8)
                      ),
                      c.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c.i32_const(16)
                )
              ),
              c.i32_add(
                c.i32_shl(
                  c.i32_load8_u(
                    c.i32_and(
                      c.i32_shr_u(
                        c.getLocal("x"),
                        c.i32_const(16)
                      ),
                      c.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c.i32_const(8)
                ),
                c.i32_load8_u(
                  c.i32_and(
                    c.i32_shr_u(
                      c.getLocal("x"),
                      c.i32_const(24)
                    ),
                    c.i32_const(255)
                  ),
                  REVTABLE,
                  0
                )
              )
            ),
            c.getLocal("bits")
          )
        );
      }
      function buildFFTJoin() {
        const f = module3.addFunction(prefix + "_fftJoin");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const T = c.i32_const(module3.alloc(n8g));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              T
            ),
            c.call(
              gPrefix + "_copy",
              c.getLocal("idx1"),
              U
            ),
            c.call(
              gPrefix + "_add",
              U,
              T,
              c.getLocal("idx1")
            ),
            c.call(
              gPrefix + "_sub",
              U,
              T,
              c.getLocal("idx2")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTJoinExt() {
        const f = module3.addFunction(prefix + "_fftJoinExt");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addParam("totalBits", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("pShiftToM", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal(
            "pShiftToM",
            c.i32_add(
              c.i32_const(SHIFT_TO_M),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              gPrefix + "_add",
              c.getLocal("idx1"),
              c.getLocal("idx2"),
              U
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              c.getLocal("pShiftToM"),
              c.getLocal("idx2")
            ),
            c.call(
              gPrefix + "_add",
              c.getLocal("idx1"),
              c.getLocal("idx2"),
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              c.getLocal("idx2")
            ),
            c.call(
              gPrefix + "_copy",
              U,
              c.getLocal("idx1")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTJoinExtInv() {
        const f = module3.addFunction(prefix + "_fftJoinExtInv");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addParam("totalBits", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("pShiftToM", "i32");
        f.addLocal("pSConst", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal(
            "pShiftToM",
            c.i32_add(
              c.i32_const(SHIFT_TO_M),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.setLocal(
            "pSConst",
            c.i32_add(
              c.i32_const(SCONST),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              U
            ),
            c.call(
              gPrefix + "_sub",
              c.getLocal("idx1"),
              U,
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              c.getLocal("pSConst"),
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("pShiftToM"),
              c.getLocal("idx1")
            ),
            c.call(
              gPrefix + "_sub",
              U,
              c.getLocal("idx1"),
              c.getLocal("idx1")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("pSConst"),
              c.getLocal("idx1")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildPrepareLagrangeEvaluation() {
        const f = module3.addFunction(prefix + "_prepareLagrangeEvaluation");
        f.addParam("pBuff1", "i32");
        f.addParam("pBuff2", "i32");
        f.addParam("n", "i32");
        f.addParam("first", "i32");
        f.addParam("inc", "i32");
        f.addParam("totalBits", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("pShiftToM", "i32");
        f.addLocal("pSConst", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal(
            "pShiftToM",
            c.i32_add(
              c.i32_const(SHIFT_TO_M),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.setLocal(
            "pSConst",
            c.i32_add(
              c.i32_const(SCONST),
              c.i32_mul(
                c.getLocal("totalBits"),
                c.i32_const(n8f)
              )
            )
          ),
          c.call(fPrefix + "_copy", c.getLocal("first"), W),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("n")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff1"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff2"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("pShiftToM"),
              U
            ),
            c.call(
              gPrefix + "_sub",
              c.getLocal("idx2"),
              U,
              U
            ),
            c.call(
              gPrefix + "_sub",
              c.getLocal("idx1"),
              c.getLocal("idx2"),
              c.getLocal("idx2")
            ),
            c.call(
              opGtimesF,
              U,
              c.getLocal("pSConst"),
              c.getLocal("idx1")
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              W,
              c.getLocal("idx2")
            ),
            c.call(
              fPrefix + "_mul",
              W,
              c.getLocal("inc"),
              W
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTMix() {
        const f = module3.addFunction(prefix + "_fftMix");
        f.addParam("pBuff", "i32");
        f.addParam("n", "i32");
        f.addParam("exp", "i32");
        f.addLocal("nGroups", "i32");
        f.addLocal("nPerGroup", "i32");
        f.addLocal("nPerGroupDiv2", "i32");
        f.addLocal("pairOffset", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("pwm", "i32");
        const c = f.getCodeBuilder();
        const W = c.i32_const(module3.alloc(n8f));
        const T = c.i32_const(module3.alloc(n8g));
        const U = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal("nPerGroup", c.i32_shl(c.i32_const(1), c.getLocal("exp"))),
          c.setLocal("nPerGroupDiv2", c.i32_shr_u(c.getLocal("nPerGroup"), c.i32_const(1))),
          c.setLocal("nGroups", c.i32_shr_u(c.getLocal("n"), c.getLocal("exp"))),
          c.setLocal("pairOffset", c.i32_mul(c.getLocal("nPerGroupDiv2"), c.i32_const(n8g))),
          c.setLocal(
            "pwm",
            c.i32_add(
              c.i32_const(ROOTs),
              c.i32_mul(
                c.getLocal("exp"),
                c.i32_const(n8f)
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("nGroups")
              )
            ),
            c.call(fPrefix + "_one", W),
            c.setLocal("j", c.i32_const(0)),
            c.block(c.loop(
              c.br_if(
                1,
                c.i32_eq(
                  c.getLocal("j"),
                  c.getLocal("nPerGroupDiv2")
                )
              ),
              c.setLocal(
                "idx1",
                c.i32_add(
                  c.getLocal("pBuff"),
                  c.i32_mul(
                    c.i32_add(
                      c.i32_mul(
                        c.getLocal("i"),
                        c.getLocal("nPerGroup")
                      ),
                      c.getLocal("j")
                    ),
                    c.i32_const(n8g)
                  )
                )
              ),
              c.setLocal(
                "idx2",
                c.i32_add(
                  c.getLocal("idx1"),
                  c.getLocal("pairOffset")
                )
              ),
              c.call(
                opGtimesF,
                c.getLocal("idx2"),
                W,
                T
              ),
              c.call(
                gPrefix + "_copy",
                c.getLocal("idx1"),
                U
              ),
              c.call(
                gPrefix + "_add",
                U,
                T,
                c.getLocal("idx1")
              ),
              c.call(
                gPrefix + "_sub",
                U,
                T,
                c.getLocal("idx2")
              ),
              c.call(
                fPrefix + "_mul",
                W,
                c.getLocal("pwm"),
                W
              ),
              c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
              c.br(0)
            )),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFFTFinal() {
        const f = module3.addFunction(prefix + "_fftFinal");
        f.addParam("pBuff", "i32");
        f.addParam("n", "i32");
        f.addParam("factor", "i32");
        f.addLocal("idx1", "i32");
        f.addLocal("idx2", "i32");
        f.addLocal("i", "i32");
        f.addLocal("ndiv2", "i32");
        const c = f.getCodeBuilder();
        const T = c.i32_const(module3.alloc(n8g));
        f.addCode(
          c.setLocal("ndiv2", c.i32_shr_u(c.getLocal("n"), c.i32_const(1))),
          c.if(
            c.i32_and(
              c.getLocal("n"),
              c.i32_const(1)
            ),
            c.call(
              opGtimesF,
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.getLocal("ndiv2"),
                  c.i32_const(n8g)
                )
              ),
              c.getLocal("factor"),
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.getLocal("ndiv2"),
                  c.i32_const(n8g)
                )
              )
            )
          ),
          c.setLocal("i", c.i32_const(0)),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_ge_u(
                c.getLocal("i"),
                c.getLocal("ndiv2")
              )
            ),
            c.setLocal(
              "idx1",
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.getLocal("i"),
                  c.i32_const(n8g)
                )
              )
            ),
            c.setLocal(
              "idx2",
              c.i32_add(
                c.getLocal("pBuff"),
                c.i32_mul(
                  c.i32_sub(
                    c.i32_sub(
                      c.getLocal("n"),
                      c.i32_const(1)
                    ),
                    c.getLocal("i")
                  ),
                  c.i32_const(n8g)
                )
              )
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx2"),
              c.getLocal("factor"),
              T
            ),
            c.call(
              opGtimesF,
              c.getLocal("idx1"),
              c.getLocal("factor"),
              c.getLocal("idx2")
            ),
            c.call(
              gPrefix + "_copy",
              T,
              c.getLocal("idx1")
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      buildRev();
      buildReversePermutation();
      buildFinalInverse();
      buildRawFFT();
      buildLog2();
      buildFFT5();
      buildIFFT();
      buildFFTJoin();
      buildFFTJoinExt();
      buildFFTJoinExtInv();
      buildFFTMix();
      buildFFTFinal();
      buildPrepareLagrangeEvaluation();
      module3.exportFunction(prefix + "_fft");
      module3.exportFunction(prefix + "_ifft");
      module3.exportFunction(prefix + "_rawfft");
      module3.exportFunction(prefix + "_fftJoin");
      module3.exportFunction(prefix + "_fftJoinExt");
      module3.exportFunction(prefix + "_fftJoinExtInv");
      module3.exportFunction(prefix + "_fftMix");
      module3.exportFunction(prefix + "_fftFinal");
      module3.exportFunction(prefix + "_prepareLagrangeEvaluation");
    };
  }
});

// ../../node_modules/wasmcurves/src/build_pol.js
var require_build_pol3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_pol.js"(exports, module2) {
    "use strict";
    module2.exports = function buildPol(module3, prefix, prefixField) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      function buildZero() {
        const f = module3.addFunction(prefix + "_zero");
        f.addParam("px", "i32");
        f.addParam("n", "i32");
        f.addLocal("lastp", "i32");
        f.addLocal("p", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal("p", c.getLocal("px")),
          c.setLocal(
            "lastp",
            c.i32_add(
              c.getLocal("px"),
              c.i32_mul(
                c.getLocal("n"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("p"),
                c.getLocal("lastp")
              )
            ),
            c.call(prefixField + "_zero", c.getLocal("p")),
            c.setLocal("p", c.i32_add(c.getLocal("p"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      function buildConstructLC() {
        const f = module3.addFunction(prefix + "_constructLC");
        f.addParam("ppolynomials", "i32");
        f.addParam("psignals", "i32");
        f.addParam("nSignals", "i32");
        f.addParam("pres", "i32");
        f.addLocal("i", "i32");
        f.addLocal("j", "i32");
        f.addLocal("pp", "i32");
        f.addLocal("ps", "i32");
        f.addLocal("pd", "i32");
        f.addLocal("ncoefs", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("i", c.i32_const(0)),
          c.setLocal("pp", c.getLocal("ppolynomials")),
          c.setLocal("ps", c.getLocal("psignals")),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("i"),
                c.getLocal("nSignals")
              )
            ),
            c.setLocal("ncoefs", c.i32_load(c.getLocal("pp"))),
            c.setLocal("pp", c.i32_add(c.getLocal("pp"), c.i32_const(4))),
            c.setLocal("j", c.i32_const(0)),
            c.block(c.loop(
              c.br_if(
                1,
                c.i32_eq(
                  c.getLocal("j"),
                  c.getLocal("ncoefs")
                )
              ),
              c.setLocal(
                "pd",
                c.i32_add(
                  c.getLocal("pres"),
                  c.i32_mul(
                    c.i32_load(c.getLocal("pp")),
                    c.i32_const(n8)
                  )
                )
              ),
              c.setLocal("pp", c.i32_add(c.getLocal("pp"), c.i32_const(4))),
              c.call(
                prefixField + "_mul",
                c.getLocal("ps"),
                c.getLocal("pp"),
                aux
              ),
              c.call(
                prefixField + "_add",
                aux,
                c.getLocal("pd"),
                c.getLocal("pd")
              ),
              c.setLocal("pp", c.i32_add(c.getLocal("pp"), c.i32_const(n8))),
              c.setLocal("j", c.i32_add(c.getLocal("j"), c.i32_const(1))),
              c.br(0)
            )),
            c.setLocal("ps", c.i32_add(c.getLocal("ps"), c.i32_const(n8))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      buildZero();
      buildConstructLC();
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_constructLC");
      return prefix;
    };
  }
});

// ../../node_modules/wasmcurves/src/build_qap.js
var require_build_qap3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_qap.js"(exports, module2) {
    "use strict";
    module2.exports = function buildQAP(module3, prefix, prefixField) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      function buildBuildABC() {
        const f = module3.addFunction(prefix + "_buildABC");
        f.addParam("pCoefs", "i32");
        f.addParam("nCoefs", "i32");
        f.addParam("pWitness", "i32");
        f.addParam("pA", "i32");
        f.addParam("pB", "i32");
        f.addParam("pC", "i32");
        f.addParam("offsetOut", "i32");
        f.addParam("nOut", "i32");
        f.addParam("offsetWitness", "i32");
        f.addParam("nWitness", "i32");
        f.addLocal("it", "i32");
        f.addLocal("ita", "i32");
        f.addLocal("itb", "i32");
        f.addLocal("last", "i32");
        f.addLocal("m", "i32");
        f.addLocal("c", "i32");
        f.addLocal("s", "i32");
        f.addLocal("pOut", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8));
        f.addCode(
          // Set output a and b to 0
          c.setLocal("ita", c.getLocal("pA")),
          c.setLocal("itb", c.getLocal("pB")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pA"),
              c.i32_mul(
                c.getLocal("nOut"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(prefixField + "_zero", c.getLocal("ita")),
            c.call(prefixField + "_zero", c.getLocal("itb")),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.br(0)
          )),
          c.setLocal("it", c.getLocal("pCoefs")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pCoefs"),
              c.i32_mul(
                c.getLocal("nCoefs"),
                c.i32_const(n8 + 12)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("it"),
                c.getLocal("last")
              )
            ),
            c.setLocal(
              "s",
              c.i32_load(c.getLocal("it"), 8)
            ),
            c.if(
              c.i32_or(
                c.i32_lt_u(
                  c.getLocal("s"),
                  c.getLocal("offsetWitness")
                ),
                c.i32_ge_u(
                  c.getLocal("s"),
                  c.i32_add(
                    c.getLocal("offsetWitness"),
                    c.getLocal("nWitness")
                  )
                )
              ),
              [
                ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
                ...c.br(1)
              ]
            ),
            c.setLocal(
              "m",
              c.i32_load(c.getLocal("it"))
            ),
            c.if(
              c.i32_eq(c.getLocal("m"), c.i32_const(0)),
              c.setLocal("pOut", c.getLocal("pA")),
              c.if(
                c.i32_eq(c.getLocal("m"), c.i32_const(1)),
                c.setLocal("pOut", c.getLocal("pB")),
                [
                  ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
                  ...c.br(1)
                ]
              )
            ),
            c.setLocal(
              "c",
              c.i32_load(c.getLocal("it"), 4)
            ),
            c.if(
              c.i32_or(
                c.i32_lt_u(
                  c.getLocal("c"),
                  c.getLocal("offsetOut")
                ),
                c.i32_ge_u(
                  c.getLocal("c"),
                  c.i32_add(
                    c.getLocal("offsetOut"),
                    c.getLocal("nOut")
                  )
                )
              ),
              [
                ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
                ...c.br(1)
              ]
            ),
            c.setLocal(
              "pOut",
              c.i32_add(
                c.getLocal("pOut"),
                c.i32_mul(
                  c.i32_sub(
                    c.getLocal("c"),
                    c.getLocal("offsetOut")
                  ),
                  c.i32_const(n8)
                )
              )
            ),
            c.call(
              prefixField + "_mul",
              c.i32_add(
                c.getLocal("pWitness"),
                c.i32_mul(
                  c.i32_sub(c.getLocal("s"), c.getLocal("offsetWitness")),
                  c.i32_const(n8)
                )
              ),
              c.i32_add(c.getLocal("it"), c.i32_const(12)),
              aux
            ),
            c.call(
              prefixField + "_add",
              c.getLocal("pOut"),
              aux,
              c.getLocal("pOut")
            ),
            c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8 + 12))),
            c.br(0)
          )),
          c.setLocal("ita", c.getLocal("pA")),
          c.setLocal("itb", c.getLocal("pB")),
          c.setLocal("it", c.getLocal("pC")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pA"),
              c.i32_mul(
                c.getLocal("nOut"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(
              prefixField + "_mul",
              c.getLocal("ita"),
              c.getLocal("itb"),
              c.getLocal("it")
            ),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      function buildJoinABC() {
        const f = module3.addFunction(prefix + "_joinABC");
        f.addParam("pA", "i32");
        f.addParam("pB", "i32");
        f.addParam("pC", "i32");
        f.addParam("n", "i32");
        f.addParam("pP", "i32");
        f.addLocal("ita", "i32");
        f.addLocal("itb", "i32");
        f.addLocal("itc", "i32");
        f.addLocal("itp", "i32");
        f.addLocal("last", "i32");
        const c = f.getCodeBuilder();
        const aux = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.setLocal("ita", c.getLocal("pA")),
          c.setLocal("itb", c.getLocal("pB")),
          c.setLocal("itc", c.getLocal("pC")),
          c.setLocal("itp", c.getLocal("pP")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pA"),
              c.i32_mul(
                c.getLocal("n"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(
              prefixField + "_mul",
              c.getLocal("ita"),
              c.getLocal("itb"),
              aux
            ),
            c.call(
              prefixField + "_sub",
              aux,
              c.getLocal("itc"),
              c.getLocal("itp")
            ),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.setLocal("itc", c.i32_add(c.getLocal("itc"), c.i32_const(n8))),
            c.setLocal("itp", c.i32_add(c.getLocal("itp"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      function buildBatchAdd() {
        const f = module3.addFunction(prefix + "_batchAdd");
        f.addParam("pa", "i32");
        f.addParam("pb", "i32");
        f.addParam("n", "i32");
        f.addParam("pr", "i32");
        f.addLocal("ita", "i32");
        f.addLocal("itb", "i32");
        f.addLocal("itr", "i32");
        f.addLocal("last", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.setLocal("ita", c.getLocal("pa")),
          c.setLocal("itb", c.getLocal("pb")),
          c.setLocal("itr", c.getLocal("pr")),
          c.setLocal(
            "last",
            c.i32_add(
              c.getLocal("pa"),
              c.i32_mul(
                c.getLocal("n"),
                c.i32_const(n8)
              )
            )
          ),
          c.block(c.loop(
            c.br_if(
              1,
              c.i32_eq(
                c.getLocal("ita"),
                c.getLocal("last")
              )
            ),
            c.call(
              prefixField + "_add",
              c.getLocal("ita"),
              c.getLocal("itb"),
              c.getLocal("itr")
            ),
            c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
            c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
            c.setLocal("itr", c.i32_add(c.getLocal("itr"), c.i32_const(n8))),
            c.br(0)
          ))
        );
      }
      buildBuildABC();
      buildJoinABC();
      buildBatchAdd();
      module3.exportFunction(prefix + "_buildABC");
      module3.exportFunction(prefix + "_joinABC");
      module3.exportFunction(prefix + "_batchAdd");
      return prefix;
    };
  }
});

// ../../node_modules/wasmcurves/src/build_applykey.js
var require_build_applykey3 = __commonJS({
  "../../node_modules/wasmcurves/src/build_applykey.js"(exports, module2) {
    "use strict";
    module2.exports = function buildApplyKey(module3, fnName, gPrefix, frPrefix, sizeGIn, sizeGOut, sizeF, opGtimesF) {
      const f = module3.addFunction(fnName);
      f.addParam("pIn", "i32");
      f.addParam("n", "i32");
      f.addParam("pFirst", "i32");
      f.addParam("pInc", "i32");
      f.addParam("pOut", "i32");
      f.addLocal("pOldFree", "i32");
      f.addLocal("i", "i32");
      f.addLocal("pFrom", "i32");
      f.addLocal("pTo", "i32");
      const c = f.getCodeBuilder();
      const t = c.i32_const(module3.alloc(sizeF));
      f.addCode(
        c.setLocal("pFrom", c.getLocal("pIn")),
        c.setLocal("pTo", c.getLocal("pOut"))
      );
      f.addCode(
        c.call(
          frPrefix + "_copy",
          c.getLocal("pFirst"),
          t
        )
      );
      f.addCode(
        c.setLocal("i", c.i32_const(0)),
        c.block(c.loop(
          c.br_if(1, c.i32_eq(c.getLocal("i"), c.getLocal("n"))),
          c.call(
            opGtimesF,
            c.getLocal("pFrom"),
            t,
            c.getLocal("pTo")
          ),
          c.setLocal("pFrom", c.i32_add(c.getLocal("pFrom"), c.i32_const(sizeGIn))),
          c.setLocal("pTo", c.i32_add(c.getLocal("pTo"), c.i32_const(sizeGOut))),
          // t = t* inc
          c.call(
            frPrefix + "_mul",
            t,
            c.getLocal("pInc"),
            t
          ),
          c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
          c.br(0)
        ))
      );
      module3.exportFunction(fnName);
    };
  }
});

// ../../node_modules/wasmcurves/src/bn128/build_bn128.js
var require_build_bn1283 = __commonJS({
  "../../node_modules/wasmcurves/src/bn128/build_bn128.js"(exports, module2) {
    "use strict";
    var utils2 = require_utils3();
    var buildF1m = require_build_f1m3();
    var buildF1 = require_build_f13();
    var buildF2m = require_build_f2m3();
    var buildF3m = require_build_f3m3();
    var buildCurve = require_build_curve_jacobian_a03();
    var buildFFT4 = require_build_fft3();
    var buildPol = require_build_pol3();
    var buildQAP = require_build_qap3();
    var buildApplyKey = require_build_applykey3();
    var { bitLength: bitLength5, modInv, isOdd: isOdd4, isNegative: isNegative5 } = require_bigint3();
    module2.exports = function buildBN128(module3, _prefix) {
      const prefix = _prefix || "bn128";
      if (module3.modules[prefix])
        return prefix;
      const q = 21888242871839275222246405745257275088696311157297823662689037894645226208583n;
      const r = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;
      const n64 = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n8 = n64 * 8;
      const frsize = n8;
      const f1size = n8;
      const f2size = f1size * 2;
      const ftsize = f1size * 12;
      const pr = module3.alloc(utils2.bigInt2BytesLE(r, frsize));
      const f1mPrefix = buildF1m(module3, q, "f1m");
      buildF1(module3, r, "fr", "frm");
      const pG1b = module3.alloc(utils2.bigInt2BytesLE(toMontgomery(3n), f1size));
      const g1mPrefix = buildCurve(module3, "g1m", "f1m", pG1b);
      buildFFT4(module3, "frm", "frm", "frm", "frm_mul");
      buildPol(module3, "pol", "frm");
      buildQAP(module3, "qap", "frm");
      const f2mPrefix = buildF2m(module3, "f1m_neg", "f2m", "f1m");
      const pG2b = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
      ]);
      const g2mPrefix = buildCurve(module3, "g2m", "f2m", pG2b);
      function buildGTimesFr(fnName, opMul) {
        const f = module3.addFunction(fnName);
        f.addParam("pG", "i32");
        f.addParam("pFr", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8));
        f.addCode(
          c.call("frm_fromMontgomery", c.getLocal("pFr"), AUX),
          c.call(
            opMul,
            c.getLocal("pG"),
            AUX,
            c.i32_const(n8),
            c.getLocal("pr")
          )
        );
        module3.exportFunction(fnName);
      }
      buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
      buildFFT4(module3, "g1m", "g1m", "frm", "g1m_timesFr");
      buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
      buildFFT4(module3, "g2m", "g2m", "frm", "g2m_timesFr");
      buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
      buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
      buildApplyKey(module3, "frm_batchApplyKey", "fmr", "frm", n8, n8, n8, "frm_mul");
      buildApplyKey(module3, "g1m_batchApplyKey", "g1m", "frm", n8 * 3, n8 * 3, n8, "g1m_timesFr");
      buildApplyKey(module3, "g1m_batchApplyKeyMixed", "g1m", "frm", n8 * 2, n8 * 3, n8, "g1m_timesFrAffine");
      buildApplyKey(module3, "g2m_batchApplyKey", "g2m", "frm", n8 * 2 * 3, n8 * 3 * 2, n8, "g2m_timesFr");
      buildApplyKey(module3, "g2m_batchApplyKeyMixed", "g2m", "frm", n8 * 2 * 2, n8 * 3 * 2, n8, "g2m_timesFrAffine");
      function toMontgomery(a) {
        return BigInt(a) * (1n << BigInt(f1size * 8)) % q;
      }
      const G1gen = [
        1n,
        2n,
        1n
      ];
      const pG1gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
        ]
      );
      const G1zero = [
        0n,
        1n,
        0n
      ];
      const pG1zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
        ]
      );
      const G2gen = [
        [
          10857046999023057135944570762232829481370756359578518086990519993285655852781n,
          11559732032986387107991004021392285783925812861821192530917403151452391805634n
        ],
        [
          8495653923123431417604973247489272438418190587263600148770280649306958101930n,
          4082367875863433681332203403145435568316851327593401208105741076214120093531n
        ],
        [
          1n,
          0n
        ]
      ];
      const pG2gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
        ]
      );
      const G2zero = [
        [
          0n,
          0n
        ],
        [
          1n,
          0n
        ],
        [
          0n,
          0n
        ]
      ];
      const pG2zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
        ]
      );
      const pOneT = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size)
      ]);
      const pNonResidueF6 = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(9), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(1), f1size)
      ]);
      const pTwoInv = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(modInv(2n, q)), f1size),
        ...utils2.bigInt2BytesLE(0n, f1size)
      ]);
      const pAltBn128Twist = pNonResidueF6;
      const pTwistCoefB = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
      ]);
      function build_mulNR6() {
        const f = module3.addFunction(prefix + "_mulNR6");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(
            f2mPrefix + "_mul",
            c.i32_const(pNonResidueF6),
            c.getLocal("x"),
            c.getLocal("pr")
          )
        );
      }
      build_mulNR6();
      const f6mPrefix = buildF3m(module3, prefix + "_mulNR6", "f6m", "f2m");
      function build_mulNR12() {
        const f = module3.addFunction(prefix + "_mulNR12");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(
            f2mPrefix + "_mul",
            c.i32_const(pNonResidueF6),
            c.i32_add(c.getLocal("x"), c.i32_const(n8 * 4)),
            c.getLocal("pr")
          ),
          c.call(
            f2mPrefix + "_copy",
            c.getLocal("x"),
            c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 2))
          ),
          c.call(
            f2mPrefix + "_copy",
            c.i32_add(c.getLocal("x"), c.i32_const(n8 * 2)),
            c.i32_add(c.getLocal("pr"), c.i32_const(n8 * 4))
          )
        );
      }
      build_mulNR12();
      const ftmPrefix = buildF2m(module3, prefix + "_mulNR12", "ftm", f6mPrefix);
      const ateLoopCount = 29793968203157093288n;
      const ateLoopBitBytes = bits4(ateLoopCount);
      const pAteLoopBitBytes = module3.alloc(ateLoopBitBytes);
      const isLoopNegative = false;
      const ateCoefSize = 3 * f2size;
      const ateNDblCoefs = ateLoopBitBytes.length - 1;
      const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) => acc + (b != 0 ? 1 : 0), 0);
      const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
      const prePSize = 3 * 2 * n8;
      const preQSize = 3 * n8 * 2 + ateNCoefs * ateCoefSize;
      const finalExpIsNegative = false;
      module3.modules[prefix] = {
        n64,
        pG1gen,
        pG1zero,
        pG1b,
        pG2gen,
        pG2zero,
        pG2b,
        pq: module3.modules["f1m"].pq,
        pr,
        pOneT,
        prePSize,
        preQSize,
        r: r.toString(),
        q: q.toString()
      };
      const finalExpZ = 4965661367192848881n;
      function naf4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            const z = 2 - Number(E % 4n);
            res.push(z);
            E = E - BigInt(z);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function bits4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            res.push(1);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function buildPrepareG1() {
        const f = module3.addFunction(prefix + "_prepareG1");
        f.addParam("pP", "i32");
        f.addParam("ppreP", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(g1mPrefix + "_normalize", c.getLocal("pP"), c.getLocal("ppreP"))
          // TODO Remove if already in affine
        );
      }
      function buildPrepAddStep() {
        const f = module3.addFunction(prefix + "_prepAddStep");
        f.addParam("pQ", "i32");
        f.addParam("pR", "i32");
        f.addParam("pCoef", "i32");
        const c = f.getCodeBuilder();
        const X2 = c.getLocal("pQ");
        const Y2 = c.i32_add(c.getLocal("pQ"), c.i32_const(f2size));
        const X1 = c.getLocal("pR");
        const Y1 = c.i32_add(c.getLocal("pR"), c.i32_const(f2size));
        const Z1 = c.i32_add(c.getLocal("pR"), c.i32_const(2 * f2size));
        const ELL_0 = c.getLocal("pCoef");
        const ELL_VW = c.i32_add(c.getLocal("pCoef"), c.i32_const(f2size));
        const ELL_VV = c.i32_add(c.getLocal("pCoef"), c.i32_const(2 * f2size));
        const D = ELL_VW;
        const E = c.i32_const(module3.alloc(f2size));
        const F = c.i32_const(module3.alloc(f2size));
        const G = c.i32_const(module3.alloc(f2size));
        const H = c.i32_const(module3.alloc(f2size));
        const I = c.i32_const(module3.alloc(f2size));
        const J = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // D = X1 - X2*Z1
          c.call(f2mPrefix + "_mul", X2, Z1, D),
          c.call(f2mPrefix + "_sub", X1, D, D),
          // E = Y1 - Y2*Z1
          c.call(f2mPrefix + "_mul", Y2, Z1, E),
          c.call(f2mPrefix + "_sub", Y1, E, E),
          // F = D^2
          c.call(f2mPrefix + "_square", D, F),
          // G = E^2
          c.call(f2mPrefix + "_square", E, G),
          // H = D*F
          c.call(f2mPrefix + "_mul", D, F, H),
          // I = X1 * F
          c.call(f2mPrefix + "_mul", X1, F, I),
          // J = H + Z1*G - (I+I)
          c.call(f2mPrefix + "_add", I, I, AUX),
          c.call(f2mPrefix + "_mul", Z1, G, J),
          c.call(f2mPrefix + "_add", H, J, J),
          c.call(f2mPrefix + "_sub", J, AUX, J),
          // X3 (X1) = D*J
          c.call(f2mPrefix + "_mul", D, J, X1),
          // Y3 (Y1) = E*(I-J)-(H*Y1)
          c.call(f2mPrefix + "_mul", H, Y1, Y1),
          c.call(f2mPrefix + "_sub", I, J, AUX),
          c.call(f2mPrefix + "_mul", E, AUX, AUX),
          c.call(f2mPrefix + "_sub", AUX, Y1, Y1),
          // Z3 (Z1) = Z1*H
          c.call(f2mPrefix + "_mul", Z1, H, Z1),
          // ell_0 = xi * (E * X2 - D * Y2)
          c.call(f2mPrefix + "_mul", D, Y2, AUX),
          c.call(f2mPrefix + "_mul", E, X2, ELL_0),
          c.call(f2mPrefix + "_sub", ELL_0, AUX, ELL_0),
          c.call(f2mPrefix + "_mul", ELL_0, c.i32_const(pAltBn128Twist), ELL_0),
          // ell_VV = - E (later: * xP)
          c.call(f2mPrefix + "_neg", E, ELL_VV)
          // ell_VW = D (later: * yP    )
          // Already assigned
        );
      }
      function buildPrepDoubleStep() {
        const f = module3.addFunction(prefix + "_prepDblStep");
        f.addParam("pR", "i32");
        f.addParam("pCoef", "i32");
        const c = f.getCodeBuilder();
        const X1 = c.getLocal("pR");
        const Y1 = c.i32_add(c.getLocal("pR"), c.i32_const(f2size));
        const Z1 = c.i32_add(c.getLocal("pR"), c.i32_const(2 * f2size));
        const ELL_0 = c.getLocal("pCoef");
        const ELL_VW = c.i32_add(c.getLocal("pCoef"), c.i32_const(f2size));
        const ELL_VV = c.i32_add(c.getLocal("pCoef"), c.i32_const(2 * f2size));
        const A = c.i32_const(module3.alloc(f2size));
        const B = c.i32_const(module3.alloc(f2size));
        const C = c.i32_const(module3.alloc(f2size));
        const D = c.i32_const(module3.alloc(f2size));
        const E = c.i32_const(module3.alloc(f2size));
        const F = c.i32_const(module3.alloc(f2size));
        const G = c.i32_const(module3.alloc(f2size));
        const H = c.i32_const(module3.alloc(f2size));
        const I = c.i32_const(module3.alloc(f2size));
        const J = c.i32_const(module3.alloc(f2size));
        const E2 = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // A = X1 * Y1 / 2
          c.call(f2mPrefix + "_mul", Y1, c.i32_const(pTwoInv), A),
          c.call(f2mPrefix + "_mul", X1, A, A),
          // B = Y1^2
          c.call(f2mPrefix + "_square", Y1, B),
          // C = Z1^2
          c.call(f2mPrefix + "_square", Z1, C),
          // D = 3 * C
          c.call(f2mPrefix + "_add", C, C, D),
          c.call(f2mPrefix + "_add", D, C, D),
          // E = twist_b * D
          c.call(f2mPrefix + "_mul", c.i32_const(pTwistCoefB), D, E),
          // F = 3 * E
          c.call(f2mPrefix + "_add", E, E, F),
          c.call(f2mPrefix + "_add", E, F, F),
          // G = (B+F)/2
          c.call(f2mPrefix + "_add", B, F, G),
          c.call(f2mPrefix + "_mul", G, c.i32_const(pTwoInv), G),
          // H = (Y1+Z1)^2-(B+C)
          c.call(f2mPrefix + "_add", B, C, AUX),
          c.call(f2mPrefix + "_add", Y1, Z1, H),
          c.call(f2mPrefix + "_square", H, H),
          c.call(f2mPrefix + "_sub", H, AUX, H),
          // I = E-B
          c.call(f2mPrefix + "_sub", E, B, I),
          // J = X1^2
          c.call(f2mPrefix + "_square", X1, J),
          // E_squared = E^2
          c.call(f2mPrefix + "_square", E, E2),
          // X3 (X1) = A * (B-F)
          c.call(f2mPrefix + "_sub", B, F, AUX),
          c.call(f2mPrefix + "_mul", A, AUX, X1),
          // Y3 (Y1) = G^2 - 3*E^2
          c.call(f2mPrefix + "_add", E2, E2, AUX),
          c.call(f2mPrefix + "_add", E2, AUX, AUX),
          c.call(f2mPrefix + "_square", G, Y1),
          c.call(f2mPrefix + "_sub", Y1, AUX, Y1),
          // Z3 (Z1) = B * H
          c.call(f2mPrefix + "_mul", B, H, Z1),
          // ell_0 = xi * I
          c.call(f2mPrefix + "_mul", c.i32_const(pAltBn128Twist), I, ELL_0),
          // ell_VW = - H (later: * yP)
          c.call(f2mPrefix + "_neg", H, ELL_VW),
          // ell_VV = 3*J (later: * xP)
          c.call(f2mPrefix + "_add", J, J, ELL_VV),
          c.call(f2mPrefix + "_add", J, ELL_VV, ELL_VV)
        );
      }
      function buildMulByQ() {
        const f = module3.addFunction(prefix + "_mulByQ");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(f2size));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(f2size * 2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(f2size));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(f2size * 2));
        const MulByQX = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery("21575463638280843010398324269430826099269044274347216827212613867836435027261"), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery("10307601595873709700152284273816112264069230130616436755625194854815875713954"), f1size)
        ]));
        const MulByQY = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery("2821565182194536844548159561693502659359617185244120367078079554186484126554"), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery("3505843767911556378687030309984248845540243509899259641013678093033130930403"), f1size)
        ]));
        f.addCode(
          // The frobeniusMap(1) in this field, is the conjugate
          c.call(f2mPrefix + "_conjugate", x, x3),
          c.call(f2mPrefix + "_mul", MulByQX, x3, x3),
          c.call(f2mPrefix + "_conjugate", y, y3),
          c.call(f2mPrefix + "_mul", MulByQY, y3, y3),
          c.call(f2mPrefix + "_conjugate", z, z3)
        );
      }
      function buildPrepareG2() {
        buildMulByQ();
        const f = module3.addFunction(prefix + "_prepareG2");
        f.addParam("pQ", "i32");
        f.addParam("ppreQ", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const QX = c.getLocal("pQ");
        const pR = module3.alloc(f2size * 3);
        const R = c.i32_const(pR);
        const RX = c.i32_const(pR);
        const RY = c.i32_const(pR + f2size);
        const RZ = c.i32_const(pR + 2 * f2size);
        const cQX = c.i32_add(c.getLocal("ppreQ"), c.i32_const(0));
        const cQY = c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size));
        const pQ1 = module3.alloc(f2size * 3);
        const Q1 = c.i32_const(pQ1);
        const pQ2 = module3.alloc(f2size * 3);
        const Q2 = c.i32_const(pQ2);
        const Q2Y = c.i32_const(pQ2 + f2size);
        f.addCode(
          c.call(g2mPrefix + "_normalize", QX, cQX),
          // TODO Remove if already in affine
          c.call(f2mPrefix + "_copy", cQX, RX),
          c.call(f2mPrefix + "_copy", cQY, RY),
          c.call(f2mPrefix + "_one", RZ)
        );
        f.addCode(
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3))),
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "_prepDblStep", R, c.getLocal("pCoef")),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(prefix + "_prepAddStep", cQX, R, c.getLocal("pCoef")),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
        f.addCode(
          c.call(prefix + "_mulByQ", cQX, Q1),
          c.call(prefix + "_mulByQ", Q1, Q2)
        );
        if (isLoopNegative) {
          f.addCode(
            c.call(f2mPrefix + "_neg", RY, RY)
          );
        }
        f.addCode(
          c.call(f2mPrefix + "_neg", Q2Y, Q2Y),
          c.call(prefix + "_prepAddStep", Q1, R, c.getLocal("pCoef")),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
          c.call(prefix + "_prepAddStep", Q2, R, c.getLocal("pCoef")),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
        );
      }
      function buildMulBy024Old() {
        const f = module3.addFunction(prefix + "__mulBy024Old");
        f.addParam("pEll0", "i32");
        f.addParam("pEllVW", "i32");
        f.addParam("pEllVV", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("pEll0");
        const x2 = c.getLocal("pEllVV");
        const x4 = c.getLocal("pEllVW");
        const z0 = c.getLocal("pR");
        const pAUX12 = module3.alloc(ftsize);
        const AUX12 = c.i32_const(pAUX12);
        const AUX12_0 = c.i32_const(pAUX12);
        const AUX12_2 = c.i32_const(pAUX12 + f2size);
        const AUX12_4 = c.i32_const(pAUX12 + f2size * 2);
        const AUX12_6 = c.i32_const(pAUX12 + f2size * 3);
        const AUX12_8 = c.i32_const(pAUX12 + f2size * 4);
        const AUX12_10 = c.i32_const(pAUX12 + f2size * 5);
        f.addCode(
          c.call(f2mPrefix + "_copy", x0, AUX12_0),
          c.call(f2mPrefix + "_zero", AUX12_2),
          c.call(f2mPrefix + "_copy", x2, AUX12_4),
          c.call(f2mPrefix + "_zero", AUX12_6),
          c.call(f2mPrefix + "_copy", x4, AUX12_8),
          c.call(f2mPrefix + "_zero", AUX12_10),
          c.call(ftmPrefix + "_mul", AUX12, z0, z0)
        );
      }
      function buildMulBy024() {
        const f = module3.addFunction(prefix + "__mulBy024");
        f.addParam("pEll0", "i32");
        f.addParam("pEllVW", "i32");
        f.addParam("pEllVV", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("pEll0");
        const x2 = c.getLocal("pEllVV");
        const x4 = c.getLocal("pEllVW");
        const z0 = c.getLocal("pR");
        const z1 = c.i32_add(c.getLocal("pR"), c.i32_const(2 * n8));
        const z2 = c.i32_add(c.getLocal("pR"), c.i32_const(4 * n8));
        const z3 = c.i32_add(c.getLocal("pR"), c.i32_const(6 * n8));
        const z4 = c.i32_add(c.getLocal("pR"), c.i32_const(8 * n8));
        const z5 = c.i32_add(c.getLocal("pR"), c.i32_const(10 * n8));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const s0 = c.i32_const(module3.alloc(f2size));
        const T3 = c.i32_const(module3.alloc(f2size));
        const T4 = c.i32_const(module3.alloc(f2size));
        const D0 = c.i32_const(module3.alloc(f2size));
        const D2 = c.i32_const(module3.alloc(f2size));
        const D4 = c.i32_const(module3.alloc(f2size));
        const S1 = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // D0 = z0 * x0;
          c.call(f2mPrefix + "_mul", z0, x0, D0),
          // D2 = z2 * x2;
          c.call(f2mPrefix + "_mul", z2, x2, D2),
          // D4 = z4 * x4;
          c.call(f2mPrefix + "_mul", z4, x4, D4),
          // t2 = z0 + z4;
          c.call(f2mPrefix + "_add", z0, z4, t2),
          // t1 = z0 + z2;
          c.call(f2mPrefix + "_add", z0, z2, t1),
          // s0 = z1 + z3 + z5;
          c.call(f2mPrefix + "_add", z1, z3, s0),
          c.call(f2mPrefix + "_add", s0, z5, s0),
          // For z.a_.a_ = z0.
          // S1 = z1 * x2;
          c.call(f2mPrefix + "_mul", z1, x2, S1),
          // T3 = S1 + D4;
          c.call(f2mPrefix + "_add", S1, D4, T3),
          // T4 = my_Fp6::non_residue * T3 + D0;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          c.call(f2mPrefix + "_add", T4, D0, z0),
          // z0 = T4;
          // For z.a_.b_ = z1
          // T3 = z5 * x4;
          c.call(f2mPrefix + "_mul", z5, x4, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T3 = T3 + D2;
          c.call(f2mPrefix + "_add", T3, D2, T3),
          // T4 = my_Fp6::non_residue * T3;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          // T3 = z1 * x0;
          c.call(f2mPrefix + "_mul", z1, x0, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = T4 + T3;
          c.call(f2mPrefix + "_add", T4, T3, z1),
          // z1 = T4;
          // For z.a_.c_ = z2
          // t0 = x0 + x2;
          c.call(f2mPrefix + "_add", x0, x2, t0),
          // T3 = t1 * t0 - D0 - D2;
          c.call(f2mPrefix + "_mul", t1, t0, T3),
          c.call(f2mPrefix + "_add", D0, D2, AUX),
          c.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = z3 * x4;
          c.call(f2mPrefix + "_mul", z3, x4, T4),
          // S1 = S1 + T4;
          c.call(f2mPrefix + "_add", S1, T4, S1),
          // For z.b_.a_ = z3 (z3 needs z2)
          // t0 = z2 + z4;
          c.call(f2mPrefix + "_add", z2, z4, t0),
          // T3 = T3 + T4;
          // z2 = T3;
          c.call(f2mPrefix + "_add", T3, T4, z2),
          // t1 = x2 + x4;
          c.call(f2mPrefix + "_add", x2, x4, t1),
          // T3 = t0 * t1 - D2 - D4;
          c.call(f2mPrefix + "_mul", t1, t0, T3),
          c.call(f2mPrefix + "_add", D2, D4, AUX),
          c.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = my_Fp6::non_residue * T3;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          // T3 = z3 * x0;
          c.call(f2mPrefix + "_mul", z3, x0, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = T4 + T3;
          c.call(f2mPrefix + "_add", T4, T3, z3),
          // z3 = T4;
          // For z.b_.b_ = z4
          // T3 = z5 * x2;
          c.call(f2mPrefix + "_mul", z5, x2, T3),
          // S1 = S1 + T3;
          c.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = my_Fp6::non_residue * T3;
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), T3, T4),
          // t0 = x0 + x4;
          c.call(f2mPrefix + "_add", x0, x4, t0),
          // T3 = t2 * t0 - D0 - D4;
          c.call(f2mPrefix + "_mul", t2, t0, T3),
          c.call(f2mPrefix + "_add", D0, D4, AUX),
          c.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = T4 + T3;
          c.call(f2mPrefix + "_add", T4, T3, z4),
          // z4 = T4;
          // For z.b_.c_ = z5.
          // t0 = x0 + x2 + x4;
          c.call(f2mPrefix + "_add", x0, x2, t0),
          c.call(f2mPrefix + "_add", t0, x4, t0),
          // T3 = s0 * t0 - S1;
          c.call(f2mPrefix + "_mul", s0, t0, T3),
          c.call(f2mPrefix + "_sub", T3, S1, z5)
          // z5 = T3;
        );
      }
      function buildMillerLoop() {
        const f = module3.addFunction(prefix + "_millerLoop");
        f.addParam("ppreP", "i32");
        f.addParam("ppreQ", "i32");
        f.addParam("r", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const preP_PX = c.getLocal("ppreP");
        const preP_PY = c.i32_add(c.getLocal("ppreP"), c.i32_const(f1size));
        const ELL_0 = c.getLocal("pCoef");
        const ELL_VW = c.i32_add(c.getLocal("pCoef"), c.i32_const(f2size));
        const ELL_VV = c.i32_add(c.getLocal("pCoef"), c.i32_const(2 * f2size));
        const pVW = module3.alloc(f2size);
        const VW = c.i32_const(pVW);
        const pVV = module3.alloc(f2size);
        const VV = c.i32_const(pVV);
        const F = c.getLocal("r");
        f.addCode(
          c.call(ftmPrefix + "_one", F),
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3))),
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(ftmPrefix + "_square", F, F),
            c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
            c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
            c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
                ...c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
                ...c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
        if (isLoopNegative) {
          f.addCode(
            c.call(ftmPrefix + "_inverse", F, F)
          );
        }
        f.addCode(
          c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
          c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
          c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
          c.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
          c.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
          c.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
          c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
        );
      }
      function buildFrobeniusMap(n) {
        const F12 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [8376118865763821496583973867626364092589906065868298776909617916018768340080n, 16469823323077808223889137241176536799009286646108169935659301613961712198316n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556617n, 0n],
            [11697423496358154304825782922584725312912383441159505038794027105778954184319n, 303847389135065887422783454877609941456349188919719272345083954437860409601n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [3321304630594332808241809054958361220322477375291206261884409189760185844239n, 5722266937896532885780051958958348231143373700109372999374820235121374419868n],
            [21888242871839275222246405745257275088696311157297823662689037894645226208582n, 0n],
            [13512124006075453725662431877630910996106405091429524885779419978626457868503n, 5418419548761466998357268504080738289687024511189653727029736280683514010267n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [10190819375481120917420622822672549775783927716138318623895010788866272024264n, 21584395482704209334823622290379665147239961968378104390343953940207365798982n],
            [2203960485148121921418603742825762020974279258880205651967n, 0n],
            [18566938241244942414004596690298913868373833782006617400804628704885040364344n, 16165975933942742336466353786298926857552937457188450663314217659523851788715n]
          ]
        ];
        const F6 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [21575463638280843010398324269430826099269044274347216827212613867836435027261n, 10307601595873709700152284273816112264069230130616436755625194854815875713954n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [3772000881919853776433695186713858239009073593817195771773381919316419345261n, 2236595495967245188281701248203181795121068902605861227855261137820944008926n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [18429021223477853657660792034369865839114504446431234726392080002137598044644n, 9344045779998320333812420223237981029506012124075525679208581902008406485703n]
          ],
          [
            [1n, 0n],
            [2581911344467009335267311115468803099551665605076196740867805258568234346338n, 19937756971775647987995932169929341994314640652964949448313374472400716661030n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [5324479202449903542726783395506214481928257762400643279780343368557297135718n, 16208900380737693084919495127334387981393726419856888799917914180988844123039n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [13981852324922362344252311234282257507216387789820983642040889267519694726527n, 7629828391165209371577384193250820201684255241773809077146787135900891633097n]
          ]
        ];
        const f = module3.addFunction(prefix + "__frobeniusMap" + n);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < 6; i++) {
          const X = i == 0 ? c.getLocal("x") : c.i32_add(c.getLocal("x"), c.i32_const(i * f2size));
          const Xc0 = X;
          const Xc1 = c.i32_add(c.getLocal("x"), c.i32_const(i * f2size + f1size));
          const R = i == 0 ? c.getLocal("r") : c.i32_add(c.getLocal("r"), c.i32_const(i * f2size));
          const Rc0 = R;
          const Rc1 = c.i32_add(c.getLocal("r"), c.i32_const(i * f2size + f1size));
          const coef = mul22(F12[Math.floor(i / 3)][n % 12], F6[i % 3][n % 6]);
          const pCoef = module3.alloc([
            ...utils2.bigInt2BytesLE(toMontgomery(coef[0]), 32),
            ...utils2.bigInt2BytesLE(toMontgomery(coef[1]), 32)
          ]);
          if (n % 2 == 1) {
            f.addCode(
              c.call(f1mPrefix + "_copy", Xc0, Rc0),
              c.call(f1mPrefix + "_neg", Xc1, Rc1),
              c.call(f2mPrefix + "_mul", R, c.i32_const(pCoef), R)
            );
          } else {
            f.addCode(c.call(f2mPrefix + "_mul", X, c.i32_const(pCoef), R));
          }
        }
        function mul22(a, b) {
          const ac0 = BigInt(a[0]);
          const ac1 = BigInt(a[1]);
          const bc0 = BigInt(b[0]);
          const bc1 = BigInt(b[1]);
          const res = [
            (ac0 * bc0 - ac1 * bc1) % q,
            (ac0 * bc1 + ac1 * bc0) % q
          ];
          if (isNegative5(res[0]))
            res[0] = res[0] + q;
          return res;
        }
      }
      function buildFinalExponentiationFirstChunk() {
        const f = module3.addFunction(prefix + "__finalExponentiationFirstChunk");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const eltC0 = elt;
        const eltC1 = c.i32_add(elt, c.i32_const(n8 * 6));
        const r2 = c.getLocal("r");
        const pA = module3.alloc(ftsize);
        const A = c.i32_const(pA);
        const Ac0 = A;
        const Ac1 = c.i32_const(pA + n8 * 6);
        const B = c.i32_const(module3.alloc(ftsize));
        const C = c.i32_const(module3.alloc(ftsize));
        const D = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          // const alt_bn128_Fq12 A = alt_bn128_Fq12(elt.c0,-elt.c1);
          c.call(f6mPrefix + "_copy", eltC0, Ac0),
          c.call(f6mPrefix + "_neg", eltC1, Ac1),
          // const alt_bn128_Fq12 B = elt.inverse();
          c.call(ftmPrefix + "_inverse", elt, B),
          // const alt_bn128_Fq12 C = A * B;
          c.call(ftmPrefix + "_mul", A, B, C),
          // const alt_bn128_Fq12 D = C.Frobenius_map(2);
          c.call(prefix + "__frobeniusMap2", C, D),
          // const alt_bn128_Fq12 result = D * C;
          c.call(ftmPrefix + "_mul", C, D, r2)
        );
      }
      function buildCyclotomicSquare() {
        const f = module3.addFunction(prefix + "__cyclotomicSquare");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x4 = c.i32_add(c.getLocal("x"), c.i32_const(f2size));
        const x3 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f2size));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(3 * f2size));
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(4 * f2size));
        const x5 = c.i32_add(c.getLocal("x"), c.i32_const(5 * f2size));
        const r0 = c.getLocal("r");
        const r4 = c.i32_add(c.getLocal("r"), c.i32_const(f2size));
        const r3 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f2size));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(3 * f2size));
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(4 * f2size));
        const r5 = c.i32_add(c.getLocal("r"), c.i32_const(5 * f2size));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t3 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        const tmp = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          //    // t0 + t1*y = (z0 + z1*y)^2 = a^2
          //    tmp = z0 * z1;
          //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;
          //    t1 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x0, x1, tmp),
          c.call(f2mPrefix + "_mul", x1, c.i32_const(pNonResidueF6), t0),
          c.call(f2mPrefix + "_add", x0, t0, t0),
          c.call(f2mPrefix + "_add", x0, x1, AUX),
          c.call(f2mPrefix + "_mul", AUX, t0, t0),
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t0, AUX, t0),
          c.call(f2mPrefix + "_add", tmp, tmp, t1),
          //  // t2 + t3*y = (z2 + z3*y)^2 = b^2
          //  tmp = z2 * z3;
          //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;
          //  t3 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x2, x3, tmp),
          c.call(f2mPrefix + "_mul", x3, c.i32_const(pNonResidueF6), t2),
          c.call(f2mPrefix + "_add", x2, t2, t2),
          c.call(f2mPrefix + "_add", x2, x3, AUX),
          c.call(f2mPrefix + "_mul", AUX, t2, t2),
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t2, AUX, t2),
          c.call(f2mPrefix + "_add", tmp, tmp, t3),
          //  // t4 + t5*y = (z4 + z5*y)^2 = c^2
          //  tmp = z4 * z5;
          //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;
          //  t5 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x4, x5, tmp),
          c.call(f2mPrefix + "_mul", x5, c.i32_const(pNonResidueF6), t4),
          c.call(f2mPrefix + "_add", x4, t4, t4),
          c.call(f2mPrefix + "_add", x4, x5, AUX),
          c.call(f2mPrefix + "_mul", AUX, t4, t4),
          c.call(f2mPrefix + "_mul", c.i32_const(pNonResidueF6), tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t4, AUX, t4),
          c.call(f2mPrefix + "_add", tmp, tmp, t5),
          // For A
          // z0 = 3 * t0 - 2 * z0
          c.call(f2mPrefix + "_sub", t0, x0, r0),
          c.call(f2mPrefix + "_add", r0, r0, r0),
          c.call(f2mPrefix + "_add", t0, r0, r0),
          // z1 = 3 * t1 + 2 * z1
          c.call(f2mPrefix + "_add", t1, x1, r1),
          c.call(f2mPrefix + "_add", r1, r1, r1),
          c.call(f2mPrefix + "_add", t1, r1, r1),
          // For B
          // z2 = 3 * (xi * t5) + 2 * z2
          c.call(f2mPrefix + "_mul", t5, c.i32_const(pAltBn128Twist), AUX),
          c.call(f2mPrefix + "_add", AUX, x2, r2),
          c.call(f2mPrefix + "_add", r2, r2, r2),
          c.call(f2mPrefix + "_add", AUX, r2, r2),
          // z3 = 3 * t4 - 2 * z3
          c.call(f2mPrefix + "_sub", t4, x3, r3),
          c.call(f2mPrefix + "_add", r3, r3, r3),
          c.call(f2mPrefix + "_add", t4, r3, r3),
          // For C
          // z4 = 3 * t2 - 2 * z4
          c.call(f2mPrefix + "_sub", t2, x4, r4),
          c.call(f2mPrefix + "_add", r4, r4, r4),
          c.call(f2mPrefix + "_add", t2, r4, r4),
          // z5 = 3 * t3 + 2 * z5
          c.call(f2mPrefix + "_add", t3, x5, r5),
          c.call(f2mPrefix + "_add", r5, r5, r5),
          c.call(f2mPrefix + "_add", t3, r5, r5)
        );
      }
      function buildCyclotomicExp(exponent, fnName) {
        const exponentNafBytes = naf4(exponent).map((b) => b == -1 ? 255 : b);
        const pExponentNafBytes = module3.alloc(exponentNafBytes);
        const f = module3.addFunction(prefix + "__cyclotomicExp_" + fnName);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("bit", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("x");
        const res = c.getLocal("r");
        const inverse = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          c.call(ftmPrefix + "_conjugate", x, inverse),
          c.call(ftmPrefix + "_one", res),
          c.if(
            c.teeLocal("bit", c.i32_load8_s(c.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
            c.if(
              c.i32_eq(
                c.getLocal("bit"),
                c.i32_const(1)
              ),
              c.call(ftmPrefix + "_mul", res, x, res),
              c.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c.setLocal("i", c.i32_const(exponentNafBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "__cyclotomicSquare", res, res),
            c.if(
              c.teeLocal("bit", c.i32_load8_s(c.getLocal("i"), pExponentNafBytes)),
              c.if(
                c.i32_eq(
                  c.getLocal("bit"),
                  c.i32_const(1)
                ),
                c.call(ftmPrefix + "_mul", res, x, res),
                c.call(ftmPrefix + "_mul", res, inverse, res)
              )
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildFinalExponentiationLastChunk() {
        buildCyclotomicSquare();
        buildCyclotomicExp(finalExpZ, "w0");
        const f = module3.addFunction(prefix + "__finalExponentiationLastChunk");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const result = c.getLocal("r");
        const A = c.i32_const(module3.alloc(ftsize));
        const B = c.i32_const(module3.alloc(ftsize));
        const C = c.i32_const(module3.alloc(ftsize));
        const D = c.i32_const(module3.alloc(ftsize));
        const E = c.i32_const(module3.alloc(ftsize));
        const F = c.i32_const(module3.alloc(ftsize));
        const G = c.i32_const(module3.alloc(ftsize));
        const H = c.i32_const(module3.alloc(ftsize));
        const I = c.i32_const(module3.alloc(ftsize));
        const J = c.i32_const(module3.alloc(ftsize));
        const K = c.i32_const(module3.alloc(ftsize));
        const L = c.i32_const(module3.alloc(ftsize));
        const M = c.i32_const(module3.alloc(ftsize));
        const N = c.i32_const(module3.alloc(ftsize));
        const O = c.i32_const(module3.alloc(ftsize));
        const P = c.i32_const(module3.alloc(ftsize));
        const Q = c.i32_const(module3.alloc(ftsize));
        const R = c.i32_const(module3.alloc(ftsize));
        const S = c.i32_const(module3.alloc(ftsize));
        const T = c.i32_const(module3.alloc(ftsize));
        const U = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          // A = exp_by_neg_z(elt)  // = elt^(-z)
          c.call(prefix + "__cyclotomicExp_w0", elt, A),
          finalExpIsNegative ? [] : c.call(ftmPrefix + "_conjugate", A, A),
          // B = A^2                // = elt^(-2*z)
          c.call(prefix + "__cyclotomicSquare", A, B),
          // C = B^2                // = elt^(-4*z)
          c.call(prefix + "__cyclotomicSquare", B, C),
          // D = C * B              // = elt^(-6*z)
          c.call(ftmPrefix + "_mul", C, B, D),
          // E = exp_by_neg_z(D)    // = elt^(6*z^2)
          c.call(prefix + "__cyclotomicExp_w0", D, E),
          finalExpIsNegative ? [] : c.call(ftmPrefix + "_conjugate", E, E),
          // F = E^2                // = elt^(12*z^2)
          c.call(prefix + "__cyclotomicSquare", E, F),
          // G = epx_by_neg_z(F)    // = elt^(-12*z^3)
          c.call(prefix + "__cyclotomicExp_w0", F, G),
          finalExpIsNegative ? [] : c.call(ftmPrefix + "_conjugate", G, G),
          // H = conj(D)            // = elt^(6*z)
          c.call(ftmPrefix + "_conjugate", D, H),
          // I = conj(G)            // = elt^(12*z^3)
          c.call(ftmPrefix + "_conjugate", G, I),
          // J = I * E              // = elt^(12*z^3 + 6*z^2)
          c.call(ftmPrefix + "_mul", I, E, J),
          // K = J * H              // = elt^(12*z^3 + 6*z^2 + 6*z)
          c.call(ftmPrefix + "_mul", J, H, K),
          // L = K * B              // = elt^(12*z^3 + 6*z^2 + 4*z)
          c.call(ftmPrefix + "_mul", K, B, L),
          // M = K * E              // = elt^(12*z^3 + 12*z^2 + 6*z)
          c.call(ftmPrefix + "_mul", K, E, M),
          // N = M * elt            // = elt^(12*z^3 + 12*z^2 + 6*z + 1)
          c.call(ftmPrefix + "_mul", M, elt, N),
          // O = L.Frobenius_map(1) // = elt^(q*(12*z^3 + 6*z^2 + 4*z))
          c.call(prefix + "__frobeniusMap1", L, O),
          // P = O * N              // = elt^(q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c.call(ftmPrefix + "_mul", O, N, P),
          // Q = K.Frobenius_map(2) // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z))
          c.call(prefix + "__frobeniusMap2", K, Q),
          // R = Q * P              // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c.call(ftmPrefix + "_mul", Q, P, R),
          // S = conj(elt)          // = elt^(-1)
          c.call(ftmPrefix + "_conjugate", elt, S),
          // T = S * L              // = elt^(12*z^3 + 6*z^2 + 4*z - 1)
          c.call(ftmPrefix + "_mul", S, L, T),
          // U = T.Frobenius_map(3) // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1))
          c.call(prefix + "__frobeniusMap3", T, U),
          // V = U * R              // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1) + q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c.call(ftmPrefix + "_mul", U, R, result)
          // result = V
        );
      }
      function buildFinalExponentiation() {
        buildFinalExponentiationFirstChunk();
        buildFinalExponentiationLastChunk();
        const f = module3.addFunction(prefix + "_finalExponentiation");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const result = c.getLocal("r");
        const eltToFirstChunk = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          c.call(prefix + "__finalExponentiationFirstChunk", elt, eltToFirstChunk),
          c.call(prefix + "__finalExponentiationLastChunk", eltToFirstChunk, result)
        );
      }
      function buildFinalExponentiationOld() {
        const f = module3.addFunction(prefix + "_finalExponentiationOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const exponent = 552484233613224096312617126783173147097382103762957654188882734314196910839907541213974502761540629817009608548654680343627701153829446747810907373256841551006201639677726139946029199968412598804882391702273019083653272047566316584365559776493027495458238373902875937659943504873220554161550525926302303331747463515644711876653177129578303191095900909191624817826566688241804408081892785725967931714097716709526092261278071952560171111444072049229123565057483750161460024353346284167282452756217662335528813519139808291170539072125381230815729071544861602750936964829313608137325426383735122175229541155376346436093930287402089517426973178917569713384748081827255472576937471496195752727188261435633271238710131736096299798168852925540549342330775279877006784354801422249722573783561685179618816480037695005515426162362431072245638324744480n;
        const pExponent = module3.alloc(utils2.bigInt2BytesLE(exponent, 352));
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(ftmPrefix + "_exp", c.getLocal("x"), c.i32_const(pExponent), c.i32_const(352), c.getLocal("r"))
        );
      }
      const pPreP = module3.alloc(prePSize);
      const pPreQ = module3.alloc(preQSize);
      function buildPairingEquation(nPairings) {
        const f = module3.addFunction(prefix + "_pairingEq" + nPairings);
        for (let i = 0; i < nPairings; i++) {
          f.addParam("p_" + i, "i32");
          f.addParam("q_" + i, "i32");
        }
        f.addParam("c", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        const auxT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(ftmPrefix + "_one", resT));
        for (let i = 0; i < nPairings; i++) {
          f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p_" + i), c.i32_const(pPreP)));
          f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q_" + i), c.i32_const(pPreQ)));
          f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), auxT));
          f.addCode(c.call(ftmPrefix + "_mul", resT, auxT, resT));
        }
        f.addCode(c.call(prefix + "_finalExponentiation", resT, resT));
        f.addCode(c.call(ftmPrefix + "_eq", resT, c.getLocal("c")));
      }
      function buildPairing4() {
        const f = module3.addFunction(prefix + "_pairing");
        f.addParam("p", "i32");
        f.addParam("q", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p"), c.i32_const(pPreP)));
        f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q"), c.i32_const(pPreQ)));
        f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), resT));
        f.addCode(c.call(prefix + "_finalExponentiation", resT, c.getLocal("r")));
      }
      buildPrepAddStep();
      buildPrepDoubleStep();
      buildPrepareG1();
      buildPrepareG2();
      buildMulBy024();
      buildMulBy024Old();
      buildMillerLoop();
      for (let i = 0; i < 10; i++) {
        buildFrobeniusMap(i);
        module3.exportFunction(prefix + "__frobeniusMap" + i);
      }
      buildFinalExponentiationOld();
      buildFinalExponentiation();
      for (let i = 1; i <= 5; i++) {
        buildPairingEquation(i);
        module3.exportFunction(prefix + "_pairingEq" + i);
      }
      buildPairing4();
      module3.exportFunction(prefix + "_pairing");
      module3.exportFunction(prefix + "_prepareG1");
      module3.exportFunction(prefix + "_prepareG2");
      module3.exportFunction(prefix + "_millerLoop");
      module3.exportFunction(prefix + "_finalExponentiation");
      module3.exportFunction(prefix + "_finalExponentiationOld");
      module3.exportFunction(prefix + "__mulBy024");
      module3.exportFunction(prefix + "__mulBy024Old");
      module3.exportFunction(prefix + "__cyclotomicSquare");
      module3.exportFunction(prefix + "__cyclotomicExp_w0");
    };
  }
});

// ../../node_modules/wasmcurves/src/bls12381/build_bls12381.js
var require_build_bls123813 = __commonJS({
  "../../node_modules/wasmcurves/src/bls12381/build_bls12381.js"(exports, module2) {
    "use strict";
    var utils2 = require_utils3();
    var buildF1m = require_build_f1m3();
    var buildF1 = require_build_f13();
    var buildF2m = require_build_f2m3();
    var buildF3m = require_build_f3m3();
    var buildCurve = require_build_curve_jacobian_a03();
    var buildFFT4 = require_build_fft3();
    var buildPol = require_build_pol3();
    var buildQAP = require_build_qap3();
    var buildApplyKey = require_build_applykey3();
    var { bitLength: bitLength5, isOdd: isOdd4, isNegative: isNegative5 } = require_bigint3();
    module2.exports = function buildBLS12381(module3, _prefix) {
      const prefix = _prefix || "bls12381";
      if (module3.modules[prefix])
        return prefix;
      const q = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
      const r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;
      const n64q = Math.floor((bitLength5(q - 1n) - 1) / 64) + 1;
      const n8q = n64q * 8;
      const f1size = n8q;
      const f2size = f1size * 2;
      const ftsize = f1size * 12;
      const n64r = Math.floor((bitLength5(r - 1n) - 1) / 64) + 1;
      const n8r = n64r * 8;
      const frsize = n8r;
      const pr = module3.alloc(utils2.bigInt2BytesLE(r, frsize));
      const f1mPrefix = buildF1m(module3, q, "f1m", "intq");
      buildF1(module3, r, "fr", "frm", "intr");
      const pG1b = module3.alloc(utils2.bigInt2BytesLE(toMontgomery(4n), f1size));
      const g1mPrefix = buildCurve(module3, "g1m", "f1m", pG1b);
      buildFFT4(module3, "frm", "frm", "frm", "frm_mul");
      buildPol(module3, "pol", "frm");
      buildQAP(module3, "qap", "frm");
      const f2mPrefix = buildF2m(module3, "f1m_neg", "f2m", "f1m");
      const pG2b = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(4n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(4n), f1size)
      ]);
      const g2mPrefix = buildCurve(module3, "g2m", "f2m", pG2b);
      function buildGTimesFr(fnName, opMul) {
        const f = module3.addFunction(fnName);
        f.addParam("pG", "i32");
        f.addParam("pFr", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const AUX = c.i32_const(module3.alloc(n8r));
        f.addCode(
          c.call("frm_fromMontgomery", c.getLocal("pFr"), AUX),
          c.call(
            opMul,
            c.getLocal("pG"),
            AUX,
            c.i32_const(n8r),
            c.getLocal("pr")
          )
        );
        module3.exportFunction(fnName);
      }
      buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
      buildFFT4(module3, "g1m", "g1m", "frm", "g1m_timesFr");
      buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
      buildFFT4(module3, "g2m", "g2m", "frm", "g2m_timesFr");
      buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
      buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
      buildApplyKey(module3, "frm_batchApplyKey", "fmr", "frm", n8r, n8r, n8r, "frm_mul");
      buildApplyKey(module3, "g1m_batchApplyKey", "g1m", "frm", n8q * 3, n8q * 3, n8r, "g1m_timesFr");
      buildApplyKey(module3, "g1m_batchApplyKeyMixed", "g1m", "frm", n8q * 2, n8q * 3, n8r, "g1m_timesFrAffine");
      buildApplyKey(module3, "g2m_batchApplyKey", "g2m", "frm", n8q * 2 * 3, n8q * 3 * 2, n8r, "g2m_timesFr");
      buildApplyKey(module3, "g2m_batchApplyKeyMixed", "g2m", "frm", n8q * 2 * 2, n8q * 3 * 2, n8r, "g2m_timesFrAffine");
      function toMontgomery(a) {
        return BigInt(a) * (1n << BigInt(f1size * 8)) % q;
      }
      const G1gen = [
        3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507n,
        1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569n,
        1n
      ];
      const pG1gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
        ]
      );
      const G1zero = [
        0n,
        1n,
        0n
      ];
      const pG1zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
        ]
      );
      const G2gen = [
        [
          352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160n,
          3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758n
        ],
        [
          1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905n,
          927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582n
        ],
        [
          1n,
          0n
        ]
      ];
      const pG2gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
        ]
      );
      const G2zero = [
        [
          0n,
          0n
        ],
        [
          1n,
          0n
        ],
        [
          0n,
          0n
        ]
      ];
      const pG2zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
        ]
      );
      const pOneT = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size)
      ]);
      const pBls12381Twist = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size)
      ]);
      function build_mulNR2() {
        const f = module3.addFunction(f2mPrefix + "_mulNR");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const x0c = c.i32_const(module3.alloc(f1size));
        const x0 = c.getLocal("x");
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(f1size));
        const r0 = c.getLocal("pr");
        const r1 = c.i32_add(c.getLocal("pr"), c.i32_const(f1size));
        f.addCode(
          c.call(f1mPrefix + "_copy", x0, x0c),
          c.call(f1mPrefix + "_sub", x0, x1, r0),
          c.call(f1mPrefix + "_add", x0c, x1, r1)
        );
      }
      build_mulNR2();
      const f6mPrefix = buildF3m(module3, f2mPrefix + "_mulNR", "f6m", "f2m");
      function build_mulNR6() {
        const f = module3.addFunction(f6mPrefix + "_mulNR");
        f.addParam("x", "i32");
        f.addParam("pr", "i32");
        const c = f.getCodeBuilder();
        const c0copy = c.i32_const(module3.alloc(f1size * 2));
        f.addCode(
          c.call(
            f2mPrefix + "_copy",
            c.getLocal("x"),
            c0copy
          ),
          c.call(
            f2mPrefix + "_mulNR",
            c.i32_add(c.getLocal("x"), c.i32_const(n8q * 4)),
            c.getLocal("pr")
          ),
          c.call(
            f2mPrefix + "_copy",
            c.i32_add(c.getLocal("x"), c.i32_const(n8q * 2)),
            c.i32_add(c.getLocal("pr"), c.i32_const(n8q * 4))
          ),
          c.call(
            f2mPrefix + "_copy",
            c0copy,
            c.i32_add(c.getLocal("pr"), c.i32_const(n8q * 2))
          )
        );
      }
      build_mulNR6();
      const ftmPrefix = buildF2m(module3, f6mPrefix + "_mulNR", "ftm", f6mPrefix);
      const ateLoopCount = 0xd201000000010000n;
      const ateLoopBitBytes = bits4(ateLoopCount);
      const pAteLoopBitBytes = module3.alloc(ateLoopBitBytes);
      const isLoopNegative = true;
      const ateCoefSize = 3 * f2size;
      const ateNDblCoefs = ateLoopBitBytes.length - 1;
      const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) => acc + (b != 0 ? 1 : 0), 0);
      const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
      const prePSize = 3 * 2 * n8q;
      const preQSize = 3 * n8q * 2 + ateNCoefs * ateCoefSize;
      const finalExpIsNegative = true;
      const finalExpZ = 15132376222941642752n;
      module3.modules[prefix] = {
        n64q,
        n64r,
        n8q,
        n8r,
        pG1gen,
        pG1zero,
        pG1b,
        pG2gen,
        pG2zero,
        pG2b,
        pq: module3.modules["f1m"].pq,
        pr,
        pOneT,
        r,
        q,
        prePSize,
        preQSize
      };
      function naf4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            const z = 2 - Number(E % 4n);
            res.push(z);
            E = E - BigInt(z);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function bits4(n) {
        let E = n;
        const res = [];
        while (E > 0n) {
          if (isOdd4(E)) {
            res.push(1);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function buildPrepareG1() {
        const f = module3.addFunction(prefix + "_prepareG1");
        f.addParam("pP", "i32");
        f.addParam("ppreP", "i32");
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(g1mPrefix + "_normalize", c.getLocal("pP"), c.getLocal("ppreP"))
          // TODO Remove if already in affine
        );
      }
      function buildPrepDoubleStep() {
        const f = module3.addFunction(prefix + "_prepDblStep");
        f.addParam("R", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const Rx = c.getLocal("R");
        const Ry = c.i32_add(c.getLocal("R"), c.i32_const(2 * n8q));
        const Rz = c.i32_add(c.getLocal("R"), c.i32_const(4 * n8q));
        const t0 = c.getLocal("r");
        const t3 = c.i32_add(c.getLocal("r"), c.i32_const(2 * n8q));
        const t6 = c.i32_add(c.getLocal("r"), c.i32_const(4 * n8q));
        const zsquared = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // tmp0 = r.x.square();
          c.call(f2mPrefix + "_square", Rx, t0),
          // tmp1 = r.y.square();
          c.call(f2mPrefix + "_square", Ry, t1),
          // tmp2 = tmp1.square();
          c.call(f2mPrefix + "_square", t1, t2),
          // tmp3 = (tmp1 + r.x).square() - tmp0 - tmp2;
          c.call(f2mPrefix + "_add", t1, Rx, t3),
          c.call(f2mPrefix + "_square", t3, t3),
          c.call(f2mPrefix + "_sub", t3, t0, t3),
          c.call(f2mPrefix + "_sub", t3, t2, t3),
          // tmp3 = tmp3 + tmp3;
          c.call(f2mPrefix + "_add", t3, t3, t3),
          // tmp4 = tmp0 + tmp0 + tmp0;
          c.call(f2mPrefix + "_add", t0, t0, t4),
          c.call(f2mPrefix + "_add", t4, t0, t4),
          // tmp6 = r.x + tmp4;
          c.call(f2mPrefix + "_add", Rx, t4, t6),
          // tmp5 = tmp4.square();
          c.call(f2mPrefix + "_square", t4, t5),
          // zsquared = r.z.square();
          c.call(f2mPrefix + "_square", Rz, zsquared),
          // r.x = tmp5 - tmp3 - tmp3;
          c.call(f2mPrefix + "_sub", t5, t3, Rx),
          c.call(f2mPrefix + "_sub", Rx, t3, Rx),
          // r.z = (r.z + r.y).square() - tmp1 - zsquared;
          c.call(f2mPrefix + "_add", Rz, Ry, Rz),
          c.call(f2mPrefix + "_square", Rz, Rz),
          c.call(f2mPrefix + "_sub", Rz, t1, Rz),
          c.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
          // r.y = (tmp3 - r.x) * tmp4;
          c.call(f2mPrefix + "_sub", t3, Rx, Ry),
          c.call(f2mPrefix + "_mul", Ry, t4, Ry),
          // tmp2 = tmp2 + tmp2;
          c.call(f2mPrefix + "_add", t2, t2, t2),
          // tmp2 = tmp2 + tmp2;
          c.call(f2mPrefix + "_add", t2, t2, t2),
          // tmp2 = tmp2 + tmp2;
          c.call(f2mPrefix + "_add", t2, t2, t2),
          // r.y -= tmp2;
          c.call(f2mPrefix + "_sub", Ry, t2, Ry),
          // tmp3 = tmp4 * zsquared;
          c.call(f2mPrefix + "_mul", t4, zsquared, t3),
          // tmp3 = tmp3 + tmp3;
          c.call(f2mPrefix + "_add", t3, t3, t3),
          // tmp3 = -tmp3;
          c.call(f2mPrefix + "_neg", t3, t3),
          // tmp6 = tmp6.square() - tmp0 - tmp5;
          c.call(f2mPrefix + "_square", t6, t6),
          c.call(f2mPrefix + "_sub", t6, t0, t6),
          c.call(f2mPrefix + "_sub", t6, t5, t6),
          // tmp1 = tmp1 + tmp1;
          c.call(f2mPrefix + "_add", t1, t1, t1),
          // tmp1 = tmp1 + tmp1;
          c.call(f2mPrefix + "_add", t1, t1, t1),
          // tmp6 = tmp6 - tmp1;
          c.call(f2mPrefix + "_sub", t6, t1, t6),
          // tmp0 = r.z * zsquared;
          c.call(f2mPrefix + "_mul", Rz, zsquared, t0),
          // tmp0 = tmp0 + tmp0;
          c.call(f2mPrefix + "_add", t0, t0, t0)
        );
      }
      function buildPrepAddStep() {
        const f = module3.addFunction(prefix + "_prepAddStep");
        f.addParam("R", "i32");
        f.addParam("Q", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const Rx = c.getLocal("R");
        const Ry = c.i32_add(c.getLocal("R"), c.i32_const(2 * n8q));
        const Rz = c.i32_add(c.getLocal("R"), c.i32_const(4 * n8q));
        const Qx = c.getLocal("Q");
        const Qy = c.i32_add(c.getLocal("Q"), c.i32_const(2 * n8q));
        const t10 = c.getLocal("r");
        const t1 = c.i32_add(c.getLocal("r"), c.i32_const(2 * n8q));
        const t9 = c.i32_add(c.getLocal("r"), c.i32_const(4 * n8q));
        const zsquared = c.i32_const(module3.alloc(f2size));
        const ysquared = c.i32_const(module3.alloc(f2size));
        const ztsquared = c.i32_const(module3.alloc(f2size));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t3 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        const t6 = c.i32_const(module3.alloc(f2size));
        const t7 = c.i32_const(module3.alloc(f2size));
        const t8 = c.i32_const(module3.alloc(f2size));
        f.addCode(
          // zsquared = r.z.square();
          c.call(f2mPrefix + "_square", Rz, zsquared),
          // ysquared = q.y.square();
          c.call(f2mPrefix + "_square", Qy, ysquared),
          // t0 = zsquared * q.x;
          c.call(f2mPrefix + "_mul", zsquared, Qx, t0),
          // t1 = ((q.y + r.z).square() - ysquared - zsquared) * zsquared;
          c.call(f2mPrefix + "_add", Qy, Rz, t1),
          c.call(f2mPrefix + "_square", t1, t1),
          c.call(f2mPrefix + "_sub", t1, ysquared, t1),
          c.call(f2mPrefix + "_sub", t1, zsquared, t1),
          c.call(f2mPrefix + "_mul", t1, zsquared, t1),
          // t2 = t0 - r.x;
          c.call(f2mPrefix + "_sub", t0, Rx, t2),
          // t3 = t2.square();
          c.call(f2mPrefix + "_square", t2, t3),
          // t4 = t3 + t3;
          c.call(f2mPrefix + "_add", t3, t3, t4),
          // t4 = t4 + t4;
          c.call(f2mPrefix + "_add", t4, t4, t4),
          // t5 = t4 * t2;
          c.call(f2mPrefix + "_mul", t4, t2, t5),
          // t6 = t1 - r.y - r.y;
          c.call(f2mPrefix + "_sub", t1, Ry, t6),
          c.call(f2mPrefix + "_sub", t6, Ry, t6),
          // t9 = t6 * q.x;
          c.call(f2mPrefix + "_mul", t6, Qx, t9),
          // t7 = t4 * r.x;
          c.call(f2mPrefix + "_mul", t4, Rx, t7),
          // r.x = t6.square() - t5 - t7 - t7;
          c.call(f2mPrefix + "_square", t6, Rx),
          c.call(f2mPrefix + "_sub", Rx, t5, Rx),
          c.call(f2mPrefix + "_sub", Rx, t7, Rx),
          c.call(f2mPrefix + "_sub", Rx, t7, Rx),
          // r.z = (r.z + t2).square() - zsquared - t3;
          c.call(f2mPrefix + "_add", Rz, t2, Rz),
          c.call(f2mPrefix + "_square", Rz, Rz),
          c.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
          c.call(f2mPrefix + "_sub", Rz, t3, Rz),
          // t10 = q.y + r.z;
          c.call(f2mPrefix + "_add", Qy, Rz, t10),
          // t8 = (t7 - r.x) * t6;
          c.call(f2mPrefix + "_sub", t7, Rx, t8),
          c.call(f2mPrefix + "_mul", t8, t6, t8),
          // t0 = r.y * t5;
          c.call(f2mPrefix + "_mul", Ry, t5, t0),
          // t0 = t0 + t0;
          c.call(f2mPrefix + "_add", t0, t0, t0),
          // r.y = t8 - t0;
          c.call(f2mPrefix + "_sub", t8, t0, Ry),
          // t10 = t10.square() - ysquared;
          c.call(f2mPrefix + "_square", t10, t10),
          c.call(f2mPrefix + "_sub", t10, ysquared, t10),
          // ztsquared = r.z.square();
          c.call(f2mPrefix + "_square", Rz, ztsquared),
          // t10 = t10 - ztsquared;
          c.call(f2mPrefix + "_sub", t10, ztsquared, t10),
          // t9 = t9 + t9 - t10;
          c.call(f2mPrefix + "_add", t9, t9, t9),
          c.call(f2mPrefix + "_sub", t9, t10, t9),
          // t10 = r.z + r.z;
          c.call(f2mPrefix + "_add", Rz, Rz, t10),
          // t6 = -t6;
          c.call(f2mPrefix + "_neg", t6, t6),
          // t1 = t6 + t6;
          c.call(f2mPrefix + "_add", t6, t6, t1)
        );
      }
      function buildPrepareG2() {
        const f = module3.addFunction(prefix + "_prepareG2");
        f.addParam("pQ", "i32");
        f.addParam("ppreQ", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const Q = c.getLocal("pQ");
        const pR = module3.alloc(f2size * 3);
        const R = c.i32_const(pR);
        const base = c.getLocal("ppreQ");
        f.addCode(
          c.call(g2mPrefix + "_normalize", Q, base),
          c.if(
            c.call(g2mPrefix + "_isZero", base),
            c.ret([])
          ),
          c.call(g2mPrefix + "_copy", base, R),
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3)))
        );
        f.addCode(
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "_prepDblStep", R, c.getLocal("pCoef")),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(prefix + "_prepAddStep", R, base, c.getLocal("pCoef")),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
      }
      function buildF6Mul1() {
        const f = module3.addFunction(f6mPrefix + "_mul1");
        f.addParam("pA", "i32");
        f.addParam("pC1", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const A_c0 = c.getLocal("pA");
        const A_c1 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 2));
        const A_c2 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 4));
        const c1 = c.getLocal("pC1");
        const t1 = c.getLocal("pR");
        const t2 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 2));
        const b_b = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 4));
        const Ac0_Ac1 = c.i32_const(module3.alloc(f1size * 2));
        const Ac1_Ac2 = c.i32_const(module3.alloc(f1size * 2));
        f.addCode(
          c.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
          c.call(f2mPrefix + "_add", A_c1, A_c2, Ac1_Ac2),
          // let b_b = self.c1 * c1;
          c.call(f2mPrefix + "_mul", A_c1, c1, b_b),
          // let t1 = (self.c1 + self.c2) * c1 - b_b;
          c.call(f2mPrefix + "_mul", Ac1_Ac2, c1, t1),
          c.call(f2mPrefix + "_sub", t1, b_b, t1),
          // let t1 = t1.mul_by_nonresidue();
          c.call(f2mPrefix + "_mulNR", t1, t1),
          // let t2 = (self.c0 + self.c1) * c1 - b_b;
          c.call(f2mPrefix + "_mul", Ac0_Ac1, c1, t2),
          c.call(f2mPrefix + "_sub", t2, b_b, t2)
        );
      }
      buildF6Mul1();
      function buildF6Mul01() {
        const f = module3.addFunction(f6mPrefix + "_mul01");
        f.addParam("pA", "i32");
        f.addParam("pC0", "i32");
        f.addParam("pC1", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const A_c0 = c.getLocal("pA");
        const A_c1 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 2));
        const A_c2 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 4));
        const c0 = c.getLocal("pC0");
        const c1 = c.getLocal("pC1");
        const t1 = c.getLocal("pR");
        const t2 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 2));
        const t3 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 4));
        const a_a = c.i32_const(module3.alloc(f1size * 2));
        const b_b = c.i32_const(module3.alloc(f1size * 2));
        const Ac0_Ac1 = c.i32_const(module3.alloc(f1size * 2));
        const Ac0_Ac2 = c.i32_const(module3.alloc(f1size * 2));
        f.addCode(
          // let a_a = self.c0 * c0;
          c.call(f2mPrefix + "_mul", A_c0, c0, a_a),
          // let b_b = self.c1 * c1;
          c.call(f2mPrefix + "_mul", A_c1, c1, b_b),
          c.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
          c.call(f2mPrefix + "_add", A_c0, A_c2, Ac0_Ac2),
          // let t1 = (self.c1 + self.c2) * c1 - b_b;
          c.call(f2mPrefix + "_add", A_c1, A_c2, t1),
          c.call(f2mPrefix + "_mul", t1, c1, t1),
          c.call(f2mPrefix + "_sub", t1, b_b, t1),
          // let t1 = t1.mul_by_nonresidue() + a_a;
          c.call(f2mPrefix + "_mulNR", t1, t1),
          c.call(f2mPrefix + "_add", t1, a_a, t1),
          // let t2 = (c0 + c1) * (self.c0 + self.c1) - a_a - b_b;
          c.call(f2mPrefix + "_add", c0, c1, t2),
          c.call(f2mPrefix + "_mul", t2, Ac0_Ac1, t2),
          c.call(f2mPrefix + "_sub", t2, a_a, t2),
          c.call(f2mPrefix + "_sub", t2, b_b, t2),
          // let t3 = (self.c0 + self.c2) * c0 - a_a + b_b;
          c.call(f2mPrefix + "_mul", Ac0_Ac2, c0, t3),
          c.call(f2mPrefix + "_sub", t3, a_a, t3),
          c.call(f2mPrefix + "_add", t3, b_b, t3)
        );
      }
      buildF6Mul01();
      function buildF12Mul014() {
        const f = module3.addFunction(ftmPrefix + "_mul014");
        f.addParam("pA", "i32");
        f.addParam("pC0", "i32");
        f.addParam("pC1", "i32");
        f.addParam("pC4", "i32");
        f.addParam("pR", "i32");
        const c = f.getCodeBuilder();
        const A_c0 = c.getLocal("pA");
        const A_c1 = c.i32_add(c.getLocal("pA"), c.i32_const(f1size * 6));
        const c0 = c.getLocal("pC0");
        const c1 = c.getLocal("pC1");
        const c4 = c.getLocal("pC4");
        const aa = c.i32_const(module3.alloc(f1size * 6));
        const bb = c.i32_const(module3.alloc(f1size * 6));
        const o = c.i32_const(module3.alloc(f1size * 2));
        const R_c0 = c.getLocal("pR");
        const R_c1 = c.i32_add(c.getLocal("pR"), c.i32_const(f1size * 6));
        f.addCode(
          // let aa = self.c0.mul_by_01(c0, c1);
          c.call(f6mPrefix + "_mul01", A_c0, c0, c1, aa),
          // let bb = self.c1.mul_by_1(c4);
          c.call(f6mPrefix + "_mul1", A_c1, c4, bb),
          // let o = c1 + c4;
          c.call(f2mPrefix + "_add", c1, c4, o),
          // let c1 = self.c1 + self.c0;
          c.call(f6mPrefix + "_add", A_c1, A_c0, R_c1),
          // let c1 = c1.mul_by_01(c0, &o);
          c.call(f6mPrefix + "_mul01", R_c1, c0, o, R_c1),
          // let c1 = c1 - aa - bb;
          c.call(f6mPrefix + "_sub", R_c1, aa, R_c1),
          c.call(f6mPrefix + "_sub", R_c1, bb, R_c1),
          // let c0 = bb;
          c.call(f6mPrefix + "_copy", bb, R_c0),
          // let c0 = c0.mul_by_nonresidue();
          c.call(f6mPrefix + "_mulNR", R_c0, R_c0),
          // let c0 = c0 + aa;
          c.call(f6mPrefix + "_add", R_c0, aa, R_c0)
        );
      }
      buildF12Mul014();
      function buildELL() {
        const f = module3.addFunction(prefix + "_ell");
        f.addParam("pP", "i32");
        f.addParam("pCoefs", "i32");
        f.addParam("pF", "i32");
        const c = f.getCodeBuilder();
        const Px = c.getLocal("pP");
        const Py = c.i32_add(c.getLocal("pP"), c.i32_const(n8q));
        const F = c.getLocal("pF");
        const coef0_0 = c.getLocal("pCoefs");
        const coef0_1 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size));
        const coef1_0 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size * 2));
        const coef1_1 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size * 3));
        const coef2 = c.i32_add(c.getLocal("pCoefs"), c.i32_const(f1size * 4));
        const pc0 = module3.alloc(f1size * 2);
        const c0 = c.i32_const(pc0);
        const c0_c0 = c.i32_const(pc0);
        const c0_c1 = c.i32_const(pc0 + f1size);
        const pc1 = module3.alloc(f1size * 2);
        const c1 = c.i32_const(pc1);
        const c1_c0 = c.i32_const(pc1);
        const c1_c1 = c.i32_const(pc1 + f1size);
        f.addCode(
          //     let mut c0 = coeffs.0;
          //     let mut c1 = coeffs.1;
          //
          //    c0.c0 *= p.y;
          //    c0.c1 *= p.y;
          //
          //    c1.c0 *= p.x;
          //    c1.c1 *= p.x;
          //
          //     f.mul_by_014(&coeffs.2, &c1, &c0)
          c.call(f1mPrefix + "_mul", coef0_0, Py, c0_c0),
          c.call(f1mPrefix + "_mul", coef0_1, Py, c0_c1),
          c.call(f1mPrefix + "_mul", coef1_0, Px, c1_c0),
          c.call(f1mPrefix + "_mul", coef1_1, Px, c1_c1),
          c.call(ftmPrefix + "_mul014", F, coef2, c1, c0, F)
        );
      }
      buildELL();
      function buildMillerLoop() {
        const f = module3.addFunction(prefix + "_millerLoop");
        f.addParam("ppreP", "i32");
        f.addParam("ppreQ", "i32");
        f.addParam("r", "i32");
        f.addLocal("pCoef", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const preP = c.getLocal("ppreP");
        const coefs = c.getLocal("pCoef");
        const F = c.getLocal("r");
        f.addCode(
          c.call(ftmPrefix + "_one", F),
          c.if(
            c.call(g1mPrefix + "_isZero", preP),
            c.ret([])
          ),
          c.if(
            c.call(g1mPrefix + "_isZero", c.getLocal("ppreQ")),
            c.ret([])
          ),
          c.setLocal("pCoef", c.i32_add(c.getLocal("ppreQ"), c.i32_const(f2size * 3))),
          c.setLocal("i", c.i32_const(ateLoopBitBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "_ell", preP, coefs, F),
            c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize))),
            c.if(
              c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
              [
                ...c.call(prefix + "_ell", preP, coefs, F),
                ...c.setLocal("pCoef", c.i32_add(c.getLocal("pCoef"), c.i32_const(ateCoefSize)))
              ]
            ),
            c.call(ftmPrefix + "_square", F, F),
            c.br_if(1, c.i32_eq(c.getLocal("i"), c.i32_const(1))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          )),
          c.call(prefix + "_ell", preP, coefs, F)
        );
        if (isLoopNegative) {
          f.addCode(
            c.call(ftmPrefix + "_conjugate", F, F)
          );
        }
      }
      function buildFrobeniusMap(n) {
        const F12 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n, 151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],
            [2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n, 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n, 877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n],
            [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
            [151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n, 3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n, 2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
            [877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n, 3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n]
          ]
        ];
        const F6 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [0n, 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [0n, 1n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [0n, 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n]
          ],
          [
            [1n, 0n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n]
          ]
        ];
        const f = module3.addFunction(ftmPrefix + "_frobeniusMap" + n);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        for (let i = 0; i < 6; i++) {
          const X = i == 0 ? c.getLocal("x") : c.i32_add(c.getLocal("x"), c.i32_const(i * f2size));
          const Xc0 = X;
          const Xc1 = c.i32_add(c.getLocal("x"), c.i32_const(i * f2size + f1size));
          const R = i == 0 ? c.getLocal("r") : c.i32_add(c.getLocal("r"), c.i32_const(i * f2size));
          const Rc0 = R;
          const Rc1 = c.i32_add(c.getLocal("r"), c.i32_const(i * f2size + f1size));
          const coef = mul22(F12[Math.floor(i / 3)][n % 12], F6[i % 3][n % 6]);
          const pCoef = module3.alloc([
            ...utils2.bigInt2BytesLE(toMontgomery(coef[0]), n8q),
            ...utils2.bigInt2BytesLE(toMontgomery(coef[1]), n8q)
          ]);
          if (n % 2 == 1) {
            f.addCode(
              c.call(f1mPrefix + "_copy", Xc0, Rc0),
              c.call(f1mPrefix + "_neg", Xc1, Rc1),
              c.call(f2mPrefix + "_mul", R, c.i32_const(pCoef), R)
            );
          } else {
            f.addCode(c.call(f2mPrefix + "_mul", X, c.i32_const(pCoef), R));
          }
        }
        function mul22(a, b) {
          const ac0 = a[0];
          const ac1 = a[1];
          const bc0 = b[0];
          const bc1 = b[1];
          const res = [
            (ac0 * bc0 - ac1 * bc1) % q,
            (ac0 * bc1 + ac1 * bc0) % q
          ];
          if (isNegative5(res[0]))
            res[0] = res[0] + q;
          return res;
        }
      }
      function buildCyclotomicSquare() {
        const f = module3.addFunction(prefix + "__cyclotomicSquare");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const x0 = c.getLocal("x");
        const x4 = c.i32_add(c.getLocal("x"), c.i32_const(f2size));
        const x3 = c.i32_add(c.getLocal("x"), c.i32_const(2 * f2size));
        const x2 = c.i32_add(c.getLocal("x"), c.i32_const(3 * f2size));
        const x1 = c.i32_add(c.getLocal("x"), c.i32_const(4 * f2size));
        const x5 = c.i32_add(c.getLocal("x"), c.i32_const(5 * f2size));
        const r0 = c.getLocal("r");
        const r4 = c.i32_add(c.getLocal("r"), c.i32_const(f2size));
        const r3 = c.i32_add(c.getLocal("r"), c.i32_const(2 * f2size));
        const r2 = c.i32_add(c.getLocal("r"), c.i32_const(3 * f2size));
        const r1 = c.i32_add(c.getLocal("r"), c.i32_const(4 * f2size));
        const r5 = c.i32_add(c.getLocal("r"), c.i32_const(5 * f2size));
        const t0 = c.i32_const(module3.alloc(f2size));
        const t1 = c.i32_const(module3.alloc(f2size));
        const t2 = c.i32_const(module3.alloc(f2size));
        const t3 = c.i32_const(module3.alloc(f2size));
        const t4 = c.i32_const(module3.alloc(f2size));
        const t5 = c.i32_const(module3.alloc(f2size));
        const tmp = c.i32_const(module3.alloc(f2size));
        const AUX = c.i32_const(module3.alloc(f2size));
        f.addCode(
          //    // t0 + t1*y = (z0 + z1*y)^2 = a^2
          //    tmp = z0 * z1;
          //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;
          //    t1 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x0, x1, tmp),
          c.call(f2mPrefix + "_mulNR", x1, t0),
          c.call(f2mPrefix + "_add", x0, t0, t0),
          c.call(f2mPrefix + "_add", x0, x1, AUX),
          c.call(f2mPrefix + "_mul", AUX, t0, t0),
          c.call(f2mPrefix + "_mulNR", tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t0, AUX, t0),
          c.call(f2mPrefix + "_add", tmp, tmp, t1),
          //  // t2 + t3*y = (z2 + z3*y)^2 = b^2
          //  tmp = z2 * z3;
          //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;
          //  t3 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x2, x3, tmp),
          c.call(f2mPrefix + "_mulNR", x3, t2),
          c.call(f2mPrefix + "_add", x2, t2, t2),
          c.call(f2mPrefix + "_add", x2, x3, AUX),
          c.call(f2mPrefix + "_mul", AUX, t2, t2),
          c.call(f2mPrefix + "_mulNR", tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t2, AUX, t2),
          c.call(f2mPrefix + "_add", tmp, tmp, t3),
          //  // t4 + t5*y = (z4 + z5*y)^2 = c^2
          //  tmp = z4 * z5;
          //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;
          //  t5 = tmp + tmp;
          c.call(f2mPrefix + "_mul", x4, x5, tmp),
          c.call(f2mPrefix + "_mulNR", x5, t4),
          c.call(f2mPrefix + "_add", x4, t4, t4),
          c.call(f2mPrefix + "_add", x4, x5, AUX),
          c.call(f2mPrefix + "_mul", AUX, t4, t4),
          c.call(f2mPrefix + "_mulNR", tmp, AUX),
          c.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c.call(f2mPrefix + "_sub", t4, AUX, t4),
          c.call(f2mPrefix + "_add", tmp, tmp, t5),
          // For A
          // z0 = 3 * t0 - 2 * z0
          c.call(f2mPrefix + "_sub", t0, x0, r0),
          c.call(f2mPrefix + "_add", r0, r0, r0),
          c.call(f2mPrefix + "_add", t0, r0, r0),
          // z1 = 3 * t1 + 2 * z1
          c.call(f2mPrefix + "_add", t1, x1, r1),
          c.call(f2mPrefix + "_add", r1, r1, r1),
          c.call(f2mPrefix + "_add", t1, r1, r1),
          // For B
          // z2 = 3 * (xi * t5) + 2 * z2
          c.call(f2mPrefix + "_mul", t5, c.i32_const(pBls12381Twist), AUX),
          c.call(f2mPrefix + "_add", AUX, x2, r2),
          c.call(f2mPrefix + "_add", r2, r2, r2),
          c.call(f2mPrefix + "_add", AUX, r2, r2),
          // z3 = 3 * t4 - 2 * z3
          c.call(f2mPrefix + "_sub", t4, x3, r3),
          c.call(f2mPrefix + "_add", r3, r3, r3),
          c.call(f2mPrefix + "_add", t4, r3, r3),
          // For C
          // z4 = 3 * t2 - 2 * z4
          c.call(f2mPrefix + "_sub", t2, x4, r4),
          c.call(f2mPrefix + "_add", r4, r4, r4),
          c.call(f2mPrefix + "_add", t2, r4, r4),
          // z5 = 3 * t3 + 2 * z5
          c.call(f2mPrefix + "_add", t3, x5, r5),
          c.call(f2mPrefix + "_add", r5, r5, r5),
          c.call(f2mPrefix + "_add", t3, r5, r5)
        );
      }
      function buildCyclotomicExp(exponent, isExpNegative, fnName) {
        const exponentNafBytes = naf4(exponent).map((b) => b == -1 ? 255 : b);
        const pExponentNafBytes = module3.alloc(exponentNafBytes);
        const f = module3.addFunction(prefix + "__cyclotomicExp_" + fnName);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("bit", "i32");
        f.addLocal("i", "i32");
        const c = f.getCodeBuilder();
        const x = c.getLocal("x");
        const res = c.getLocal("r");
        const inverse = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          c.call(ftmPrefix + "_conjugate", x, inverse),
          c.call(ftmPrefix + "_one", res),
          c.if(
            c.teeLocal("bit", c.i32_load8_s(c.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
            c.if(
              c.i32_eq(
                c.getLocal("bit"),
                c.i32_const(1)
              ),
              c.call(ftmPrefix + "_mul", res, x, res),
              c.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c.setLocal("i", c.i32_const(exponentNafBytes.length - 2)),
          c.block(c.loop(
            c.call(prefix + "__cyclotomicSquare", res, res),
            c.if(
              c.teeLocal("bit", c.i32_load8_s(c.getLocal("i"), pExponentNafBytes)),
              c.if(
                c.i32_eq(
                  c.getLocal("bit"),
                  c.i32_const(1)
                ),
                c.call(ftmPrefix + "_mul", res, x, res),
                c.call(ftmPrefix + "_mul", res, inverse, res)
              )
            ),
            c.br_if(1, c.i32_eqz(c.getLocal("i"))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
          ))
        );
        if (isExpNegative) {
          f.addCode(
            c.call(ftmPrefix + "_conjugate", res, res)
          );
        }
      }
      function buildFinalExponentiation() {
        buildCyclotomicSquare();
        buildCyclotomicExp(finalExpZ, finalExpIsNegative, "w0");
        const f = module3.addFunction(prefix + "_finalExponentiation");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const elt = c.getLocal("x");
        const res = c.getLocal("r");
        const t0 = c.i32_const(module3.alloc(ftsize));
        const t1 = c.i32_const(module3.alloc(ftsize));
        const t2 = c.i32_const(module3.alloc(ftsize));
        const t3 = c.i32_const(module3.alloc(ftsize));
        const t4 = c.i32_const(module3.alloc(ftsize));
        const t5 = c.i32_const(module3.alloc(ftsize));
        const t6 = c.i32_const(module3.alloc(ftsize));
        f.addCode(
          // let mut t0 = f.frobenius_map(6)
          c.call(ftmPrefix + "_frobeniusMap6", elt, t0),
          // let t1 = f.invert()
          c.call(ftmPrefix + "_inverse", elt, t1),
          // let mut t2 = t0 * t1;
          c.call(ftmPrefix + "_mul", t0, t1, t2),
          // t1 = t2.clone();
          c.call(ftmPrefix + "_copy", t2, t1),
          // t2 = t2.frobenius_map().frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap2", t2, t2),
          // t2 *= t1;
          c.call(ftmPrefix + "_mul", t2, t1, t2),
          // t1 = cyclotomic_square(t2).conjugate();
          c.call(prefix + "__cyclotomicSquare", t2, t1),
          c.call(ftmPrefix + "_conjugate", t1, t1),
          // let mut t3 = cycolotomic_exp(t2);
          c.call(prefix + "__cyclotomicExp_w0", t2, t3),
          // let mut t4 = cyclotomic_square(t3);
          c.call(prefix + "__cyclotomicSquare", t3, t4),
          // let mut t5 = t1 * t3;
          c.call(ftmPrefix + "_mul", t1, t3, t5),
          // t1 = cycolotomic_exp(t5);
          c.call(prefix + "__cyclotomicExp_w0", t5, t1),
          // t0 = cycolotomic_exp(t1);
          c.call(prefix + "__cyclotomicExp_w0", t1, t0),
          // let mut t6 = cycolotomic_exp(t0);
          c.call(prefix + "__cyclotomicExp_w0", t0, t6),
          // t6 *= t4;
          c.call(ftmPrefix + "_mul", t6, t4, t6),
          // t4 = cycolotomic_exp(t6);
          c.call(prefix + "__cyclotomicExp_w0", t6, t4),
          // t5 = t5.conjugate();
          c.call(ftmPrefix + "_conjugate", t5, t5),
          // t4 *= t5 * t2;
          c.call(ftmPrefix + "_mul", t4, t5, t4),
          c.call(ftmPrefix + "_mul", t4, t2, t4),
          // t5 = t2.conjugate();
          c.call(ftmPrefix + "_conjugate", t2, t5),
          // t1 *= t2;
          c.call(ftmPrefix + "_mul", t1, t2, t1),
          // t1 = t1.frobenius_map().frobenius_map().frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap3", t1, t1),
          // t6 *= t5;
          c.call(ftmPrefix + "_mul", t6, t5, t6),
          // t6 = t6.frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap1", t6, t6),
          // t3 *= t0;
          c.call(ftmPrefix + "_mul", t3, t0, t3),
          // t3 = t3.frobenius_map().frobenius_map();
          c.call(ftmPrefix + "_frobeniusMap2", t3, t3),
          // t3 *= t1;
          c.call(ftmPrefix + "_mul", t3, t1, t3),
          // t3 *= t6;
          c.call(ftmPrefix + "_mul", t3, t6, t3),
          // f = t3 * t4;
          c.call(ftmPrefix + "_mul", t3, t4, res)
        );
      }
      function buildFinalExponentiationOld() {
        const f = module3.addFunction(prefix + "_finalExponentiationOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        const exponent = 322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n;
        const pExponent = module3.alloc(utils2.bigInt2BytesLE(exponent, 544));
        const c = f.getCodeBuilder();
        f.addCode(
          c.call(ftmPrefix + "_exp", c.getLocal("x"), c.i32_const(pExponent), c.i32_const(544), c.getLocal("r"))
        );
      }
      const pPreP = module3.alloc(prePSize);
      const pPreQ = module3.alloc(preQSize);
      function buildPairingEquation(nPairings) {
        const f = module3.addFunction(prefix + "_pairingEq" + nPairings);
        for (let i = 0; i < nPairings; i++) {
          f.addParam("p_" + i, "i32");
          f.addParam("q_" + i, "i32");
        }
        f.addParam("c", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        const auxT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(ftmPrefix + "_one", resT));
        for (let i = 0; i < nPairings; i++) {
          f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p_" + i), c.i32_const(pPreP)));
          f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q_" + i), c.i32_const(pPreQ)));
          f.addCode(
            c.if(
              c.i32_eqz(c.call(g1mPrefix + "_inGroupAffine", c.i32_const(pPreP))),
              c.ret(c.i32_const(0))
            ),
            c.if(
              c.i32_eqz(c.call(g2mPrefix + "_inGroupAffine", c.i32_const(pPreQ))),
              c.ret(c.i32_const(0))
            )
          );
          f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), auxT));
          f.addCode(c.call(ftmPrefix + "_mul", resT, auxT, resT));
        }
        f.addCode(c.call(prefix + "_finalExponentiation", resT, resT));
        f.addCode(c.call(ftmPrefix + "_eq", resT, c.getLocal("c")));
      }
      function buildPairing4() {
        const f = module3.addFunction(prefix + "_pairing");
        f.addParam("p", "i32");
        f.addParam("q", "i32");
        f.addParam("r", "i32");
        const c = f.getCodeBuilder();
        const resT = c.i32_const(module3.alloc(ftsize));
        f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p"), c.i32_const(pPreP)));
        f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q"), c.i32_const(pPreQ)));
        f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), resT));
        f.addCode(c.call(prefix + "_finalExponentiation", resT, c.getLocal("r")));
      }
      function buildInGroupG2() {
        const f = module3.addFunction(g2mPrefix + "_inGroupAffine");
        f.addParam("p", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const WINV = [
          2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279894n,
          2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893n
        ];
        const FROB2X = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
        const FROB3Y = [
          2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,
          2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n
        ];
        const wInv = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery(WINV[0]), n8q),
          ...utils2.bigInt2BytesLE(toMontgomery(WINV[1]), n8q)
        ]));
        const frob2X = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(FROB2X), n8q)));
        const frob3Y = c.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery(FROB3Y[0]), n8q),
          ...utils2.bigInt2BytesLE(toMontgomery(FROB3Y[1]), n8q)
        ]));
        const z = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(finalExpZ, 8)));
        const px = c.getLocal("p");
        const py = c.i32_add(c.getLocal("p"), c.i32_const(f2size));
        const aux = c.i32_const(module3.alloc(f1size));
        const x_winv = c.i32_const(module3.alloc(f2size));
        const y_winv = c.i32_const(module3.alloc(f2size));
        const pf2 = module3.alloc(f2size * 2);
        const f2 = c.i32_const(pf2);
        const f2x = c.i32_const(pf2);
        const f2x_c1 = c.i32_const(pf2);
        const f2x_c2 = c.i32_const(pf2 + f1size);
        const f2y = c.i32_const(pf2 + f2size);
        const f2y_c1 = c.i32_const(pf2 + f2size);
        const f2y_c2 = c.i32_const(pf2 + f2size + f1size);
        const pf3 = module3.alloc(f2size * 3);
        const f3 = c.i32_const(pf3);
        const f3x = c.i32_const(pf3);
        const f3x_c1 = c.i32_const(pf3);
        const f3x_c2 = c.i32_const(pf3 + f1size);
        const f3y = c.i32_const(pf3 + f2size);
        const f3y_c1 = c.i32_const(pf3 + f2size);
        const f3y_c2 = c.i32_const(pf3 + f2size + f1size);
        const f3z = c.i32_const(pf3 + f2size * 2);
        f.addCode(
          c.if(
            c.call(g2mPrefix + "_isZeroAffine", c.getLocal("p")),
            c.ret(c.i32_const(1))
          ),
          c.if(
            c.i32_eqz(c.call(g2mPrefix + "_inCurveAffine", c.getLocal("p"))),
            c.ret(c.i32_const(0))
          ),
          c.call(f2mPrefix + "_mul", px, wInv, x_winv),
          c.call(f2mPrefix + "_mul", py, wInv, y_winv),
          c.call(f2mPrefix + "_mul1", x_winv, frob2X, f2x),
          c.call(f2mPrefix + "_neg", y_winv, f2y),
          c.call(f2mPrefix + "_neg", x_winv, f3x),
          c.call(f2mPrefix + "_mul", y_winv, frob3Y, f3y),
          c.call(f1mPrefix + "_sub", f2x_c1, f2x_c2, aux),
          c.call(f1mPrefix + "_add", f2x_c1, f2x_c2, f2x_c2),
          c.call(f1mPrefix + "_copy", aux, f2x_c1),
          c.call(f1mPrefix + "_sub", f2y_c1, f2y_c2, aux),
          c.call(f1mPrefix + "_add", f2y_c1, f2y_c2, f2y_c2),
          c.call(f1mPrefix + "_copy", aux, f2y_c1),
          c.call(f1mPrefix + "_add", f3x_c1, f3x_c2, aux),
          c.call(f1mPrefix + "_sub", f3x_c1, f3x_c2, f3x_c2),
          c.call(f1mPrefix + "_copy", aux, f3x_c1),
          c.call(f1mPrefix + "_sub", f3y_c2, f3y_c1, aux),
          c.call(f1mPrefix + "_add", f3y_c1, f3y_c2, f3y_c2),
          c.call(f1mPrefix + "_copy", aux, f3y_c1),
          c.call(f2mPrefix + "_one", f3z),
          c.call(g2mPrefix + "_timesScalar", f3, z, c.i32_const(8), f3),
          c.call(g2mPrefix + "_addMixed", f3, f2, f3),
          c.ret(
            c.call(g2mPrefix + "_eqMixed", f3, c.getLocal("p"))
          )
        );
        const fInGroup = module3.addFunction(g2mPrefix + "_inGroup");
        fInGroup.addParam("pIn", "i32");
        fInGroup.setReturnType("i32");
        const c2 = fInGroup.getCodeBuilder();
        const aux2 = c2.i32_const(module3.alloc(f2size * 2));
        fInGroup.addCode(
          c2.call(g2mPrefix + "_toAffine", c2.getLocal("pIn"), aux2),
          c2.ret(
            c2.call(g2mPrefix + "_inGroupAffine", aux2)
          )
        );
      }
      function buildInGroupG1() {
        const f = module3.addFunction(g1mPrefix + "_inGroupAffine");
        f.addParam("p", "i32");
        f.setReturnType("i32");
        const c = f.getCodeBuilder();
        const BETA = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
        const BETA2 = 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n;
        const Z2M1D3 = (finalExpZ * finalExpZ - 1n) / 3n;
        const beta = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(BETA), n8q)));
        const beta2 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(BETA2), n8q)));
        const z2m1d3 = c.i32_const(module3.alloc(utils2.bigInt2BytesLE(Z2M1D3, 16)));
        const px = c.getLocal("p");
        const py = c.i32_add(c.getLocal("p"), c.i32_const(f1size));
        const psp = module3.alloc(f1size * 3);
        const sp = c.i32_const(psp);
        const spx = c.i32_const(psp);
        const spy = c.i32_const(psp + f1size);
        const ps2p = module3.alloc(f1size * 2);
        const s2p = c.i32_const(ps2p);
        const s2px = c.i32_const(ps2p);
        const s2py = c.i32_const(ps2p + f1size);
        f.addCode(
          c.if(
            c.call(g1mPrefix + "_isZeroAffine", c.getLocal("p")),
            c.ret(c.i32_const(1))
          ),
          c.if(
            c.i32_eqz(c.call(g1mPrefix + "_inCurveAffine", c.getLocal("p"))),
            c.ret(c.i32_const(0))
          ),
          c.call(f1mPrefix + "_mul", px, beta, spx),
          c.call(f1mPrefix + "_copy", py, spy),
          c.call(f1mPrefix + "_mul", px, beta2, s2px),
          c.call(f1mPrefix + "_copy", py, s2py),
          c.call(g1mPrefix + "_doubleAffine", sp, sp),
          c.call(g1mPrefix + "_subMixed", sp, c.getLocal("p"), sp),
          c.call(g1mPrefix + "_subMixed", sp, s2p, sp),
          c.call(g1mPrefix + "_timesScalar", sp, z2m1d3, c.i32_const(16), sp),
          c.ret(
            c.call(g1mPrefix + "_eqMixed", sp, s2p)
          )
        );
        const fInGroup = module3.addFunction(g1mPrefix + "_inGroup");
        fInGroup.addParam("pIn", "i32");
        fInGroup.setReturnType("i32");
        const c2 = fInGroup.getCodeBuilder();
        const aux2 = c2.i32_const(module3.alloc(f1size * 2));
        fInGroup.addCode(
          c2.call(g1mPrefix + "_toAffine", c2.getLocal("pIn"), aux2),
          c2.ret(
            c2.call(g1mPrefix + "_inGroupAffine", aux2)
          )
        );
      }
      for (let i = 0; i < 10; i++) {
        buildFrobeniusMap(i);
        module3.exportFunction(ftmPrefix + "_frobeniusMap" + i);
      }
      buildInGroupG1();
      buildInGroupG2();
      buildPrepAddStep();
      buildPrepDoubleStep();
      buildPrepareG1();
      buildPrepareG2();
      buildMillerLoop();
      buildFinalExponentiationOld();
      buildFinalExponentiation();
      for (let i = 1; i <= 5; i++) {
        buildPairingEquation(i);
        module3.exportFunction(prefix + "_pairingEq" + i);
      }
      buildPairing4();
      module3.exportFunction(prefix + "_pairing");
      module3.exportFunction(prefix + "_prepareG1");
      module3.exportFunction(prefix + "_prepareG2");
      module3.exportFunction(prefix + "_millerLoop");
      module3.exportFunction(prefix + "_finalExponentiation");
      module3.exportFunction(prefix + "_finalExponentiationOld");
      module3.exportFunction(prefix + "__cyclotomicSquare");
      module3.exportFunction(prefix + "__cyclotomicExp_w0");
      module3.exportFunction(f6mPrefix + "_mul1");
      module3.exportFunction(f6mPrefix + "_mul01");
      module3.exportFunction(ftmPrefix + "_mul014");
      module3.exportFunction(g1mPrefix + "_inGroupAffine");
      module3.exportFunction(g1mPrefix + "_inGroup");
      module3.exportFunction(g2mPrefix + "_inGroupAffine");
      module3.exportFunction(g2mPrefix + "_inGroup");
    };
  }
});

// ../../node_modules/wasmcurves/index.js
var require_wasmcurves3 = __commonJS({
  "../../node_modules/wasmcurves/index.js"(exports, module2) {
    "use strict";
    module2.exports.buildBn128 = require_build_bn1283();
    module2.exports.buildBls12381 = require_build_bls123813();
    module2.exports.buildF1m = require_build_f1m3();
  }
});

// ../../node_modules/ejs/lib/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/ejs/lib/utils.js"(exports) {
    "use strict";
    var regExpChars = /[|\\{}()[\]^$+*?.]/g;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var hasOwn = function(obj, key) {
      return hasOwnProperty2.apply(obj, [key]);
    };
    exports.escapeRegExpChars = function(string2) {
      if (!string2) {
        return "";
      }
      return String(string2).replace(regExpChars, "\\$&");
    };
    var _ENCODE_HTML_RULES = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&#34;",
      "'": "&#39;"
    };
    var _MATCH_HTML = /[&<>'"]/g;
    function encode_char(c) {
      return _ENCODE_HTML_RULES[c] || c;
    }
    var escapeFuncStr = `var _ENCODE_HTML_RULES = {
      "&": "&amp;"
    , "<": "&lt;"
    , ">": "&gt;"
    , '"': "&#34;"
    , "'": "&#39;"
    }
  , _MATCH_HTML = /[&<>'"]/g;
function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
};
`;
    exports.escapeXML = function(markup) {
      return markup == void 0 ? "" : String(markup).replace(_MATCH_HTML, encode_char);
    };
    function escapeXMLToString() {
      return Function.prototype.toString.call(this) + ";\n" + escapeFuncStr;
    }
    try {
      if (typeof Object.defineProperty === "function") {
        Object.defineProperty(exports.escapeXML, "toString", { value: escapeXMLToString });
      } else {
        exports.escapeXML.toString = escapeXMLToString;
      }
    } catch (err) {
      console.warn("Unable to set escapeXML.toString (is the Function prototype frozen?)");
    }
    exports.shallowCopy = function(to, from) {
      from = from || {};
      if (to !== null && to !== void 0) {
        for (var p in from) {
          if (!hasOwn(from, p)) {
            continue;
          }
          if (p === "__proto__" || p === "constructor") {
            continue;
          }
          to[p] = from[p];
        }
      }
      return to;
    };
    exports.shallowCopyFromList = function(to, from, list) {
      list = list || [];
      from = from || {};
      if (to !== null && to !== void 0) {
        for (var i = 0; i < list.length; i++) {
          var p = list[i];
          if (typeof from[p] != "undefined") {
            if (!hasOwn(from, p)) {
              continue;
            }
            if (p === "__proto__" || p === "constructor") {
              continue;
            }
            to[p] = from[p];
          }
        }
      }
      return to;
    };
    exports.cache = {
      _data: {},
      set: function(key, val) {
        this._data[key] = val;
      },
      get: function(key) {
        return this._data[key];
      },
      remove: function(key) {
        delete this._data[key];
      },
      reset: function() {
        this._data = {};
      }
    };
    exports.hyphenToCamel = function(str) {
      return str.replace(/-[a-z]/g, function(match) {
        return match[1].toUpperCase();
      });
    };
    exports.createNullProtoObjWherePossible = function() {
      if (typeof Object.create == "function") {
        return function() {
          return /* @__PURE__ */ Object.create(null);
        };
      }
      if (!({ __proto__: null } instanceof Object)) {
        return function() {
          return { __proto__: null };
        };
      }
      return function() {
        return {};
      };
    }();
  }
});

// ../../node_modules/ejs/package.json
var require_package = __commonJS({
  "../../node_modules/ejs/package.json"(exports, module2) {
    module2.exports = {
      name: "ejs",
      description: "Embedded JavaScript templates",
      keywords: [
        "template",
        "engine",
        "ejs"
      ],
      version: "3.1.9",
      author: "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)",
      license: "Apache-2.0",
      bin: {
        ejs: "./bin/cli.js"
      },
      main: "./lib/ejs.js",
      jsdelivr: "ejs.min.js",
      unpkg: "ejs.min.js",
      repository: {
        type: "git",
        url: "git://github.com/mde/ejs.git"
      },
      bugs: "https://github.com/mde/ejs/issues",
      homepage: "https://github.com/mde/ejs",
      dependencies: {
        jake: "^10.8.5"
      },
      devDependencies: {
        browserify: "^16.5.1",
        eslint: "^6.8.0",
        "git-directory-deploy": "^1.5.1",
        jsdoc: "^4.0.2",
        "lru-cache": "^4.0.1",
        mocha: "^10.2.0",
        "uglify-js": "^3.3.16"
      },
      engines: {
        node: ">=0.10.0"
      },
      scripts: {
        test: "mocha -u tdd"
      }
    };
  }
});

// ../../node_modules/ejs/lib/ejs.js
var require_ejs = __commonJS({
  "../../node_modules/ejs/lib/ejs.js"(exports) {
    "use strict";
    var fs2 = require("fs");
    var path = require("path");
    var utils2 = require_utils4();
    var scopeOptionWarned = false;
    var _VERSION_STRING = require_package().version;
    var _DEFAULT_OPEN_DELIMITER = "<";
    var _DEFAULT_CLOSE_DELIMITER = ">";
    var _DEFAULT_DELIMITER = "%";
    var _DEFAULT_LOCALS_NAME = "locals";
    var _NAME = "ejs";
    var _REGEX_STRING = "(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)";
    var _OPTS_PASSABLE_WITH_DATA = [
      "delimiter",
      "scope",
      "context",
      "debug",
      "compileDebug",
      "client",
      "_with",
      "rmWhitespace",
      "strict",
      "filename",
      "async"
    ];
    var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat("cache");
    var _BOM = /^\uFEFF/;
    var _JS_IDENTIFIER = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
    exports.cache = utils2.cache;
    exports.fileLoader = fs2.readFileSync;
    exports.localsName = _DEFAULT_LOCALS_NAME;
    exports.promiseImpl = new Function("return this;")().Promise;
    exports.resolveInclude = function(name, filename, isDir) {
      var dirname = path.dirname;
      var extname = path.extname;
      var resolve = path.resolve;
      var includePath = resolve(isDir ? filename : dirname(filename), name);
      var ext = extname(name);
      if (!ext) {
        includePath += ".ejs";
      }
      return includePath;
    };
    function resolvePaths(name, paths) {
      var filePath;
      if (paths.some(function(v) {
        filePath = exports.resolveInclude(name, v, true);
        return fs2.existsSync(filePath);
      })) {
        return filePath;
      }
    }
    function getIncludePath(path2, options) {
      var includePath;
      var filePath;
      var views = options.views;
      var match = /^[A-Za-z]+:\\|^\//.exec(path2);
      if (match && match.length) {
        path2 = path2.replace(/^\/*/, "");
        if (Array.isArray(options.root)) {
          includePath = resolvePaths(path2, options.root);
        } else {
          includePath = exports.resolveInclude(path2, options.root || "/", true);
        }
      } else {
        if (options.filename) {
          filePath = exports.resolveInclude(path2, options.filename);
          if (fs2.existsSync(filePath)) {
            includePath = filePath;
          }
        }
        if (!includePath && Array.isArray(views)) {
          includePath = resolvePaths(path2, views);
        }
        if (!includePath && typeof options.includer !== "function") {
          throw new Error('Could not find the include file "' + options.escapeFunction(path2) + '"');
        }
      }
      return includePath;
    }
    function handleCache(options, template) {
      var func;
      var filename = options.filename;
      var hasTemplate = arguments.length > 1;
      if (options.cache) {
        if (!filename) {
          throw new Error("cache option requires a filename");
        }
        func = exports.cache.get(filename);
        if (func) {
          return func;
        }
        if (!hasTemplate) {
          template = fileLoader(filename).toString().replace(_BOM, "");
        }
      } else if (!hasTemplate) {
        if (!filename) {
          throw new Error("Internal EJS error: no file name or template provided");
        }
        template = fileLoader(filename).toString().replace(_BOM, "");
      }
      func = exports.compile(template, options);
      if (options.cache) {
        exports.cache.set(filename, func);
      }
      return func;
    }
    function tryHandleCache(options, data, cb) {
      var result;
      if (!cb) {
        if (typeof exports.promiseImpl == "function") {
          return new exports.promiseImpl(function(resolve, reject) {
            try {
              result = handleCache(options)(data);
              resolve(result);
            } catch (err) {
              reject(err);
            }
          });
        } else {
          throw new Error("Please provide a callback function");
        }
      } else {
        try {
          result = handleCache(options)(data);
        } catch (err) {
          return cb(err);
        }
        cb(null, result);
      }
    }
    function fileLoader(filePath) {
      return exports.fileLoader(filePath);
    }
    function includeFile(path2, options) {
      var opts = utils2.shallowCopy(utils2.createNullProtoObjWherePossible(), options);
      opts.filename = getIncludePath(path2, opts);
      if (typeof options.includer === "function") {
        var includerResult = options.includer(path2, opts.filename);
        if (includerResult) {
          if (includerResult.filename) {
            opts.filename = includerResult.filename;
          }
          if (includerResult.template) {
            return handleCache(opts, includerResult.template);
          }
        }
      }
      return handleCache(opts);
    }
    function rethrow(err, str, flnm, lineno, esc) {
      var lines = str.split("\n");
      var start = Math.max(lineno - 3, 0);
      var end = Math.min(lines.length, lineno + 3);
      var filename = esc(flnm);
      var context = lines.slice(start, end).map(function(line, i) {
        var curr = i + start + 1;
        return (curr == lineno ? " >> " : "    ") + curr + "| " + line;
      }).join("\n");
      err.path = filename;
      err.message = (filename || "ejs") + ":" + lineno + "\n" + context + "\n\n" + err.message;
      throw err;
    }
    function stripSemi(str) {
      return str.replace(/;(\s*$)/, "$1");
    }
    exports.compile = function compile(template, opts) {
      var templ;
      if (opts && opts.scope) {
        if (!scopeOptionWarned) {
          console.warn("`scope` option is deprecated and will be removed in EJS 3");
          scopeOptionWarned = true;
        }
        if (!opts.context) {
          opts.context = opts.scope;
        }
        delete opts.scope;
      }
      templ = new Template(template, opts);
      return templ.compile();
    };
    exports.render = function(template, d, o) {
      var data = d || utils2.createNullProtoObjWherePossible();
      var opts = o || utils2.createNullProtoObjWherePossible();
      if (arguments.length == 2) {
        utils2.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);
      }
      return handleCache(opts, template)(data);
    };
    exports.renderFile = function() {
      var args = Array.prototype.slice.call(arguments);
      var filename = args.shift();
      var cb;
      var opts = { filename };
      var data;
      var viewOpts;
      if (typeof arguments[arguments.length - 1] == "function") {
        cb = args.pop();
      }
      if (args.length) {
        data = args.shift();
        if (args.length) {
          utils2.shallowCopy(opts, args.pop());
        } else {
          if (data.settings) {
            if (data.settings.views) {
              opts.views = data.settings.views;
            }
            if (data.settings["view cache"]) {
              opts.cache = true;
            }
            viewOpts = data.settings["view options"];
            if (viewOpts) {
              utils2.shallowCopy(opts, viewOpts);
            }
          }
          utils2.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
        }
        opts.filename = filename;
      } else {
        data = utils2.createNullProtoObjWherePossible();
      }
      return tryHandleCache(opts, data, cb);
    };
    exports.Template = Template;
    exports.clearCache = function() {
      exports.cache.reset();
    };
    function Template(text2, opts) {
      opts = opts || utils2.createNullProtoObjWherePossible();
      var options = utils2.createNullProtoObjWherePossible();
      this.templateText = text2;
      this.mode = null;
      this.truncate = false;
      this.currentLine = 1;
      this.source = "";
      options.client = opts.client || false;
      options.escapeFunction = opts.escape || opts.escapeFunction || utils2.escapeXML;
      options.compileDebug = opts.compileDebug !== false;
      options.debug = !!opts.debug;
      options.filename = opts.filename;
      options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;
      options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
      options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;
      options.strict = opts.strict || false;
      options.context = opts.context;
      options.cache = opts.cache || false;
      options.rmWhitespace = opts.rmWhitespace;
      options.root = opts.root;
      options.includer = opts.includer;
      options.outputFunctionName = opts.outputFunctionName;
      options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;
      options.views = opts.views;
      options.async = opts.async;
      options.destructuredLocals = opts.destructuredLocals;
      options.legacyInclude = typeof opts.legacyInclude != "undefined" ? !!opts.legacyInclude : true;
      if (options.strict) {
        options._with = false;
      } else {
        options._with = typeof opts._with != "undefined" ? opts._with : true;
      }
      this.opts = options;
      this.regex = this.createRegex();
    }
    Template.modes = {
      EVAL: "eval",
      ESCAPED: "escaped",
      RAW: "raw",
      COMMENT: "comment",
      LITERAL: "literal"
    };
    Template.prototype = {
      createRegex: function() {
        var str = _REGEX_STRING;
        var delim = utils2.escapeRegExpChars(this.opts.delimiter);
        var open2 = utils2.escapeRegExpChars(this.opts.openDelimiter);
        var close = utils2.escapeRegExpChars(this.opts.closeDelimiter);
        str = str.replace(/%/g, delim).replace(/</g, open2).replace(/>/g, close);
        return new RegExp(str);
      },
      compile: function() {
        var src;
        var fn;
        var opts = this.opts;
        var prepended = "";
        var appended = "";
        var escapeFn = opts.escapeFunction;
        var ctor;
        var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : "undefined";
        if (!this.source) {
          this.generateSource();
          prepended += '  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n';
          if (opts.outputFunctionName) {
            if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) {
              throw new Error("outputFunctionName is not a valid JS identifier.");
            }
            prepended += "  var " + opts.outputFunctionName + " = __append;\n";
          }
          if (opts.localsName && !_JS_IDENTIFIER.test(opts.localsName)) {
            throw new Error("localsName is not a valid JS identifier.");
          }
          if (opts.destructuredLocals && opts.destructuredLocals.length) {
            var destructuring = "  var __locals = (" + opts.localsName + " || {}),\n";
            for (var i = 0; i < opts.destructuredLocals.length; i++) {
              var name = opts.destructuredLocals[i];
              if (!_JS_IDENTIFIER.test(name)) {
                throw new Error("destructuredLocals[" + i + "] is not a valid JS identifier.");
              }
              if (i > 0) {
                destructuring += ",\n  ";
              }
              destructuring += name + " = __locals." + name;
            }
            prepended += destructuring + ";\n";
          }
          if (opts._with !== false) {
            prepended += "  with (" + opts.localsName + " || {}) {\n";
            appended += "  }\n";
          }
          appended += "  return __output;\n";
          this.source = prepended + this.source + appended;
        }
        if (opts.compileDebug) {
          src = "var __line = 1\n  , __lines = " + JSON.stringify(this.templateText) + "\n  , __filename = " + sanitizedFilename + ";\ntry {\n" + this.source + "} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n";
        } else {
          src = this.source;
        }
        if (opts.client) {
          src = "escapeFn = escapeFn || " + escapeFn.toString() + ";\n" + src;
          if (opts.compileDebug) {
            src = "rethrow = rethrow || " + rethrow.toString() + ";\n" + src;
          }
        }
        if (opts.strict) {
          src = '"use strict";\n' + src;
        }
        if (opts.debug) {
          console.log(src);
        }
        if (opts.compileDebug && opts.filename) {
          src = src + "\n//# sourceURL=" + sanitizedFilename + "\n";
        }
        try {
          if (opts.async) {
            try {
              ctor = new Function("return (async function(){}).constructor;")();
            } catch (e4) {
              if (e4 instanceof SyntaxError) {
                throw new Error("This environment does not support async/await");
              } else {
                throw e4;
              }
            }
          } else {
            ctor = Function;
          }
          fn = new ctor(opts.localsName + ", escapeFn, include, rethrow", src);
        } catch (e4) {
          if (e4 instanceof SyntaxError) {
            if (opts.filename) {
              e4.message += " in " + opts.filename;
            }
            e4.message += " while compiling ejs\n\n";
            e4.message += "If the above error is not helpful, you may want to try EJS-Lint:\n";
            e4.message += "https://github.com/RyanZim/EJS-Lint";
            if (!opts.async) {
              e4.message += "\n";
              e4.message += "Or, if you meant to create an async function, pass `async: true` as an option.";
            }
          }
          throw e4;
        }
        var returnedFn = opts.client ? fn : function anonymous(data) {
          var include = function(path2, includeData) {
            var d = utils2.shallowCopy(utils2.createNullProtoObjWherePossible(), data);
            if (includeData) {
              d = utils2.shallowCopy(d, includeData);
            }
            return includeFile(path2, opts)(d);
          };
          return fn.apply(
            opts.context,
            [data || utils2.createNullProtoObjWherePossible(), escapeFn, include, rethrow]
          );
        };
        if (opts.filename && typeof Object.defineProperty === "function") {
          var filename = opts.filename;
          var basename = path.basename(filename, path.extname(filename));
          try {
            Object.defineProperty(returnedFn, "name", {
              value: basename,
              writable: false,
              enumerable: false,
              configurable: true
            });
          } catch (e4) {
          }
        }
        return returnedFn;
      },
      generateSource: function() {
        var opts = this.opts;
        if (opts.rmWhitespace) {
          this.templateText = this.templateText.replace(/[\r\n]+/g, "\n").replace(/^\s+|\s+$/gm, "");
        }
        this.templateText = this.templateText.replace(/[ \t]*<%_/gm, "<%_").replace(/_%>[ \t]*/gm, "_%>");
        var self2 = this;
        var matches = this.parseTemplateText();
        var d = this.opts.delimiter;
        var o = this.opts.openDelimiter;
        var c = this.opts.closeDelimiter;
        if (matches && matches.length) {
          matches.forEach(function(line, index) {
            var closing;
            if (line.indexOf(o + d) === 0 && line.indexOf(o + d + d) !== 0) {
              closing = matches[index + 2];
              if (!(closing == d + c || closing == "-" + d + c || closing == "_" + d + c)) {
                throw new Error('Could not find matching close tag for "' + line + '".');
              }
            }
            self2.scanLine(line);
          });
        }
      },
      parseTemplateText: function() {
        var str = this.templateText;
        var pat = this.regex;
        var result = pat.exec(str);
        var arr = [];
        var firstPos;
        while (result) {
          firstPos = result.index;
          if (firstPos !== 0) {
            arr.push(str.substring(0, firstPos));
            str = str.slice(firstPos);
          }
          arr.push(result[0]);
          str = str.slice(result[0].length);
          result = pat.exec(str);
        }
        if (str) {
          arr.push(str);
        }
        return arr;
      },
      _addOutput: function(line) {
        if (this.truncate) {
          line = line.replace(/^(?:\r\n|\r|\n)/, "");
          this.truncate = false;
        }
        if (!line) {
          return line;
        }
        line = line.replace(/\\/g, "\\\\");
        line = line.replace(/\n/g, "\\n");
        line = line.replace(/\r/g, "\\r");
        line = line.replace(/"/g, '\\"');
        this.source += '    ; __append("' + line + '")\n';
      },
      scanLine: function(line) {
        var self2 = this;
        var d = this.opts.delimiter;
        var o = this.opts.openDelimiter;
        var c = this.opts.closeDelimiter;
        var newLineCount = 0;
        newLineCount = line.split("\n").length - 1;
        switch (line) {
          case o + d:
          case o + d + "_":
            this.mode = Template.modes.EVAL;
            break;
          case o + d + "=":
            this.mode = Template.modes.ESCAPED;
            break;
          case o + d + "-":
            this.mode = Template.modes.RAW;
            break;
          case o + d + "#":
            this.mode = Template.modes.COMMENT;
            break;
          case o + d + d:
            this.mode = Template.modes.LITERAL;
            this.source += '    ; __append("' + line.replace(o + d + d, o + d) + '")\n';
            break;
          case d + d + c:
            this.mode = Template.modes.LITERAL;
            this.source += '    ; __append("' + line.replace(d + d + c, d + c) + '")\n';
            break;
          case d + c:
          case "-" + d + c:
          case "_" + d + c:
            if (this.mode == Template.modes.LITERAL) {
              this._addOutput(line);
            }
            this.mode = null;
            this.truncate = line.indexOf("-") === 0 || line.indexOf("_") === 0;
            break;
          default:
            if (this.mode) {
              switch (this.mode) {
                case Template.modes.EVAL:
                case Template.modes.ESCAPED:
                case Template.modes.RAW:
                  if (line.lastIndexOf("//") > line.lastIndexOf("\n")) {
                    line += "\n";
                  }
              }
              switch (this.mode) {
                case Template.modes.EVAL:
                  this.source += "    ; " + line + "\n";
                  break;
                case Template.modes.ESCAPED:
                  this.source += "    ; __append(escapeFn(" + stripSemi(line) + "))\n";
                  break;
                case Template.modes.RAW:
                  this.source += "    ; __append(" + stripSemi(line) + ")\n";
                  break;
                case Template.modes.COMMENT:
                  break;
                case Template.modes.LITERAL:
                  this._addOutput(line);
                  break;
              }
            } else {
              this._addOutput(line);
            }
        }
        if (self2.opts.compileDebug && newLineCount) {
          this.currentLine += newLineCount;
          this.source += "    ; __line = " + this.currentLine + "\n";
        }
      }
    };
    exports.escapeXML = utils2.escapeXML;
    exports.__express = exports.renderFile;
    exports.VERSION = _VERSION_STRING;
    exports.name = _NAME;
    if (typeof window != "undefined") {
      window.ejs = exports;
    }
  }
});

// ../../node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "../../node_modules/js-sha3/src/sha3.js"(exports, module2) {
    "use strict";
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits5, padding, outputType) {
        return function(message) {
          return new Keccak(bits5, padding, bits5).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits5, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits5, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits5, padding, outputType) {
        return function(message, outputBits, n, s) {
          return methods["cshake" + bits5].update(message, outputBits, n, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits5, padding, outputType) {
        return function(key, message, outputBits, s) {
          return methods["kmac" + bits5].update(key, message, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits5, padding) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits5, padding, type);
        }
        return method;
      };
      var createMethod = function(bits5, padding) {
        var method = createOutputMethod(bits5, padding, "hex");
        method.create = function() {
          return new Keccak(bits5, padding, bits5);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits5, padding);
      };
      var createShakeMethod = function(bits5, padding) {
        var method = createShakeOutputMethod(bits5, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits5, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits5, padding);
      };
      var createCshakeMethod = function(bits5, padding) {
        var w = CSHAKE_BYTEPAD[bits5];
        var method = createCshakeOutputMethod(bits5, padding, "hex");
        method.create = function(outputBits, n, s) {
          if (!n && !s) {
            return methods["shake" + bits5].create(outputBits);
          } else {
            return new Keccak(bits5, padding, outputBits).bytepad([n, s], w);
          }
        };
        method.update = function(message, outputBits, n, s) {
          return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits5, padding);
      };
      var createKmacMethod = function(bits5, padding) {
        var w = CSHAKE_BYTEPAD[bits5];
        var method = createKmacOutputMethod(bits5, padding, "hex");
        method.create = function(key, outputBits, s) {
          return new Kmac(bits5, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
        };
        method.update = function(key, message, outputBits, s) {
          return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits5, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits4 = algorithm.bits;
        for (var j = 0; j < bits4.length; ++j) {
          var methodName = algorithm.name + "_" + bits4[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits4[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits4[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits5, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits5 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f(s);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits5, padding, outputBits) {
        Keccak.call(this, bits5, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS) {
        module2.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// ../../node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "../../node_modules/bignumber.js/bignumber.js"(exports, module2) {
    "use strict";
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div4, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e4, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2))
            return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e4 = 0, i = v; i >= 10; i /= 10, e4++)
                  ;
                if (e4 > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e4;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e4 = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e4 < 0)
                e4 = i;
              e4 += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e4 < 0) {
              e4 = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET2.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET2.slice(0, b);
            e4 = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e4) {
                    e4 = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e4 = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e4 = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e4 = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e4 = e4 - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e4 < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e4;
              x.c = [];
              i = (e4 + 1) % LOG_BASE;
              if (e4 < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET2 = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET: ALPHABET2
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber2.DEBUG)
            return true;
          var i, n, c = v.c, e4 = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e4 >= -MAX && e4 <= MAX && e4 === mathfloor(e4)) {
                if (c[0] === 0) {
                  if (e4 === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e4 + 1) % LOG_BASE;
                if (i < 1)
                  i += LOG_BASE;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e4 === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e4, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e4 = 0];
            } else {
              for (e4 = -1; c[0] === 0; c.splice(0, 1), e4 -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e4 -= LOG_BASE - i;
            }
            rand.e = e4;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; )
            sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e4, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET2, decimal) : (alphabet = decimal, ALPHABET2));
            e4 = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e4;
            } else {
              x.c = xc;
              x.e = e4;
              x.s = sign;
              x = div4(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e4 = x.e;
            }
            d = e4 + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e4;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint(str, e4, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div4 = function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e4, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e4 = x.e - y.e;
            s = dp + e4 + 1;
            if (!base) {
              base = BASE;
              e4 = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e4--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e4 * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e4;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e4, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e4 = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e4 || e4 <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e4);
            } else {
              i -= ne;
              str = toFixedPoint(str, e4, "0");
              if (e4 + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e4 - len;
                if (i > 0) {
                  if (e4 + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method) {
          var n, i = 1, m = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            n = new BigNumber2(args[i]);
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function normalise(n, c, e4) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e4 = i + e4 * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e4 < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e4;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e4 = n.e;
          if (e4 === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e4 <= TO_EXP_NEG || e4 >= TO_EXP_POS ? toExponential(str, e4) : toFixedPoint(str, e4, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div4(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div4(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd4(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd4(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd4(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd4(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div4(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div4(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e4, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e4 = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e4;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e4);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e4 = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e4) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e4 = bitFloor((e4 + 1) / 2) - (e4 < 0 || e4 % 2);
            if (s == 1 / 0) {
              n = "5e" + e4;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e4;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e4 = r.e;
            s = e4 + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div4(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e4)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md2) {
          var d, d0, d1, d2, e4, exp7, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md2 != null) {
            n = new BigNumber2(md2);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e4 = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp7 = e4 % LOG_BASE) < 0 ? LOG_BASE + exp7 : exp7];
          md2 = !md2 || n.comparedTo(d) > 0 ? e4 > 0 ? d : n1 : n;
          exp7 = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div4(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md2) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div4(md2.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e4 = e4 * 2;
          r = div4(n1, d1, e4, ROUNDING_MODE).minus(x).abs().comparedTo(
            div4(n0, d0, e4, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp7;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e4 = n.e;
          if (e4 === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e4 <= TO_EXP_NEG || e4 >= TO_EXP_POS ? toExponential(coeffToString(n.c), e4) : toFixedPoint(coeffToString(n.c), e4, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e4 + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET2.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e4, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd4(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e4) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e4 < 0 ? "e" : "e+") + e4;
      }
      function toFixedPoint(str, e4, z) {
        var len, zs;
        if (e4 < 0) {
          for (zs = z + "."; ++e4; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e4 > len) {
            for (zs = z, e4 -= len; --e4; zs += z)
              ;
            str += zs;
          } else if (e4 < len) {
            str = str.slice(0, e4) + "." + str.slice(e4);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// ../../node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/json-bigint/lib/stringify.js"(exports, module2) {
    "use strict";
    var BigNumber = require_bignumber();
    var JSON2 = module2.exports;
    (function() {
      "use strict";
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string2) {
        escapable.lastIndex = 0;
        return escapable.test(string2) ? '"' + string2.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string2 + '"';
      }
      function str(key, holder) {
        var i, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i = 0; i < length; i += 1) {
                partial[i] = str(i, value) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                if (typeof rep[i] === "string") {
                  k = rep[i];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k2) {
                var v2 = str(k2, value);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              });
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// ../../node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/json-bigint/lib/parse.js"(exports, module2) {
    "use strict";
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text2, error = function(m) {
        throw {
          name: "SyntaxError",
          message: m,
          at,
          text: text2
        };
      }, next = function(c) {
        if (c && c !== ch) {
          error("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text2.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string3 = "";
        if (ch === "-") {
          string3 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string3 += ch;
          next();
        }
        if (ch === ".") {
          string3 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string3 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string3 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string3 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string3 += ch;
            next();
          }
        }
        number2 = +string3;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null)
            BigNumber = require_bignumber();
          if (string3.length > 15)
            return _options.storeAsString ? string3 : _options.useNativeBigInt ? BigInt(string3) : new BigNumber(string3);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string2 = function() {
        var hex, i, string3 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt)
                string3 += text2.substring(startAt, at - 1);
              next();
              return string3;
            }
            if (ch === "\\") {
              if (at - 1 > startAt)
                string3 += text2.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string3 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string3 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string2();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string2();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text2 = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k, v, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k2) {
              v = walk(value2, k2);
              if (v !== void 0) {
                value2[k2] = v;
              } else {
                delete value2[k2];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module2.exports = json_parse;
  }
});

// ../../node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "../../node_modules/json-bigint/index.js"(exports, module2) {
    "use strict";
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module2.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module2.exports.parse = json_parse();
    module2.exports.stringify = json_stringify;
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/trees.js"(exports, module2) {
    "use strict";
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero4(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
    );
    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero4(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero4(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero4(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero4(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero4(base_length);
    var base_dist = new Array(D_CODES);
    zero4(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    var put_short = (s, w) => {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    var send_bits = (s, value, length) => {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    };
    var send_code = (s, c, tree) => {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    };
    var bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush = (s) => {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    var gen_bitlen = (s, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m;
      let bits4;
      let xbits;
      let f;
      let overflow = 0;
      for (bits4 = 0; bits4 <= MAX_BITS; bits4++) {
        s.bl_count[bits4] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits4 = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits4 > max_length) {
          bits4 = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits4;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits4]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits4 + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits4 = max_length - 1;
        while (s.bl_count[bits4] === 0) {
          bits4--;
        }
        s.bl_count[bits4]--;
        s.bl_count[bits4 + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits4 = max_length; bits4 !== 0; bits4--) {
        n = s.bl_count[bits4];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits4) {
            s.opt_len += (bits4 - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits4;
          }
          n--;
        }
      }
    };
    var gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS + 1);
      let code = 0;
      let bits4;
      let n;
      for (bits4 = 1; bits4 <= MAX_BITS; bits4++) {
        code = code + bl_count[bits4 - 1] << 1;
        next_code[bits4] = code;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    var tr_static_init = () => {
      let n;
      let bits4;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits4 = 0; bits4 <= MAX_BITS; bits4++) {
        bl_count[bits4] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    };
    var init_block = (s) => {
      let n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.sym_next = s.matches = 0;
    };
    var bi_windup = (s) => {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    var smaller = (tree, n, m, depth) => {
      const _n2 = n * 2;
      const _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    var pqdownheap = (s, tree, k) => {
      const v = s.heap[k];
      let j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    };
    var compress_block = (s, ltree, dtree) => {
      let dist;
      let lc;
      let sx = 0;
      let code;
      let extra;
      if (s.sym_next !== 0) {
        do {
          dist = s.pending_buf[s.sym_buf + sx++] & 255;
          dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
          lc = s.pending_buf[s.sym_buf + sx++];
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (sx < s.sym_next);
      }
      send_code(s, END_BLOCK, ltree);
    };
    var build_tree = (s, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    };
    var scan_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree = (s) => {
      let max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees = (s, lcodes, dcodes, blcodes) => {
      let rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    var detect_data_type = (s) => {
      let block_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, block_mask >>>= 1) {
        if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    var static_init_done = false;
    var _tr_init = (s) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    };
    var _tr_stored_block = (s, buf, stored_len, last) => {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      bi_windup(s);
      put_short(s, stored_len);
      put_short(s, ~stored_len);
      if (stored_len) {
        s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
      }
      s.pending += stored_len;
    };
    var _tr_align = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    var _tr_flush_block = (s, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    };
    var _tr_tally = (s, dist, lc) => {
      s.pending_buf[s.sym_buf + s.sym_next++] = dist;
      s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
      s.pending_buf[s.sym_buf + s.sym_next++] = lc;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.sym_next === s.sym_end;
    };
    module2.exports._tr_init = _tr_init;
    module2.exports._tr_stored_block = _tr_stored_block;
    module2.exports._tr_flush_block = _tr_flush_block;
    module2.exports._tr_tally = _tr_tally;
    module2.exports._tr_align = _tr_align;
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/adler32.js"(exports, module2) {
    "use strict";
    var adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    module2.exports = adler32;
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/crc32.js"(exports, module2) {
    "use strict";
    var makeTable = () => {
      let c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    };
    var crcTable = new Uint32Array(makeTable());
    var crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    };
    module2.exports = crc32;
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/messages.js"(exports, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/deflate.js"(exports, module2) {
    "use strict";
    var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var {
      Z_NO_FLUSH,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_BLOCK,
      Z_OK,
      Z_STREAM_END,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_BUF_ERROR,
      Z_DEFAULT_COMPRESSION,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY,
      Z_UNKNOWN,
      Z_DEFLATED
    } = require_constants();
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var GZIP_STATE = 57;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    var err = (strm, errorCode) => {
      strm.msg = msg[errorCode];
      return errorCode;
    };
    var rank = (f) => {
      return f * 2 - (f > 4 ? 9 : 0);
    };
    var zero4 = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var slide_hash = (s) => {
      let n, m;
      let p;
      let wsize = s.w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
      n = wsize;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
    };
    var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending = (strm) => {
      const s = strm.state;
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    var flush_block_only = (s, last) => {
      _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    var put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };
    var putShortMSB = (s, b) => {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    };
    var read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match = (s, cur_match) => {
      let chain_length = s.max_chain_length;
      let scan = s.strstart;
      let match;
      let len;
      let best_len = s.prev_length;
      let nice_match = s.nice_match;
      const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s.window;
      const wmask = s.w_mask;
      const prev = s.prev;
      const strend = s.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    var fill_window = (s) => {
      const _w_size = s.w_size;
      let n, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
          slide_hash(s);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
          while (s.insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    var deflate_stored = (s, flush) => {
      let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
      let len, left, have, last = 0;
      let used = s.strm.avail_in;
      do {
        len = 65535;
        have = s.bi_valid + 42 >> 3;
        if (s.strm.avail_out < have) {
          break;
        }
        have = s.strm.avail_out - have;
        left = s.strstart - s.block_start;
        if (len > left + s.strm.avail_in) {
          len = left + s.strm.avail_in;
        }
        if (len > have) {
          len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s.strm.avail_in)) {
          break;
        }
        last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;
        _tr_stored_block(s, 0, 0, last);
        s.pending_buf[s.pending - 4] = len;
        s.pending_buf[s.pending - 3] = len >> 8;
        s.pending_buf[s.pending - 2] = ~len;
        s.pending_buf[s.pending - 1] = ~len >> 8;
        flush_pending(s.strm);
        if (left) {
          if (left > len) {
            left = len;
          }
          s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
          s.strm.next_out += left;
          s.strm.avail_out -= left;
          s.strm.total_out += left;
          s.block_start += left;
          len -= left;
        }
        if (len) {
          read_buf(s.strm, s.strm.output, s.strm.next_out, len);
          s.strm.next_out += len;
          s.strm.avail_out -= len;
          s.strm.total_out += len;
        }
      } while (last === 0);
      used -= s.strm.avail_in;
      if (used) {
        if (used >= s.w_size) {
          s.matches = 2;
          s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
          s.strstart = s.w_size;
          s.insert = s.strstart;
        } else {
          if (s.window_size - s.strstart <= used) {
            s.strstart -= s.w_size;
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
              s.matches++;
            }
            if (s.insert > s.strstart) {
              s.insert = s.strstart;
            }
          }
          s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
          s.strstart += used;
          s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
        }
        s.block_start = s.strstart;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      if (last) {
        return BS_FINISH_DONE;
      }
      if (flush !== Z_NO_FLUSH && flush !== Z_FINISH && s.strm.avail_in === 0 && s.strstart === s.block_start) {
        return BS_BLOCK_DONE;
      }
      have = s.window_size - s.strstart;
      if (s.strm.avail_in > have && s.block_start >= s.w_size) {
        s.block_start -= s.w_size;
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        have += s.w_size;
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      if (have > s.strm.avail_in) {
        have = s.strm.avail_in;
      }
      if (have) {
        read_buf(s.strm, s.window, s.strstart, have);
        s.strstart += have;
        s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      have = s.bi_valid + 42 >> 3;
      have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
      min_block = have > s.w_size ? s.w_size : have;
      left = s.strstart - s.block_start;
      if (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && s.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last = flush === Z_FINISH && s.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block(s, s.block_start, len, last);
        s.block_start += len;
        flush_pending(s.strm);
      }
      return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    var deflate_fast = (s, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_slow = (s, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_rle = (s, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_huff = (s, flush) => {
      let bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    var lm_init = (s) => {
      s.window_size = 2 * s.w_size;
      zero4(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero4(this.dyn_ltree);
      zero4(this.dyn_dtree);
      zero4(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      this.heap = new Uint16Array(2 * L_CODES + 1);
      zero4(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES + 1);
      zero4(this.depth);
      this.sym_buf = 0;
      this.lit_bufsize = 0;
      this.sym_next = 0;
      this.sym_end = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s = strm.state;
      if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
      s.status !== GZIP_STATE && //#endif
      s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
        return 1;
      }
      return 0;
    };
    var deflateResetKeep = (strm) => {
      if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = //#ifdef GZIP
      s.wrap === 2 ? GZIP_STATE : (
        //#endif
        s.wrap ? INIT_STATE : BUSY_STATE
      );
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = -2;
      _tr_init(s);
      return Z_OK;
    };
    var deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = (strm, head) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    };
    var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.status = INIT_STATE;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      s.sym_buf = s.lit_bufsize;
      s.sym_end = (s.lit_bufsize - 1) * 3;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    var deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    };
    var deflate = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      const s = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      const old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === INIT_STATE && s.wrap === 0) {
        s.status = BUSY_STATE;
      }
      if (s.status === INIT_STATE) {
        let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (s.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          let beg = s.pending;
          let left = (s.gzhead.extra.length & 65535) - s.gzindex;
          while (s.pending + left > s.pending_buf_size) {
            let copy = s.pending_buf_size - s.pending;
            s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
            s.pending = s.pending_buf_size;
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex += copy;
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
            beg = 0;
            left -= copy;
          }
          let gzhead_extra = new Uint8Array(s.gzhead.extra);
          s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
          s.pending += left;
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = NAME_STATE;
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = COMMENT_STATE;
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
        }
        s.status = HCRC_STATE;
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          } else if (flush !== Z_BLOCK) {
            _tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero4(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    };
    var deflateEnd = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    };
    var deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const s = strm.state;
      const wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero4(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    };
    module2.exports.deflateInit = deflateInit;
    module2.exports.deflateInit2 = deflateInit2;
    module2.exports.deflateReset = deflateReset;
    module2.exports.deflateResetKeep = deflateResetKeep;
    module2.exports.deflateSetHeader = deflateSetHeader;
    module2.exports.deflate = deflate;
    module2.exports.deflateEnd = deflateEnd;
    module2.exports.deflateSetDictionary = deflateSetDictionary;
    module2.exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/utils/common.js"(exports, module2) {
    "use strict";
    var _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    module2.exports.assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    module2.exports.flattenChunks = (chunks) => {
      let len = 0;
      for (let i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      const result = new Uint8Array(len);
      for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/utils/strings.js"(exports, module2) {
    "use strict";
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    module2.exports.string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };
    module2.exports.buf2string = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        let c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    module2.exports.utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/zstream.js"(exports, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/deflate.js"(exports, module2) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils2 = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString6 = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED
    } = require_constants();
    function Deflate(options) {
      this.options = utils2.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
      }, options || {});
      let opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString6.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString6.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = zlib_deflate.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        this.result = utils2.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      const deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    module2.exports.Deflate = Deflate;
    module2.exports.deflate = deflate;
    module2.exports.deflateRaw = deflateRaw;
    module2.exports.gzip = gzip;
    module2.exports.constants = require_constants();
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/inffast.js"(exports, module2) {
    "use strict";
    var BAD = 16209;
    var TYPE = 16191;
    module2.exports = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits4;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits4 = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits4 < 15) {
            hold += input[_in++] << bits4;
            bits4 += 8;
            hold += input[_in++] << bits4;
            bits4 += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits4 -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits4 < op) {
                    hold += input[_in++] << bits4;
                    bits4 += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits4 -= op;
                }
                if (bits4 < 15) {
                  hold += input[_in++] << bits4;
                  bits4 += 8;
                  hold += input[_in++] << bits4;
                  bits4 += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits4 -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits4 < op) {
                        hold += input[_in++] << bits4;
                        bits4 += 8;
                        if (bits4 < op) {
                          hold += input[_in++] << bits4;
                          bits4 += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits4 -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits4 >> 3;
      _in -= len;
      bits4 -= len << 3;
      hold &= (1 << bits4) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits4;
      return;
    };
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/inftrees.js"(exports, module2) {
    "use strict";
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    var lext = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    var dbase = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    var dext = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits4 = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let match;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits4;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        match = 20;
      } else if (type === LENS) {
        base = lbase;
        extra = lext;
        match = 257;
      } else {
        base = dbase;
        extra = dext;
        match = 0;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] + 1 < match) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match) {
          here_op = extra[work[sym] - match];
          here_val = base[work[sym] - match];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    module2.exports = inflate_table;
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/inflate.js"(exports, module2) {
    "use strict";
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var {
      Z_FINISH,
      Z_BLOCK,
      Z_TREES,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = require_constants();
    var HEAD = 16180;
    var FLAGS = 16181;
    var TIME = 16182;
    var OS = 16183;
    var EXLEN = 16184;
    var EXTRA = 16185;
    var NAME = 16186;
    var COMMENT = 16187;
    var HCRC = 16188;
    var DICTID = 16189;
    var DICT = 16190;
    var TYPE = 16191;
    var TYPEDO = 16192;
    var STORED = 16193;
    var COPY_ = 16194;
    var COPY = 16195;
    var TABLE = 16196;
    var LENLENS = 16197;
    var CODELENS = 16198;
    var LEN_ = 16199;
    var LEN = 16200;
    var LENEXT = 16201;
    var DIST = 16202;
    var DISTEXT = 16203;
    var MATCH = 16204;
    var LIT = 16205;
    var CHECK = 16206;
    var LENGTH = 16207;
    var DONE = 16208;
    var BAD = 16209;
    var MEM = 16210;
    var SYNC = 16211;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    var zswap32 = (q) => {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    };
    function InflateState() {
      this.strm = null;
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state = strm.state;
      if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
        return 1;
      }
      return 0;
    };
    var inflateResetKeep = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.flags = -1;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    };
    var inflateReset = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    var inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    var inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      const state = new InflateState();
      strm.state = state;
      state.strm = strm;
      state.window = null;
      state.mode = HEAD;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    var virgin = true;
    var lenfix;
    var distfix;
    var fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    var updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits4;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits4 = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits4 < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits4;
                bits4 += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                if (state.wbits === 0) {
                  state.wbits = 15;
                }
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits4 = 0;
                state.mode = FLAGS;
                break;
              }
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits4 -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              }
              if (len > 15 || len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              state.flags = 0;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits4 = 0;
              break;
            case FLAGS:
              while (bits4 < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits4;
                bits4 += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits4 = 0;
              state.mode = TIME;
            case TIME:
              while (bits4 < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits4;
                bits4 += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits4 = 0;
              state.mode = OS;
            case OS:
              while (bits4 < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits4;
                bits4 += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits4 = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits4 < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits4;
                  bits4 += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits4 = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits4 < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits4;
                  bits4 += 8;
                }
                if (state.wrap & 4 && hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits4 = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits4 < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits4;
                bits4 += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits4 = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits4;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits4 & 7;
                bits4 -= bits4 & 7;
                state.mode = CHECK;
                break;
              }
              while (bits4 < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits4;
                bits4 += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits4 -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits4 -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits4 -= 2;
              break;
            case STORED:
              hold >>>= bits4 & 7;
              bits4 -= bits4 & 7;
              while (bits4 < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits4;
                bits4 += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits4 = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits4 < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits4;
                bits4 += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits4 -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits4 -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits4 -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits4 < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits4;
                  bits4 += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits4 -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits4) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits4;
                  bits4 += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits4 -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits4 < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits4;
                      bits4 += 8;
                    }
                    hold >>>= here_bits;
                    bits4 -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits4 -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits4 < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits4;
                      bits4 += 8;
                    }
                    hold >>>= here_bits;
                    bits4 -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits4 -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits4 < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits4;
                      bits4 += 8;
                    }
                    hold >>>= here_bits;
                    bits4 -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits4 -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits4;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits4 = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits4) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits4;
                bits4 += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits4) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits4;
                  bits4 += 8;
                }
                hold >>>= last_bits;
                bits4 -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits4 -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits4 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits4;
                  bits4 += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits4 -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits4) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits4;
                bits4 += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits4) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits4;
                  bits4 += 8;
                }
                hold >>>= last_bits;
                bits4 -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits4 -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits4 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits4;
                  bits4 += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits4 -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits4 < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits4;
                  bits4 += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits4 = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits4 < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits4;
                  bits4 += 8;
                }
                if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits4 = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits4;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap & 4 && _out) {
        strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    var inflateEnd = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    };
    var inflateGetHeader = (strm, head) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    };
    var inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    };
    module2.exports.inflateReset = inflateReset;
    module2.exports.inflateReset2 = inflateReset2;
    module2.exports.inflateResetKeep = inflateResetKeep;
    module2.exports.inflateInit = inflateInit;
    module2.exports.inflateInit2 = inflateInit2;
    module2.exports.inflate = inflate;
    module2.exports.inflateEnd = inflateEnd;
    module2.exports.inflateGetHeader = inflateGetHeader;
    module2.exports.inflateSetDictionary = inflateSetDictionary;
    module2.exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/zlib/gzheader.js"(exports, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/lib/inflate.js"(exports, module2) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils2 = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString6 = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = require_constants();
    function Inflate(options) {
      this.options = utils2.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
      }, options || {});
      const opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString6.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended)
        return false;
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString6.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = zlib_inflate.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          zlib_inflate.inflateReset(strm);
          status = zlib_inflate.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail)
                strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0)
          continue;
        if (status === Z_STREAM_END) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils2.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      const inflator = new Inflate(options);
      inflator.push(input);
      if (inflator.err)
        throw inflator.msg || msg[inflator.err];
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    module2.exports.Inflate = Inflate;
    module2.exports.inflate = inflate;
    module2.exports.inflateRaw = inflateRaw;
    module2.exports.ungzip = inflate;
    module2.exports.constants = require_constants();
  }
});

// ../../node_modules/@pcd/passport-ui/node_modules/pako/index.js
var require_pako = __commonJS({
  "../../node_modules/@pcd/passport-ui/node_modules/pako/index.js"(exports, module2) {
    "use strict";
    var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
    var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
    var constants = require_constants();
    module2.exports.Deflate = Deflate;
    module2.exports.deflate = deflate;
    module2.exports.deflateRaw = deflateRaw;
    module2.exports.gzip = gzip;
    module2.exports.Inflate = Inflate;
    module2.exports.inflate = inflate;
    module2.exports.inflateRaw = inflateRaw;
    module2.exports.ungzip = ungzip;
    module2.exports.constants = constants;
  }
});

// ../../node_modules/qr-image/lib/encode.js
var require_encode = __commonJS({
  "../../node_modules/qr-image/lib/encode.js"(exports, module2) {
    "use strict";
    function pushBits(arr, n, value) {
      for (var bit = 1 << n - 1; bit; bit = bit >>> 1) {
        arr.push(bit & value ? 1 : 0);
      }
    }
    function encode_8bit(data) {
      var len = data.length;
      var bits4 = [];
      for (var i = 0; i < len; i++) {
        pushBits(bits4, 8, data[i]);
      }
      var res = {};
      var d = [0, 1, 0, 0];
      pushBits(d, 16, len);
      res.data10 = res.data27 = d.concat(bits4);
      if (len < 256) {
        var d = [0, 1, 0, 0];
        pushBits(d, 8, len);
        res.data1 = d.concat(bits4);
      }
      return res;
    }
    var ALPHANUM = function(s) {
      var res = {};
      for (var i = 0; i < s.length; i++) {
        res[s[i]] = i;
      }
      return res;
    }("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
    function encode_alphanum(str) {
      var len = str.length;
      var bits4 = [];
      for (var i = 0; i < len; i += 2) {
        var b = 6;
        var n = ALPHANUM[str[i]];
        if (str[i + 1]) {
          b = 11;
          n = n * 45 + ALPHANUM[str[i + 1]];
        }
        pushBits(bits4, b, n);
      }
      var res = {};
      var d = [0, 0, 1, 0];
      pushBits(d, 13, len);
      res.data27 = d.concat(bits4);
      if (len < 2048) {
        var d = [0, 0, 1, 0];
        pushBits(d, 11, len);
        res.data10 = d.concat(bits4);
      }
      if (len < 512) {
        var d = [0, 0, 1, 0];
        pushBits(d, 9, len);
        res.data1 = d.concat(bits4);
      }
      return res;
    }
    function encode_numeric(str) {
      var len = str.length;
      var bits4 = [];
      for (var i = 0; i < len; i += 3) {
        var s = str.substr(i, 3);
        var b = Math.ceil(s.length * 10 / 3);
        pushBits(bits4, b, parseInt(s, 10));
      }
      var res = {};
      var d = [0, 0, 0, 1];
      pushBits(d, 14, len);
      res.data27 = d.concat(bits4);
      if (len < 4096) {
        var d = [0, 0, 0, 1];
        pushBits(d, 12, len);
        res.data10 = d.concat(bits4);
      }
      if (len < 1024) {
        var d = [0, 0, 0, 1];
        pushBits(d, 10, len);
        res.data1 = d.concat(bits4);
      }
      return res;
    }
    function encode_url(str) {
      var slash = str.indexOf("/", 8) + 1 || str.length;
      var res = encode3(str.slice(0, slash).toUpperCase(), false);
      if (slash >= str.length) {
        return res;
      }
      var path_res = encode3(str.slice(slash), false);
      res.data27 = res.data27.concat(path_res.data27);
      if (res.data10 && path_res.data10) {
        res.data10 = res.data10.concat(path_res.data10);
      }
      if (res.data1 && path_res.data1) {
        res.data1 = res.data1.concat(path_res.data1);
      }
      return res;
    }
    function encode3(data, parse_url) {
      var str;
      var t = typeof data;
      if (t == "string" || t == "number") {
        str = "" + data;
        data = new Buffer(str);
      } else if (Buffer.isBuffer(data)) {
        str = data.toString();
      } else if (Array.isArray(data)) {
        data = new Buffer(data);
        str = data.toString();
      } else {
        throw new Error("Bad data");
      }
      if (/^[0-9]+$/.test(str)) {
        if (data.length > 7089) {
          throw new Error("Too much data");
        }
        return encode_numeric(str);
      }
      if (/^[0-9A-Z \$%\*\+\.\/\:\-]+$/.test(str)) {
        if (data.length > 4296) {
          throw new Error("Too much data");
        }
        return encode_alphanum(str);
      }
      if (parse_url && /^https?:/i.test(str)) {
        return encode_url(str);
      }
      if (data.length > 2953) {
        throw new Error("Too much data");
      }
      return encode_8bit(data);
    }
    module2.exports = encode3;
  }
});

// ../../node_modules/qr-image/lib/errorcode.js
var require_errorcode = __commonJS({
  "../../node_modules/qr-image/lib/errorcode.js"(exports, module2) {
    "use strict";
    var GF256_BASE = 285;
    var EXP_TABLE = [1];
    var LOG_TABLE = [];
    for (i = 1; i < 256; i++) {
      n = EXP_TABLE[i - 1] << 1;
      if (n > 255)
        n = n ^ GF256_BASE;
      EXP_TABLE[i] = n;
    }
    var n;
    var i;
    for (i = 0; i < 255; i++) {
      LOG_TABLE[EXP_TABLE[i]] = i;
    }
    var i;
    function exp7(k) {
      while (k < 0)
        k += 255;
      while (k > 255)
        k -= 255;
      return EXP_TABLE[k];
    }
    function log(k) {
      if (k < 1 || k > 255) {
        throw Error("Bad log(" + k + ")");
      }
      return LOG_TABLE[k];
    }
    var POLYNOMIALS = [
      [0],
      // a^0 x^0
      [0, 0],
      // a^0 x^1 + a^0 x^0
      [0, 25, 1]
      // a^0 x^2 + a^25 x^1 + a^1 x^0
      // and so on...
    ];
    function generatorPolynomial(num) {
      if (POLYNOMIALS[num]) {
        return POLYNOMIALS[num];
      }
      var prev = generatorPolynomial(num - 1);
      var res = [];
      res[0] = prev[0];
      for (var i2 = 1; i2 <= num; i2++) {
        res[i2] = log(exp7(prev[i2]) ^ exp7(prev[i2 - 1] + num - 1));
      }
      POLYNOMIALS[num] = res;
      return res;
    }
    module2.exports = function calculate_ec(msg, ec_len) {
      msg = [].slice.call(msg);
      var poly = generatorPolynomial(ec_len);
      for (var i2 = 0; i2 < ec_len; i2++)
        msg.push(0);
      while (msg.length > ec_len) {
        if (!msg[0]) {
          msg.shift();
          continue;
        }
        var log_k = log(msg[0]);
        for (var i2 = 0; i2 <= ec_len; i2++) {
          msg[i2] = msg[i2] ^ exp7(poly[i2] + log_k);
        }
        msg.shift();
      }
      return new Buffer(msg);
    };
  }
});

// ../../node_modules/qr-image/lib/matrix.js
var require_matrix = __commonJS({
  "../../node_modules/qr-image/lib/matrix.js"(exports, module2) {
    "use strict";
    function init2(version) {
      var N = version * 4 + 17;
      var matrix = [];
      var zeros = new Buffer(N);
      zeros.fill(0);
      zeros = [].slice.call(zeros);
      for (var i = 0; i < N; i++) {
        matrix[i] = zeros.slice();
      }
      return matrix;
    }
    function fillFinders(matrix) {
      var N = matrix.length;
      for (var i = -3; i <= 3; i++) {
        for (var j = -3; j <= 3; j++) {
          var max = Math.max(i, j);
          var min = Math.min(i, j);
          var pixel = max == 2 && min >= -2 || min == -2 && max <= 2 ? 128 : 129;
          matrix[3 + i][3 + j] = pixel;
          matrix[3 + i][N - 4 + j] = pixel;
          matrix[N - 4 + i][3 + j] = pixel;
        }
      }
      for (var i = 0; i < 8; i++) {
        matrix[7][i] = matrix[i][7] = matrix[7][N - i - 1] = matrix[i][N - 8] = matrix[N - 8][i] = matrix[N - 1 - i][7] = 128;
      }
    }
    function fillAlignAndTiming(matrix) {
      var N = matrix.length;
      if (N > 21) {
        var len = N - 13;
        var delta = Math.round(len / Math.ceil(len / 28));
        if (delta % 2)
          delta++;
        var res = [];
        for (var p = len + 6; p > 10; p -= delta) {
          res.unshift(p);
        }
        res.unshift(6);
        for (var i = 0; i < res.length; i++) {
          for (var j = 0; j < res.length; j++) {
            var x = res[i], y = res[j];
            if (matrix[x][y])
              continue;
            for (var r = -2; r <= 2; r++) {
              for (var c = -2; c <= 2; c++) {
                var max = Math.max(r, c);
                var min = Math.min(r, c);
                var pixel = max == 1 && min >= -1 || min == -1 && max <= 1 ? 128 : 129;
                matrix[x + r][y + c] = pixel;
              }
            }
          }
        }
      }
      for (var i = 8; i < N - 8; i++) {
        matrix[6][i] = matrix[i][6] = i % 2 ? 128 : 129;
      }
    }
    function fillStub(matrix) {
      var N = matrix.length;
      for (var i = 0; i < 8; i++) {
        if (i != 6) {
          matrix[8][i] = matrix[i][8] = 128;
        }
        matrix[8][N - 1 - i] = 128;
        matrix[N - 1 - i][8] = 128;
      }
      matrix[8][8] = 128;
      matrix[N - 8][8] = 129;
      if (N < 45)
        return;
      for (var i = N - 11; i < N - 8; i++) {
        for (var j = 0; j < 6; j++) {
          matrix[i][j] = matrix[j][i] = 128;
        }
      }
    }
    var fillReserved = function() {
      var FORMATS = Array(32);
      var VERSIONS = Array(40);
      var gf15 = 1335;
      var gf18 = 7973;
      var formats_mask = 21522;
      for (var format = 0; format < 32; format++) {
        var res = format << 10;
        for (var i = 5; i > 0; i--) {
          if (res >>> 9 + i) {
            res = res ^ gf15 << i - 1;
          }
        }
        FORMATS[format] = (res | format << 10) ^ formats_mask;
      }
      for (var version = 7; version <= 40; version++) {
        var res = version << 12;
        for (var i = 6; i > 0; i--) {
          if (res >>> 11 + i) {
            res = res ^ gf18 << i - 1;
          }
        }
        VERSIONS[version] = res | version << 12;
      }
      var EC_LEVELS = { L: 1, M: 0, Q: 3, H: 2 };
      return function fillReserved2(matrix, ec_level, mask) {
        var N = matrix.length;
        var format2 = FORMATS[EC_LEVELS[ec_level] << 3 | mask];
        function F(k) {
          return format2 >> k & 1 ? 129 : 128;
        }
        ;
        for (var i2 = 0; i2 < 8; i2++) {
          matrix[8][N - 1 - i2] = F(i2);
          if (i2 < 6)
            matrix[i2][8] = F(i2);
        }
        for (var i2 = 8; i2 < 15; i2++) {
          matrix[N - 15 + i2][8] = F(i2);
          if (i2 > 8)
            matrix[8][14 - i2] = F(i2);
        }
        matrix[7][8] = F(6);
        matrix[8][8] = F(7);
        matrix[8][7] = F(8);
        var version2 = VERSIONS[(N - 17) / 4];
        if (!version2)
          return;
        function V(k) {
          return version2 >> k & 1 ? 129 : 128;
        }
        ;
        for (var i2 = 0; i2 < 6; i2++) {
          for (var j = 0; j < 3; j++) {
            matrix[N - 11 + j][i2] = matrix[i2][N - 11 + j] = V(i2 * 3 + j);
          }
        }
      };
    }();
    var fillData = function() {
      var MASK_FUNCTIONS = [
        function(i, j) {
          return (i + j) % 2 == 0;
        },
        function(i, j) {
          return i % 2 == 0;
        },
        function(i, j) {
          return j % 3 == 0;
        },
        function(i, j) {
          return (i + j) % 3 == 0;
        },
        function(i, j) {
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
        },
        function(i, j) {
          return i * j % 2 + i * j % 3 == 0;
        },
        function(i, j) {
          return (i * j % 2 + i * j % 3) % 2 == 0;
        },
        function(i, j) {
          return (i * j % 3 + (i + j) % 2) % 2 == 0;
        }
      ];
      return function fillData2(matrix, data, mask) {
        var N = matrix.length;
        var row, col, dir = -1;
        row = col = N - 1;
        var mask_fn = MASK_FUNCTIONS[mask];
        var len = data.blocks[data.blocks.length - 1].length;
        for (var i = 0; i < len; i++) {
          for (var b = 0; b < data.blocks.length; b++) {
            if (data.blocks[b].length <= i)
              continue;
            put(data.blocks[b][i]);
          }
        }
        len = data.ec_len;
        for (var i = 0; i < len; i++) {
          for (var b = 0; b < data.ec.length; b++) {
            put(data.ec[b][i]);
          }
        }
        if (col > -1) {
          do {
            matrix[row][col] = mask_fn(row, col) ? 1 : 0;
          } while (next());
        }
        function put(byte) {
          for (var mask2 = 128; mask2; mask2 = mask2 >> 1) {
            var pixel = !!(mask2 & byte);
            if (mask_fn(row, col))
              pixel = !pixel;
            matrix[row][col] = pixel ? 1 : 0;
            next();
          }
        }
        function next() {
          do {
            if (col % 2 ^ col < 6) {
              if (dir < 0 && row == 0 || dir > 0 && row == N - 1) {
                col--;
                dir = -dir;
              } else {
                col++;
                row += dir;
              }
            } else {
              col--;
            }
            if (col == 6) {
              col--;
            }
            if (col < 0) {
              return false;
            }
          } while (matrix[row][col] & 240);
          return true;
        }
      };
    }();
    function calculatePenalty(matrix) {
      var N = matrix.length;
      var penalty = 0;
      for (var i = 0; i < N; i++) {
        var pixel = matrix[i][0] & 1;
        var len = 1;
        for (var j = 1; j < N; j++) {
          var p = matrix[i][j] & 1;
          if (p == pixel) {
            len++;
            continue;
          }
          if (len >= 5) {
            penalty += len - 2;
          }
          pixel = p;
          len = 1;
        }
        if (len >= 5) {
          penalty += len - 2;
        }
      }
      for (var j = 0; j < N; j++) {
        var pixel = matrix[0][j] & 1;
        var len = 1;
        for (var i = 1; i < N; i++) {
          var p = matrix[i][j] & 1;
          if (p == pixel) {
            len++;
            continue;
          }
          if (len >= 5) {
            penalty += len - 2;
          }
          pixel = p;
          len = 1;
        }
        if (len >= 5) {
          penalty += len - 2;
        }
      }
      for (var i = 0; i < N - 1; i++) {
        for (var j = 0; j < N - 1; j++) {
          var s = matrix[i][j] + matrix[i][j + 1] + matrix[i + 1][j] + matrix[i + 1][j + 1] & 7;
          if (s == 0 || s == 4) {
            penalty += 3;
          }
        }
      }
      function I(k) {
        return matrix[i][j + k] & 1;
      }
      ;
      function J(k) {
        return matrix[i + k][j] & 1;
      }
      ;
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (j < N - 6 && I(0) && !I(1) && I(2) && I(3) && I(4) && !I(5) && I(6)) {
            if (j >= 4 && !(I(-4) || I(-3) || I(-2) || I(-1))) {
              penalty += 40;
            }
            if (j < N - 10 && !(I(7) || I(8) || I(9) || I(10))) {
              penalty += 40;
            }
          }
          if (i < N - 6 && J(0) && !J(1) && J(2) && J(3) && J(4) && !J(5) && J(6)) {
            if (i >= 4 && !(J(-4) || J(-3) || J(-2) || J(-1))) {
              penalty += 40;
            }
            if (i < N - 10 && !(J(7) || J(8) || J(9) || J(10))) {
              penalty += 40;
            }
          }
        }
      }
      var numDark = 0;
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (matrix[i][j] & 1)
            numDark++;
        }
      }
      penalty += 10 * Math.floor(Math.abs(10 - 20 * numDark / (N * N)));
      return penalty;
    }
    function getMatrix(data) {
      var matrix = init2(data.version);
      fillFinders(matrix);
      fillAlignAndTiming(matrix);
      fillStub(matrix);
      var penalty = Infinity;
      var bestMask = 0;
      for (var mask = 0; mask < 8; mask++) {
        fillData(matrix, data, mask);
        fillReserved(matrix, data.ec_level, mask);
        var p = calculatePenalty(matrix);
        if (p < penalty) {
          penalty = p;
          bestMask = mask;
        }
      }
      fillData(matrix, data, bestMask);
      fillReserved(matrix, data.ec_level, bestMask);
      return matrix.map(function(row) {
        return row.map(function(cell) {
          return cell & 1;
        });
      });
    }
    module2.exports = {
      getMatrix,
      init: init2,
      fillFinders,
      fillAlignAndTiming,
      fillStub,
      fillReserved,
      fillData,
      calculatePenalty
    };
  }
});

// ../../node_modules/qr-image/lib/qr-base.js
var require_qr_base = __commonJS({
  "../../node_modules/qr-image/lib/qr-base.js"(exports, module2) {
    "use strict";
    var encode3 = require_encode();
    var calculateEC = require_errorcode();
    var matrix = require_matrix();
    function _deepCopy(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    var EC_LEVELS = ["L", "M", "Q", "H"];
    var versions = [
      [],
      // there is no version 0
      // total number of codewords, (number of ec codewords, number of blocks) * ( L, M, Q, H )
      [26, 7, 1, 10, 1, 13, 1, 17, 1],
      [44, 10, 1, 16, 1, 22, 1, 28, 1],
      [70, 15, 1, 26, 1, 36, 2, 44, 2],
      [100, 20, 1, 36, 2, 52, 2, 64, 4],
      [134, 26, 1, 48, 2, 72, 4, 88, 4],
      // 5
      [172, 36, 2, 64, 4, 96, 4, 112, 4],
      [196, 40, 2, 72, 4, 108, 6, 130, 5],
      [242, 48, 2, 88, 4, 132, 6, 156, 6],
      [292, 60, 2, 110, 5, 160, 8, 192, 8],
      [346, 72, 4, 130, 5, 192, 8, 224, 8],
      // 10
      [404, 80, 4, 150, 5, 224, 8, 264, 11],
      [466, 96, 4, 176, 8, 260, 10, 308, 11],
      [532, 104, 4, 198, 9, 288, 12, 352, 16],
      [581, 120, 4, 216, 9, 320, 16, 384, 16],
      [655, 132, 6, 240, 10, 360, 12, 432, 18],
      // 15
      [733, 144, 6, 280, 10, 408, 17, 480, 16],
      [815, 168, 6, 308, 11, 448, 16, 532, 19],
      [901, 180, 6, 338, 13, 504, 18, 588, 21],
      [991, 196, 7, 364, 14, 546, 21, 650, 25],
      [1085, 224, 8, 416, 16, 600, 20, 700, 25],
      // 20
      [1156, 224, 8, 442, 17, 644, 23, 750, 25],
      [1258, 252, 9, 476, 17, 690, 23, 816, 34],
      [1364, 270, 9, 504, 18, 750, 25, 900, 30],
      [1474, 300, 10, 560, 20, 810, 27, 960, 32],
      [1588, 312, 12, 588, 21, 870, 29, 1050, 35],
      // 25
      [1706, 336, 12, 644, 23, 952, 34, 1110, 37],
      [1828, 360, 12, 700, 25, 1020, 34, 1200, 40],
      [1921, 390, 13, 728, 26, 1050, 35, 1260, 42],
      [2051, 420, 14, 784, 28, 1140, 38, 1350, 45],
      [2185, 450, 15, 812, 29, 1200, 40, 1440, 48],
      // 30
      [2323, 480, 16, 868, 31, 1290, 43, 1530, 51],
      [2465, 510, 17, 924, 33, 1350, 45, 1620, 54],
      [2611, 540, 18, 980, 35, 1440, 48, 1710, 57],
      [2761, 570, 19, 1036, 37, 1530, 51, 1800, 60],
      [2876, 570, 19, 1064, 38, 1590, 53, 1890, 63],
      // 35
      [3034, 600, 20, 1120, 40, 1680, 56, 1980, 66],
      [3196, 630, 21, 1204, 43, 1770, 59, 2100, 70],
      [3362, 660, 22, 1260, 45, 1860, 62, 2220, 74],
      [3532, 720, 24, 1316, 47, 1950, 65, 2310, 77],
      [3706, 750, 25, 1372, 49, 2040, 68, 2430, 81]
      // 40
    ];
    versions = versions.map(function(v, index) {
      if (!index)
        return {};
      var res = {};
      for (var i = 1; i < 8; i += 2) {
        var length = v[0] - v[i];
        var num_template = v[i + 1];
        var ec_level = EC_LEVELS[i / 2 | 0];
        var level = {
          version: index,
          ec_level,
          data_len: length,
          ec_len: v[i] / num_template,
          blocks: [],
          ec: []
        };
        for (var k = num_template, n = length; k > 0; k--) {
          var block = n / k | 0;
          level.blocks.push(block);
          n -= block;
        }
        res[ec_level] = level;
      }
      return res;
    });
    function getTemplate(message, ec_level) {
      var i = 1;
      var len;
      if (message.data1) {
        len = Math.ceil(message.data1.length / 8);
      } else {
        i = 10;
      }
      for (; i < 10; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      if (message.data10) {
        len = Math.ceil(message.data10.length / 8);
      } else {
        i = 27;
      }
      for (; i < 27; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      len = Math.ceil(message.data27.length / 8);
      for (; i < 41; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      throw new Error("Too much data");
    }
    function fillTemplate(message, template) {
      var blocks = new Buffer(template.data_len);
      blocks.fill(0);
      if (template.version < 10) {
        message = message.data1;
      } else if (template.version < 27) {
        message = message.data10;
      } else {
        message = message.data27;
      }
      var len = message.length;
      for (var i = 0; i < len; i += 8) {
        var b = 0;
        for (var j = 0; j < 8; j++) {
          b = b << 1 | (message[i + j] ? 1 : 0);
        }
        blocks[i / 8] = b;
      }
      var pad = 236;
      for (var i = Math.ceil((len + 4) / 8); i < blocks.length; i++) {
        blocks[i] = pad;
        pad = pad == 236 ? 17 : 236;
      }
      var offset = 0;
      template.blocks = template.blocks.map(function(n) {
        var b2 = blocks.slice(offset, offset + n);
        offset += n;
        template.ec.push(calculateEC(b2, template.ec_len));
        return b2;
      });
      return template;
    }
    function QR(text2, ec_level, parse_url) {
      ec_level = EC_LEVELS.indexOf(ec_level) > -1 ? ec_level : "M";
      var message = encode3(text2, parse_url);
      var data = fillTemplate(message, getTemplate(message, ec_level));
      return matrix.getMatrix(data);
    }
    module2.exports = {
      QR,
      getTemplate,
      fillTemplate
    };
  }
});

// ../../node_modules/qr-image/lib/crc32buffer.js
var require_crc32buffer = __commonJS({
  "../../node_modules/qr-image/lib/crc32buffer.js"(exports, module2) {
    "use strict";
    var crc_table = [];
    for (n = 0; n < 256; n++) {
      c = crc_table[n] = new Buffer(4);
      c.writeUInt32BE(n, 0);
      for (k = 0; k < 8; k++) {
        b0 = c[0] & 1;
        b1 = c[1] & 1;
        b2 = c[2] & 1;
        b3 = c[3] & 1;
        c[0] = c[0] >> 1 ^ (b3 ? 237 : 0);
        c[1] = c[1] >> 1 ^ (b3 ? 184 : 0) ^ (b0 ? 128 : 0);
        c[2] = c[2] >> 1 ^ (b3 ? 131 : 0) ^ (b1 ? 128 : 0);
        c[3] = c[3] >> 1 ^ (b3 ? 32 : 0) ^ (b2 ? 128 : 0);
      }
    }
    var c;
    var b0;
    var b1;
    var b2;
    var b3;
    var k;
    var n;
    function update(c2, buf) {
      var l = buf.length;
      for (var n2 = 0; n2 < l; n2++) {
        var e4 = crc_table[c2[3] ^ buf[n2]];
        c2[3] = e4[3] ^ c2[2];
        c2[2] = e4[2] ^ c2[1];
        c2[1] = e4[1] ^ c2[0];
        c2[0] = e4[0];
      }
    }
    function crc32() {
      var l = arguments.length;
      var c2 = new Buffer(4);
      c2.fill(255);
      for (var i = 0; i < l; i++) {
        update(c2, new Buffer(arguments[i]));
      }
      c2[0] = c2[0] ^ 255;
      c2[1] = c2[1] ^ 255;
      c2[2] = c2[2] ^ 255;
      c2[3] = c2[3] ^ 255;
      return c2.readUInt32BE(0);
    }
    module2.exports = crc32;
  }
});

// ../../node_modules/qr-image/lib/crc32.js
var require_crc322 = __commonJS({
  "../../node_modules/qr-image/lib/crc32.js"(exports, module2) {
    "use strict";
    (function() {
      if (process.arch === "arm") {
        module2.exports = require_crc32buffer();
        return;
      }
      var crc_table = [];
      (function() {
        for (var n = 0; n < 256; n++) {
          var c = n;
          for (var k = 0; k < 8; k++) {
            if (c & 1) {
              c = 3988292384 ^ c >>> 1;
            } else {
              c = c >>> 1;
            }
          }
          crc_table[n] = c >>> 0;
        }
      })();
      function update(c, buf) {
        var l = buf.length;
        for (var n = 0; n < l; n++) {
          c = crc_table[(c ^ buf[n]) & 255] ^ c >>> 8;
        }
        return c;
      }
      function crc32() {
        var l = arguments.length;
        var c = -1;
        for (var i = 0; i < l; i++) {
          c = update(c, new Buffer(arguments[i]));
        }
        c = (c ^ -1) >>> 0;
        return c;
      }
      module2.exports = crc32;
    })();
  }
});

// ../../node_modules/qr-image/lib/png.js
var require_png = __commonJS({
  "../../node_modules/qr-image/lib/png.js"(exports, module2) {
    "use strict";
    var zlib2 = require("zlib");
    var crc32 = require_crc322();
    var PNG_HEAD = new Buffer([137, 80, 78, 71, 13, 10, 26, 10]);
    var PNG_IHDR = new Buffer([0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0]);
    var PNG_IDAT = new Buffer([0, 0, 0, 0, 73, 68, 65, 84]);
    var PNG_IEND = new Buffer([0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130]);
    function png(bitmap2, stream4) {
      stream4.push(PNG_HEAD);
      var IHDR = Buffer.concat([PNG_IHDR]);
      IHDR.writeUInt32BE(bitmap2.size, 8);
      IHDR.writeUInt32BE(bitmap2.size, 12);
      IHDR.writeUInt32BE(crc32(IHDR.slice(4, -4)), 21);
      stream4.push(IHDR);
      var IDAT = Buffer.concat([
        PNG_IDAT,
        zlib2.deflateSync(bitmap2.data, { level: 9 }),
        new Buffer(4)
      ]);
      IDAT.writeUInt32BE(IDAT.length - 12, 0);
      IDAT.writeUInt32BE(crc32(IDAT.slice(4, -4)), IDAT.length - 4);
      stream4.push(IDAT);
      stream4.push(PNG_IEND);
      stream4.push(null);
    }
    function bitmap(matrix, size, margin) {
      var N = matrix.length;
      var X = (N + 2 * margin) * size;
      var data = new Buffer((X + 1) * X);
      data.fill(255);
      for (var i = 0; i < X; i++) {
        data[i * (X + 1)] = 0;
      }
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (matrix[i][j]) {
            var offset = ((margin + i) * (X + 1) + (margin + j)) * size + 1;
            data.fill(0, offset, offset + size);
            for (var c = 1; c < size; c++) {
              data.copy(data, offset + c * (X + 1), offset, offset + size);
            }
          }
        }
      }
      return {
        data,
        size: X
      };
    }
    module2.exports = {
      bitmap,
      png
    };
  }
});

// ../../node_modules/qr-image/lib/vector.js
var require_vector = __commonJS({
  "../../node_modules/qr-image/lib/vector.js"(exports, module2) {
    "use strict";
    function matrix2path(matrix) {
      var N = matrix.length;
      var filled = [];
      for (var row = -1; row <= N; row++) {
        filled[row] = [];
      }
      var path = [];
      for (var row = 0; row < N; row++) {
        for (var col = 0; col < N; col++) {
          if (filled[row][col])
            continue;
          filled[row][col] = 1;
          if (isDark(row, col)) {
            if (!isDark(row - 1, col)) {
              path.push(plot(row, col, "right"));
            }
          } else {
            if (isDark(row, col - 1)) {
              path.push(plot(row, col, "down"));
            }
          }
        }
      }
      return path;
      function isDark(row2, col2) {
        if (row2 < 0 || col2 < 0 || row2 >= N || col2 >= N)
          return false;
        return !!matrix[row2][col2];
      }
      function plot(row0, col0, dir) {
        filled[row0][col0] = 1;
        var res = [];
        res.push(["M", col0, row0]);
        var row2 = row0;
        var col2 = col0;
        var len = 0;
        do {
          switch (dir) {
            case "right":
              filled[row2][col2] = 1;
              if (isDark(row2, col2)) {
                filled[row2 - 1][col2] = 1;
                if (isDark(row2 - 1, col2)) {
                  res.push(["h", len]);
                  len = 0;
                  dir = "up";
                } else {
                  len++;
                  col2++;
                }
              } else {
                res.push(["h", len]);
                len = 0;
                dir = "down";
              }
              break;
            case "left":
              filled[row2 - 1][col2 - 1] = 1;
              if (isDark(row2 - 1, col2 - 1)) {
                filled[row2][col2 - 1] = 1;
                if (isDark(row2, col2 - 1)) {
                  res.push(["h", -len]);
                  len = 0;
                  dir = "down";
                } else {
                  len++;
                  col2--;
                }
              } else {
                res.push(["h", -len]);
                len = 0;
                dir = "up";
              }
              break;
            case "down":
              filled[row2][col2 - 1] = 1;
              if (isDark(row2, col2 - 1)) {
                filled[row2][col2] = 1;
                if (isDark(row2, col2)) {
                  res.push(["v", len]);
                  len = 0;
                  dir = "right";
                } else {
                  len++;
                  row2++;
                }
              } else {
                res.push(["v", len]);
                len = 0;
                dir = "left";
              }
              break;
            case "up":
              filled[row2 - 1][col2] = 1;
              if (isDark(row2 - 1, col2)) {
                filled[row2 - 1][col2 - 1] = 1;
                if (isDark(row2 - 1, col2 - 1)) {
                  res.push(["v", -len]);
                  len = 0;
                  dir = "left";
                } else {
                  len++;
                  row2--;
                }
              } else {
                res.push(["v", -len]);
                len = 0;
                dir = "right";
              }
              break;
          }
        } while (row2 != row0 || col2 != col0);
        return res;
      }
    }
    function pushSVGPath(matrix, stream4, margin) {
      matrix2path(matrix).forEach(function(subpath) {
        var res = "";
        for (var k = 0; k < subpath.length; k++) {
          var item = subpath[k];
          switch (item[0]) {
            case "M":
              res += "M" + (item[1] + margin) + " " + (item[2] + margin);
              break;
            default:
              res += item.join("");
          }
        }
        res += "z";
        stream4.push(res);
      });
    }
    function SVG_object(matrix, margin) {
      var stream4 = [];
      pushSVGPath(matrix, stream4, margin);
      var result = {
        size: matrix.length + 2 * margin,
        path: stream4.filter(Boolean).join("")
      };
      return result;
    }
    function SVG(matrix, stream4, margin, size) {
      var X = matrix.length + 2 * margin;
      stream4.push('<svg xmlns="http://www.w3.org/2000/svg" ');
      if (size > 0) {
        var XY = X * size;
        stream4.push('width="' + XY + '" height="' + XY + '" ');
      }
      stream4.push('viewBox="0 0 ' + X + " " + X + '">');
      stream4.push('<path d="');
      pushSVGPath(matrix, stream4, margin);
      stream4.push('"/></svg>');
      stream4.push(null);
    }
    function EPS(matrix, stream4, margin) {
      var N = matrix.length;
      var scale = 9;
      var X = (N + 2 * margin) * scale;
      stream4.push([
        "%!PS-Adobe-3.0 EPSF-3.0",
        "%%BoundingBox: 0 0 " + X + " " + X,
        "/h { 0 rlineto } bind def",
        "/v { 0 exch neg rlineto } bind def",
        "/M { neg " + (N + margin) + " add moveto } bind def",
        "/z { closepath } bind def",
        scale + " " + scale + " scale",
        ""
      ].join("\n"));
      matrix2path(matrix).forEach(function(subpath) {
        var res = "";
        for (var k = 0; k < subpath.length; k++) {
          var item = subpath[k];
          switch (item[0]) {
            case "M":
              res += item[1] + margin + " " + item[2] + " M ";
              break;
            default:
              res += item[1] + " " + item[0] + " ";
          }
        }
        res += "z\n";
        stream4.push(res);
      });
      stream4.push("fill\n%%EOF\n");
      stream4.push(null);
    }
    function PDF(matrix, stream4, margin) {
      var N = matrix.length;
      var scale = 9;
      var X = (N + 2 * margin) * scale;
      var data = [
        "%PDF-1.0\n\n",
        "1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj\n",
        "2 0 obj << /Type /Pages /Count 1 /Kids [ 3 0 R ] >> endobj\n"
      ];
      data.push("3 0 obj << /Type /Page /Parent 2 0 R /Resources <<>> /Contents 4 0 R /MediaBox [ 0 0 " + X + " " + X + " ] >> endobj\n");
      var path = scale + " 0 0 " + scale + " 0 0 cm\n";
      path += matrix2path(matrix).map(function(subpath) {
        var res = "";
        var x, y;
        for (var k = 0; k < subpath.length; k++) {
          var item = subpath[k];
          switch (item[0]) {
            case "M":
              x = item[1] + margin;
              y = N - item[2] + margin;
              res += x + " " + y + " m ";
              break;
            case "h":
              x += item[1];
              res += x + " " + y + " l ";
              break;
            case "v":
              y -= item[1];
              res += x + " " + y + " l ";
              break;
          }
        }
        res += "h";
        return res;
      }).join("\n");
      path += "\nf\n";
      data.push("4 0 obj << /Length " + path.length + " >> stream\n" + path + "endstream\nendobj\n");
      var xref = "xref\n0 5\n0000000000 65535 f \n";
      for (var i = 1, l = data[0].length; i < 5; i++) {
        xref += ("0000000000" + l).substr(-10) + " 00000 n \n";
        l += data[i].length;
      }
      data.push(
        xref,
        "trailer << /Root 1 0 R /Size 5 >>\n",
        "startxref\n" + l + "\n%%EOF\n"
      );
      stream4.push(data.join(""));
      stream4.push(null);
    }
    module2.exports = {
      svg: SVG,
      eps: EPS,
      pdf: PDF,
      svg_object: SVG_object
    };
  }
});

// ../../node_modules/qr-image/lib/qr.js
var require_qr = __commonJS({
  "../../node_modules/qr-image/lib/qr.js"(exports, module2) {
    "use strict";
    var Readable2 = require("stream").Readable;
    var QR = require_qr_base().QR;
    var png = require_png();
    var vector = require_vector();
    var fn_noop = function() {
    };
    var BITMAP_OPTIONS = {
      parse_url: false,
      ec_level: "M",
      size: 5,
      margin: 4,
      customize: null
    };
    var VECTOR_OPTIONS = {
      parse_url: false,
      ec_level: "M",
      margin: 1,
      size: 0
    };
    function get_options(options, force_type) {
      if (typeof options === "string") {
        options = { "ec_level": options };
      } else {
        options = options || {};
      }
      var _options = {
        type: String(force_type || options.type || "png").toLowerCase()
      };
      var defaults2 = _options.type == "png" ? BITMAP_OPTIONS : VECTOR_OPTIONS;
      for (var k in defaults2) {
        _options[k] = k in options ? options[k] : defaults2[k];
      }
      return _options;
    }
    function qr_image(text2, options) {
      options = get_options(options);
      var matrix = QR(text2, options.ec_level, options.parse_url);
      var stream4 = new Readable2();
      stream4._read = fn_noop;
      switch (options.type) {
        case "svg":
        case "pdf":
        case "eps":
          process.nextTick(function() {
            vector[options.type](matrix, stream4, options.margin, options.size);
          });
          break;
        case "svgpath":
          process.nextTick(function() {
            var obj = vector.svg_object(matrix, options.margin, options.size);
            stream4.push(obj.path);
            stream4.push(null);
          });
          break;
        case "png":
        default:
          process.nextTick(function() {
            var bitmap = png.bitmap(matrix, options.size, options.margin);
            if (options.customize) {
              options.customize(bitmap);
            }
            png.png(bitmap, stream4);
          });
      }
      return stream4;
    }
    function qr_image_sync(text2, options) {
      options = get_options(options);
      var matrix = QR(text2, options.ec_level, options.parse_url);
      var stream4 = [];
      var result;
      switch (options.type) {
        case "svg":
        case "pdf":
        case "eps":
          vector[options.type](matrix, stream4, options.margin, options.size);
          result = stream4.filter(Boolean).join("");
          break;
        case "png":
        default:
          var bitmap = png.bitmap(matrix, options.size, options.margin);
          if (options.customize) {
            options.customize(bitmap);
          }
          png.png(bitmap, stream4);
          result = Buffer.concat(stream4.filter(Boolean));
      }
      return result;
    }
    function svg_object(text2, options) {
      options = get_options(options, "svg");
      var matrix = QR(text2, options.ec_level);
      return vector.svg_object(matrix, options.margin);
    }
    module2.exports = {
      matrix: QR,
      image: qr_image,
      imageSync: qr_image_sync,
      svgObject: svg_object
    };
  }
});

// ../../node_modules/@pcd/passport-ui/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@pcd/passport-ui/dist/index.js"(exports, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp2(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod4, isNodeMode, target) => (target = mod4 != null ? __create2(__getProtoOf2(mod4)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod4 || !mod4.__esModule ? __defProp2(target, "default", { value: mod4, enumerable: true }) : target,
      mod4
    ));
    var __toCommonJS2 = (mod4) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod4);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e4) {
            reject(e4);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e4) {
            reject(e4);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var src_exports2 = {};
    __export2(src_exports2, {
      FieldLabel: () => FieldLabel2,
      HiddenText: () => HiddenText,
      HiddenTextContainer: () => HiddenTextContainer,
      QR: () => QR,
      QRDisplay: () => QRDisplay,
      QRDisplayWithRegenerateAndStorage: () => QRDisplayWithRegenerateAndStorage,
      Separator: () => Separator2,
      Spacer: () => Spacer2,
      TextContainer: () => TextContainer2,
      decodeQRPayload: () => decodeQRPayload,
      encodeQRPayload: () => encodeQRPayload
    });
    module2.exports = __toCommonJS2(src_exports2);
    var import_styled_components8 = __toESM2(require("styled-components"));
    var import_jsx_runtime9 = require("react/jsx-runtime");
    function Spacer2({
      w,
      h
    }) {
      const width = w && `${w}px`;
      const height = h && `${h}px`;
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { style: { width, height } });
    }
    var Separator2 = import_styled_components8.default.div`
  box-sizing: border-box;
  background-color: var(--primary-lite);
  width: 100%;
  height: 2px;
  border-radius: 99px;
  margin: 16px 0px;
`;
    var FieldLabel2 = import_styled_components8.default.span`
  font-weight: bold;
`;
    var import_react10 = require("react");
    var import_styled_components22 = __toESM2(require("styled-components"));
    var import_jsx_runtime22 = require("react/jsx-runtime");
    function HiddenText({ text: text2 }) {
      const [visible, setVisible] = (0, import_react10.useState)(false);
      const onRevealClick = (0, import_react10.useCallback)(() => {
        setVisible(true);
      }, []);
      if (visible) {
        return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(TextContainer2, { children: text2 });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(HiddenTextContainer, { onClick: onRevealClick, children: "tap to reveal" });
    }
    var TextContainer2 = import_styled_components22.default.div`
  border: 2px solid var(--primary-lite);
  overflow: hidden;
  padding: 4px 8px;
  border-radius: 4px;
  margin-bottom: 8px;
`;
    var HiddenTextContainer = import_styled_components22.default.div`
  border: 2px solid var(--primary-lite);
  overflow: hidden;
  padding: 4px 8px;
  border-radius: 4px;
  display: flex;
  justify-content: center;
  align-items: center;
  user-select: none;
  cursor: pointer;
  background-color: rgba(0, 0, 0, 0.1);
  &:hover {
    background-color: rgba(0, 0, 0, 0.12);
  }
`;
    var import_pako = require_pako();
    var import_qr_image = __toESM2(require_qr());
    var import_react22 = require("react");
    var import_styled_components32 = __toESM2(require("styled-components"));
    var import_jsx_runtime32 = require("react/jsx-runtime");
    function encodeQRPayload(unencoded) {
      console.log(`encoding payload with length ${unencoded.length}`);
      const compressedData = (0, import_pako.gzip)(unencoded);
      const base64CompressedData = Buffer.from(compressedData).toString("base64");
      console.log(
        `Compressed: ${compressedData.length}, base64: ${base64CompressedData.length}`
      );
      return base64CompressedData;
    }
    function decodeQRPayload(encoded) {
      const buffer = Buffer.from(encoded, "base64");
      const unzippedBuffer = Buffer.from((0, import_pako.ungzip)(buffer));
      const decodedBuffer = unzippedBuffer.toString("utf8");
      return decodedBuffer;
    }
    function QRDisplayWithRegenerateAndStorage({
      generateQRPayload,
      maxAgeMs,
      uniqueId,
      loadingLogo,
      loadedLogo,
      fgColor,
      bgColor
    }) {
      const regenerateAfterMs = maxAgeMs * 2 / 3;
      const [savedState, setSavedState] = (0, import_react22.useState)(() => {
        const savedState2 = JSON.parse(
          localStorage[uniqueId] || "{}"
        );
        console.log(
          `[QR] ('${uniqueId}') loaded saved state for ${uniqueId}: ${JSON.stringify(
            savedState2
          )}`
        );
        const { timestamp, payload } = savedState2;
        if (timestamp != null && Date.now() - timestamp < maxAgeMs && payload !== void 0) {
          console.log(
            `[QR] ('${uniqueId}') from localStorage, timestamp ${timestamp}`
          );
          return { timestamp, payload };
        }
        return void 0;
      });
      const maybeGenerateQR = (0, import_react22.useCallback)(() => __async(this, null, function* () {
        const timestamp = Date.now();
        if (savedState && timestamp - savedState.timestamp < regenerateAfterMs) {
          console.log(
            `[QR] ('${uniqueId}') not regenerating, timestamp ${timestamp}`
          );
          return;
        }
        console.log(`[QR] ('${uniqueId}') regenerating data ${timestamp}`);
        const newData = yield generateQRPayload();
        const newSavedState = { timestamp, payload: newData };
        localStorage[uniqueId] = JSON.stringify(newSavedState);
        setSavedState(newSavedState);
      }), [generateQRPayload, regenerateAfterMs, savedState, uniqueId]);
      (0, import_react22.useEffect)(() => {
        maybeGenerateQR();
        const interval = setInterval(maybeGenerateQR, maxAgeMs / 10);
        return () => clearInterval(interval);
      }, [maxAgeMs, maybeGenerateQR]);
      const logoOverlay = (0, import_react22.useMemo)(() => {
        return savedState ? loadedLogo : loadingLogo;
      }, [loadedLogo, loadingLogo, savedState]);
      console.log(`[QR] ('${uniqueId}') rendering ${savedState == null ? void 0 : savedState.payload}`);
      return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
        QRDisplay,
        {
          logoOverlay,
          value: savedState == null ? void 0 : savedState.payload,
          fgColor,
          bgColor
        }
      );
    }
    function QRDisplay({
      value,
      logoOverlay,
      fgColor,
      bgColor
    }) {
      return /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(QRWrap, { children: [
        value !== void 0 && /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
          QR,
          {
            value,
            bgColor: bgColor != null ? bgColor : "#ffffff",
            fgColor: fgColor != null ? fgColor : "#000000"
          }
        ),
        logoOverlay
      ] });
    }
    var qrSize = "300px";
    var QRWrap = import_styled_components32.default.div`
  position: relative;
  width: ${qrSize};
  height: ${qrSize};
  margin: 0 auto;
`;
    function QR({
      value,
      fgColor,
      bgColor
    }) {
      const [svgObject, setSvgObject] = (0, import_react22.useState)();
      (0, import_react22.useEffect)(() => {
        const svgObject2 = import_qr_image.default.svgObject(value, "L");
        setSvgObject(svgObject2);
      }, [bgColor, fgColor, value]);
      return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Container3, { children: svgObject && /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
        "svg",
        {
          viewBox: `0 0 ${svgObject.size} ${svgObject.size}`,
          preserveAspectRatio: "none",
          children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
            "path",
            {
              width: "100%",
              height: "100%",
              d: svgObject.path,
              fill: fgColor
            }
          )
        }
      ) });
    }
    var Container3 = import_styled_components32.default.div`
  width: 100% !important;
  height: 100% !important;

  svg {
    width: 100%;
    height: 100%;
  }
`;
  }
});

// ../../node_modules/valid-url/index.js
var require_valid_url = __commonJS({
  "../../node_modules/valid-url/index.js"(exports, module2) {
    "use strict";
    (function(module3) {
      "use strict";
      module3.exports.is_uri = is_iri;
      module3.exports.is_http_uri = is_http_iri;
      module3.exports.is_https_uri = is_https_iri;
      module3.exports.is_web_uri = is_web_iri;
      module3.exports.isUri = is_iri;
      module3.exports.isHttpUri = is_http_iri;
      module3.exports.isHttpsUri = is_https_iri;
      module3.exports.isWebUri = is_web_iri;
      var splitUri = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
      };
      function is_iri(value) {
        if (!value) {
          return;
        }
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value))
          return;
        if (/%[^0-9a-f]/i.test(value))
          return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value))
          return;
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path = "";
        var query = "";
        var fragment = "";
        var out = "";
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        if (!(scheme && scheme.length && path.length >= 0))
          return;
        if (authority && authority.length) {
          if (!(path.length === 0 || /^\//.test(path)))
            return;
        } else {
          if (/^\/\//.test(path))
            return;
        }
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))
          return;
        out += scheme + ":";
        if (authority && authority.length) {
          out += "//" + authority;
        }
        out += path;
        if (query && query.length) {
          out += "?" + query;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
          return;
        }
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path = "";
        var port = "";
        var query = "";
        var fragment = "";
        var out = "";
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        if (!scheme)
          return;
        if (allowHttps) {
          if (scheme.toLowerCase() != "https")
            return;
        } else {
          if (scheme.toLowerCase() != "http")
            return;
        }
        if (!authority) {
          return;
        }
        if (/:(\d+)$/.test(authority)) {
          port = authority.match(/:(\d+)$/)[0];
          authority = authority.replace(/:\d+$/, "");
        }
        out += scheme + ":";
        out += "//" + authority;
        if (port) {
          out += port;
        }
        out += path;
        if (query && query.length) {
          out += "?" + query;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_https_iri(value) {
        return is_http_iri(value, true);
      }
      function is_web_iri(value) {
        return is_http_iri(value) || is_https_iri(value);
      }
    })(module2);
  }
});

// ../../node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "../../node_modules/delayed-stream/lib/delayed_stream.js"(exports, module2) {
    "use strict";
    var Stream = require("stream").Stream;
    var util2 = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util2.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// ../../node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "../../node_modules/combined-stream/lib/combined_stream.js"(exports, module2) {
    "use strict";
    var util2 = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util2.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream4) {
      return typeof stream4 !== "function" && typeof stream4 !== "string" && typeof stream4 !== "boolean" && typeof stream4 !== "number" && !Buffer.isBuffer(stream4);
    };
    CombinedStream.prototype.append = function(stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        if (!(stream4 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream4, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream4.on("data", this._checkDataSize.bind(this));
          stream4 = newStream;
        }
        this._handleErrors(stream4);
        if (this.pauseStreams) {
          stream4.pause();
        }
      }
      this._streams.push(stream4);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream4 = this._streams.shift();
      if (typeof stream4 == "undefined") {
        this.end();
        return;
      }
      if (typeof stream4 !== "function") {
        this._pipeNext(stream4);
        return;
      }
      var getStream = stream4;
      getStream(function(stream5) {
        var isStreamLike = CombinedStream.isStreamLike(stream5);
        if (isStreamLike) {
          stream5.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream5);
        }
        this._pipeNext(stream5);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream4) {
      this._currentStream = stream4;
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on("end", this._getNext.bind(this));
        stream4.pipe(this, { end: false });
        return;
      }
      var value = stream4;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream4) {
      var self2 = this;
      stream4.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream4) {
        if (!stream4.dataSize) {
          return;
        }
        self2.dataSize += stream4.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// ../../node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../node_modules/mime-db/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_db();
  }
});

// ../../node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// ../../node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "../../node_modules/asynckit/lib/defer.js"(exports, module2) {
    "use strict";
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// ../../node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "../../node_modules/asynckit/lib/async.js"(exports, module2) {
    "use strict";
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// ../../node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "../../node_modules/asynckit/lib/abort.js"(exports, module2) {
    "use strict";
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// ../../node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "../../node_modules/asynckit/lib/iterate.js"(exports, module2) {
    "use strict";
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// ../../node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "../../node_modules/asynckit/lib/state.js"(exports, module2) {
    "use strict";
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// ../../node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "../../node_modules/asynckit/lib/terminator.js"(exports, module2) {
    "use strict";
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// ../../node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "../../node_modules/asynckit/parallel.js"(exports, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// ../../node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "../../node_modules/asynckit/serialOrdered.js"(exports, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// ../../node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "../../node_modules/asynckit/serial.js"(exports, module2) {
    "use strict";
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// ../../node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "../../node_modules/asynckit/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// ../../node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "../../node_modules/form-data/lib/populate.js"(exports, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// ../../node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "../../node_modules/form-data/lib/form_data.js"(exports, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util2 = require("util");
    var path = require("path");
    var http2 = require("http");
    var https2 = require("https");
    var parseUrl = require("url").parse;
    var fs2 = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData3;
    util2.inherits(FormData3, CombinedStream);
    function FormData3(options) {
      if (!(this instanceof FormData3)) {
        return new FormData3(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData3.LINE_BREAK = "\r\n";
    FormData3.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData3.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append2 = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util2.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append2(header);
      append2(value);
      append2(footer);
      this._trackLength(header, value, options);
    };
    FormData3.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData3.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData3.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs2.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData3.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData3.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData3.LINE_BREAK + contents + FormData3.LINE_BREAK;
    };
    FormData3.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData3.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData3.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData3.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData3.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData3.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData3.LINE_BREAK;
    };
    FormData3.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData3.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData3.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData3.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData3.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData3.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData3.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData3.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData3.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData3.prototype.submit = function(params, cb) {
      var request, options, defaults2 = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults2);
      } else {
        options = populate(params, defaults2);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https2.request(options);
      } else {
        request = http2.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData3.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData3.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// ../../node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "../../node_modules/proxy-from-env/index.js"(exports) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl2(url2) {
      var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports.getProxyForUrl = getProxyForUrl2;
  }
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/ms/index.js"(exports, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "../../node_modules/debug/src/common.js"(exports, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports, module2) {
    "use strict";
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common2()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/supports-color/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/supports-color/node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os2 = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream4) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream4 && !stream4.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream4) {
      const level = supportsColor(stream4);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// ../../node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "../../node_modules/debug/src/node.js"(exports, module2) {
    "use strict";
    var tty = require("tty");
    var util2 = require("util");
    exports.init = init2;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../node_modules/debug/src/index.js"(exports, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  }
});

// ../../node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../../node_modules/follow-redirects/debug.js"(exports, module2) {
    "use strict";
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// ../../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../../node_modules/follow-redirects/index.js"(exports, module2) {
    "use strict";
    var url2 = require("url");
    var URL2 = url2.URL;
    var http2 = require("http");
    var https2 = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer2(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction2(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url2.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url2.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
        return;
      }
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url2.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction2(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
      }
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isString2(input)) {
            var parsed;
            try {
              parsed = urlToOptions(new URL2(input));
            } catch (err) {
              parsed = url2.parse(input);
            }
            if (!isString2(parsed.protocol)) {
              throw new InvalidUrlError({ input });
            }
            input = parsed;
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (isFunction2(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString2(options.host) && !isString2(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop2() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? (
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1)
        ) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      return CustomError;
    }
    function abortRequest(request) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop2);
      request.abort();
    }
    function isSubdomain(subdomain, domain) {
      assert(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction2(value) {
      return typeof value === "function";
    }
    function isBuffer2(value) {
      return typeof value === "object" && "length" in value;
    }
    module2.exports = wrap({ http: http2, https: https2 });
    module2.exports.wrap = wrap;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CountryIdentityProvider: () => CountryIdentityProvider,
  LogInWithCountryIdentity: () => LogInWithCountryIdentity,
  Proof: () => Proof2,
  useCountryIdentity: () => useCountryIdentity
});
module.exports = __toCommonJS(src_exports);

// src/components/LogInWithCountryIdentityButton.tsx
var import_react5 = require("react");

// src/components/ProveModal.tsx
var import_react4 = require("react");
var import_styled_components4 = __toESM(require("styled-components"));

// src/components/UploadButton.tsx
var import_styled_components = __toESM(require("styled-components"));
var import_jsx_runtime = require("react/jsx-runtime");
var FileInput = ({ onChange }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputFile, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", { type: "file", onChange }) });
};
var InputFile = import_styled_components.default.div`
  border-radius: 0.5rem;
  border-width: 1px;
  border-color: #d1d5db;
  padding: 5px;
  width: 100%;
  font-size: 0.875rem;
  line-height: 1.25rem;
  color: #111827;
  background-color: #f9fafb;
  cursor: pointer;
  padding-top: 10px;
  padding-bottom: 10px;
`;

// src/components/ProveButton.tsx
var import_pcd_types = require("@pcd/pcd-types");
var import_styled_components3 = __toESM(require("styled-components"));
var import_react3 = require("react");

// src/hooks/useCountryIdentity.ts
var import_react = require("react");
function useCountryIdentity() {
  const val = (0, import_react.useContext)(CountryIdentityContext);
  return [val.state, val.startReq];
}
var CountryIdentityContext = (0, import_react.createContext)({
  state: { status: "logged-out" },
  startReq: () => {
  }
});

// src/components/LoadingSpinner.tsx
var import_react2 = require("react");
var import_styled_components2 = __toESM(require("styled-components"));
var import_jsx_runtime2 = require("react/jsx-runtime");
var Spinner = () => {
  const emojis = ["\u{1F30E}", "\u{1F30D}", "\u{1F30F}"];
  const [currentEmojiIndex, setCurrentEmojiIndex] = (0, import_react2.useState)(0);
  (0, import_react2.useEffect)(() => {
    const interval = setInterval(() => {
      setCurrentEmojiIndex((prevIndex) => (prevIndex + 1) % emojis.length);
    }, 200);
    return () => clearInterval(interval);
  }, [emojis.length]);
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(SpinnerStyle, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Emoji, { children: emojis[currentEmojiIndex] }) });
};
var SpinnerStyle = import_styled_components2.default.div`
  font-size: 1rem; /* Adjust the font size to make the emoji bigger */
  display: flex;
  justify-content: center;
  align-items: center;
`;
var Emoji = import_styled_components2.default.div`
  transition: transform 0.25s ease-in-out;
`;

// src/components/ProveButton.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
var ProveButton = ({
  msgBigInt,
  modulusBigInt,
  sigBigInt,
  signatureValidity
}) => {
  const { state, startReq } = (0, import_react3.useContext)(CountryIdentityContext);
  const args = {
    base_message: {
      argumentType: import_pcd_types.ArgumentTypeName.BigInt,
      userProvided: false,
      value: msgBigInt == null ? void 0 : msgBigInt.toString(),
      description: ""
    },
    signature: {
      argumentType: import_pcd_types.ArgumentTypeName.BigInt,
      userProvided: false,
      value: sigBigInt == null ? void 0 : sigBigInt.toString(),
      description: ""
    },
    modulus: {
      argumentType: import_pcd_types.ArgumentTypeName.BigInt,
      userProvided: false,
      value: modulusBigInt == null ? void 0 : modulusBigInt.toString(),
      description: ""
    }
  };
  return (() => {
    switch (state.status) {
      case "logged-out":
        return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          Btn,
          {
            disabled: !(signatureValidity == "Signature looks valid \u2705" /* SIGNATURE_VALID */),
            onClick: () => {
              startReq({ type: "login", args });
            },
            children: "Request Identity Proof"
          }
        );
      case "logging-in":
        return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(Btn, { children: [
          "Generating proof...",
          "\u2003",
          /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Spinner, {})
        ] });
    }
  })();
};
var Btn = import_styled_components3.default.button`
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0.5rem 1rem;
  font-size: 1rem;
  cursor: pointer;
  color: #f8f8f8;
  font-weight: bold;
  box-shadow: 0px 0.25rem 0.75rem rgba(0, 0, 0, 0.1);
  border: none;
  min-width: 12rem;
  min-height: 3rem;
  border-radius: 0.5rem;
  background: linear-gradient(345deg, #10fe53 0%, #09d3ff 100%);

  &:hover {
    opacity: 70%;
    background: linear-gradient(345deg, #10fe53 0%, #09d3ff 100%);
  }

  &:active {
    background: #f8f8f8;
  }

  &:disabled {
    color: #a8aaaf;
    background: #e8e8e8;
    cursor: default;
  }
`;

// src/util.ts
var peculiarX509 = __toESM(require("@peculiar/x509"));
var forge = __toESM(require("node-forge"));
var pdfUpload = (e4, setpdfStatus, setsignatureValidity) => {
  return new Promise((resolve, reject) => {
    if (e4.target.files) {
      try {
        const fileReader = new FileReader();
        fileReader.readAsBinaryString(e4.target.files[0]);
        fileReader.onload = (e5) => {
          if (e5.target) {
            try {
              const { signedData, signature } = extractSignature(
                Buffer.from(e5.target.result, "binary")
              );
              if (signature != "") {
                resolve({
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  signature: forge.asn1.fromDer(signature).value,
                  signedData
                });
                setpdfStatus("Signature detected \u2705" /* SIGNATURE_PRESENT */);
              } else {
                setpdfStatus("Signature not detected in document \u274C" /* SIGNATURE_NOT_PRESENT */);
              }
            } catch (error) {
              setpdfStatus(".pdf document invalid \u274C" /* ERROR_PARSING_PDF */);
              reject(error);
            }
          }
        };
      } catch {
        setpdfStatus("");
        setsignatureValidity("");
        reject();
      }
    }
  });
};
var extractSignature = (pdf, signaturePosition = 1) => {
  const byteRangePos = getSubstringIndex(pdf, "/ByteRange [", signaturePosition);
  const byteRangeEnd = pdf.indexOf("]", byteRangePos);
  const byteRange = pdf.subarray(byteRangePos, byteRangeEnd + 1).toString();
  const matches = /\/ByteRange \[(\d+) +(\d+) +(\d+) +(\d+) *\]/.exec(byteRange);
  if (matches == null) {
    return {
      ByteRange: [0],
      signature: "",
      signedData: Buffer.from([])
    };
  } else {
    const ByteRange = matches.slice(1).map(Number);
    const signedData = Buffer.concat([
      pdf.subarray(ByteRange[0], ByteRange[0] + ByteRange[1]),
      pdf.subarray(ByteRange[2], ByteRange[2] + ByteRange[3])
    ]);
    const signatureHex = pdf.subarray(ByteRange[0] + ByteRange[1] + 1, ByteRange[2]).toString("binary").replace(/(?:00|>)+$/, "");
    const signature = Buffer.from(signatureHex, "hex").toString("binary");
    return {
      ByteRange: matches.slice(1, 5).map(Number),
      signature,
      signedData
    };
  }
};
var getSubstringIndex = (str, substring, n) => {
  let times = 0;
  let index = 0;
  while (times < n && index !== -1) {
    index = str.indexOf(substring, index + 1);
    times += 1;
  }
  return index;
};
var cerUpload = async (e4, signedPdfData, signature, pdfStatus, setcertificateStatus, setsignatureValidity) => {
  return new Promise((resolve, reject) => {
    if (e4.target.files) {
      try {
        const fileReader = new FileReader();
        fileReader.readAsArrayBuffer(e4.target.files[0]);
        fileReader.onload = (e5) => {
          if (e5.target && pdfStatus == "Signature detected \u2705" /* SIGNATURE_PRESENT */) {
            try {
              const cer = new peculiarX509.X509Certificate(
                e5.target.result
              );
              const cert = forge.pki.certificateFromPem(
                cer.toString("pem")
              );
              const md2 = forge.md.sha1.create();
              md2.update(signedPdfData.toString("binary"));
              const decryptData = Buffer.from(
                cert.publicKey.encrypt(signature, "RAW"),
                "binary"
              );
              const hash = Buffer.from(md2.digest().bytes(), "binary");
              const isValid = Buffer.compare(decryptData.subarray(236, 256), hash) === 0;
              if (isValid) {
                const msgBigInt = BigInt("0x" + hash.toString("hex"));
                const sigBigInt = BigInt(
                  "0x" + Buffer.from(signature, "binary").toString("hex")
                );
                const modulusBigInt = BigInt(
                  "0x" + cert.publicKey.n.toString(16)
                );
                setsignatureValidity("Signature looks valid \u2705" /* SIGNATURE_VALID */);
                setcertificateStatus(
                  "Certificate correctly parsed \u2705" /* CERTIFICATE_CORRECTLY_FORMATTED */
                );
                resolve({ msgBigInt, sigBigInt, modulusBigInt });
              } else {
                setsignatureValidity(
                  "Signature looks invalid \u274C" /* SIGNATURE_INVALID */
                );
                setcertificateStatus(
                  "Certificate correctly parsed \u2705" /* CERTIFICATE_CORRECTLY_FORMATTED */
                );
                reject();
              }
            } catch (error) {
              setsignatureValidity("Signature looks invalid \u274C" /* SIGNATURE_INVALID */);
              setcertificateStatus(
                ".cer document invalid \u274C" /* ERROR_PARSING_CERTIFICATE */
              );
              reject();
            }
          } else {
            setcertificateStatus("No pdf document uploaded" /* NO_PDF_UPLOADED */);
            reject();
          }
        };
      } catch (error) {
        setsignatureValidity("Signature looks invalid \u274C" /* SIGNATURE_INVALID */);
        setcertificateStatus("");
        reject();
      }
    }
  });
};
function text(emoji, text2) {
  const msp = "\u2003";
  return `${emoji}${msp}${text2}`;
}

// src/components/ProveModal.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
var Modal = ({ isOpen, onClose }) => {
  const [signedPdfData, setSignedPdfData] = (0, import_react4.useState)(Buffer.from([]));
  const [signature, setSignature] = (0, import_react4.useState)("");
  const [msgBigInt, setMsgBigInt] = (0, import_react4.useState)();
  const [sigBigInt, setSigBigInt] = (0, import_react4.useState)();
  const [modulusBigInt, setModulusBigInt] = (0, import_react4.useState)();
  const [pdfStatus, setpdfStatus] = (0, import_react4.useState)("");
  const [signatureValidity, setsignatureValidity] = (0, import_react4.useState)("");
  const [certificateStatus, setcertificateStatus] = (0, import_react4.useState)("");
  const certificateOrSignatureStatus = certificateStatus == ".cer document invalid \u274C" /* ERROR_PARSING_CERTIFICATE */ || certificateStatus == "" || certificateStatus == "No pdf document uploaded" /* NO_PDF_UPLOADED */ ? certificateStatus : signatureValidity;
  const handlePdfChange = async (e4) => {
    const { signature: signature2, signedData } = await pdfUpload(
      e4,
      setpdfStatus,
      setsignatureValidity
    );
    setSignature(signature2);
    setSignedPdfData(signedData);
  };
  const handleCerUpload = async (e4) => {
    const { msgBigInt: msgBigInt2, sigBigInt: sigBigInt2, modulusBigInt: modulusBigInt2 } = await cerUpload(
      e4,
      signedPdfData,
      signature,
      pdfStatus,
      setcertificateStatus,
      setsignatureValidity
    );
    setMsgBigInt(msgBigInt2);
    setSigBigInt(sigBigInt2);
    setModulusBigInt(modulusBigInt2);
  };
  return isOpen ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ModalOverlay, { onClick: onClose, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(ModalContent, { onClick: (e4) => e4.stopPropagation(), children: [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(TitleSection, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("p", { children: "Prove your Identity with your Aadhar card" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(UploadSection, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(UploadFile, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Label, { children: "Upload your Aadhaar card pdf" }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(FileInput, { onChange: handlePdfChange }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(DocumentResult, { children: pdfStatus })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(UploadFile, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Label, { children: "Upload your Aadhaar card certification" }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(FileInput, { onChange: handleCerUpload }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(DocumentResult, { children: certificateOrSignatureStatus })
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      ProveButton,
      {
        sigBigInt,
        modulusBigInt,
        msgBigInt,
        signatureValidity
      }
    )
  ] }) }) : null;
};
var ModalOverlay = import_styled_components4.default.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.2); /* Low opacity gray */
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999; /* Ensure the modal appears on top of other elements */
`;
var ModalContent = import_styled_components4.default.div`
  /* Modal styles common to both desktop and mobile */
  position: fixed;
  display: flex;
  flex-direction: column;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #ffffff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
  justify-content: space-between;

  /* Responsive styles */
  @media (max-width: 768px) {
    /* For screens <= 768px (e.g., mobile devices) */
    width: 100%;
    height: 60%;
    max-width: 100%;
    max-height: 100%;
  }

  @media (min-width: 769px) {
    /* For screens > 768px (e.g., desktop) */
    min-height: 400px;
    width: 80%; /* Adjust the percentage as needed */
    max-width: 400px; /* Set a maximum width for desktop */
  }
`;
var UploadFile = import_styled_components4.default.div`
  margin-top: 10px;
  margin-bottom: 10px;
`;
var DocumentResult = import_styled_components4.default.div`
  position: absolute;
  font-size: 0.875rem;
  margin-top: 4px;
`;
var TitleSection = import_styled_components4.default.div`
  flex-shrink: 0;
  margin-left: auto;
  margin-right: auto;
  font-size: medium;
  font-weight: bold;
`;
var UploadSection = import_styled_components4.default.div`
  display: grid;
  row-gap: 20px;
`;
var Label = import_styled_components4.default.div`
  margin-bottom: 0.5rem;
  line-height: 1.25rem;
  font-weight: 500;
  color: #111827;
`;

// src/components/LogInWithCountryIdentityButton.tsx
var import_styled_components5 = __toESM(require("styled-components"));
var import_react6 = require("react");
var import_jsx_runtime5 = require("react/jsx-runtime");
var LogInWithCountryIdentity = () => {
  const [isModalOpen, setIsModalOpen] = (0, import_react5.useState)(false);
  const { state, startReq } = (0, import_react6.useContext)(CountryIdentityContext);
  (0, import_react6.useEffect)(() => {
    if (state.status === "logged-in")
      setIsModalOpen(false);
  }, [state]);
  const openModal = () => {
    setIsModalOpen(true);
  };
  const closeModal = () => {
    setIsModalOpen(false);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
    (state.status === "logged-out" || state.status === "logging-in") && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Btn2, { onClick: openModal, children: text("\u{1F30F}", "Log In with Country Identity") }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Modal, { isOpen: isModalOpen, onClose: closeModal })
    ] }),
    state.status === "logged-in" && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Btn2, { onClick: () => startReq({ type: "logout" }), children: text("\u{1F30F}", "Log Out") }) })
  ] });
};
var Btn2 = import_styled_components5.default.button`
  padding: 0.5rem 1rem;
  font-size: 1rem;
  cursor: pointer;
  color: #000000;
  font-weight: bold;
  border-radius: 1.3125rem;
  background: #fff;
  box-shadow: 0px 3px 8px 1px rgba(0, 0, 0, 0.25);
  border: none;
  min-width: 12rem;
  min-height: 3rem;
  border-radius: 0.5rem;

  &:hover {
    background: #fafafa;
  }

  &:active {
    background: #f8f8f8;
  }

  &:disabled {
    color: #a8aaaf;
    background: #e8e8e8;
    cursor: default;
  }
`;

// src/provider/countryIdentityProvider.tsx
var import_react7 = require("react");
var import_pcd_country_identity = require("pcd-country-identity");
var import_react8 = __toESM(require("react"));

// ../pcd-country-identity/src/types.ts
var IdentityPCDTypeName = "identity-pcd";

// ../../node_modules/uuid/dist/esm-node/rng.js
var import_crypto = __toESM(require("crypto"));
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// ../../node_modules/uuid/dist/esm-node/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// ../../node_modules/uuid/dist/esm-node/native.js
var import_crypto2 = __toESM(require("crypto"));
var native_default = {
  randomUUID: import_crypto2.default.randomUUID
};

// ../../node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../../node_modules/snarkjs/src/groth16.js
var groth16_exports = {};
__export(groth16_exports, {
  exportSolidityCallData: () => groth16ExportSolidityCallData,
  fullProve: () => groth16FullProve,
  prove: () => groth16Prove,
  verify: () => groth16Verify
});

// ../../node_modules/@iden3/binfileutils/node_modules/ffjavascript/src/scalar.js
var scalar_exports = {};
__export(scalar_exports, {
  abs: () => abs,
  add: () => add,
  band: () => band,
  bitLength: () => bitLength,
  bits: () => bits,
  bor: () => bor,
  bxor: () => bxor,
  div: () => div,
  e: () => e,
  eq: () => eq,
  exp: () => exp,
  fromArray: () => fromArray,
  fromRprBE: () => fromRprBE,
  fromRprLE: () => fromRprLE,
  fromString: () => fromString,
  geq: () => geq,
  gt: () => gt,
  isNegative: () => isNegative,
  isOdd: () => isOdd,
  isZero: () => isZero,
  land: () => land,
  leq: () => leq,
  lnot: () => lnot,
  lor: () => lor,
  lt: () => lt,
  mod: () => mod,
  mul: () => mul,
  naf: () => naf,
  neg: () => neg,
  neq: () => neq,
  one: () => one,
  pow: () => pow,
  shiftLeft: () => shiftLeft,
  shiftRight: () => shiftRight,
  shl: () => shl,
  shr: () => shr,
  square: () => square,
  sub: () => sub,
  toArray: () => toArray,
  toLEBuff: () => toLEBuff,
  toNumber: () => toNumber,
  toRprBE: () => toRprBE,
  toRprLE: () => toRprLE,
  toString: () => toString,
  zero: () => zero
});
var hexLen = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];
function fromString(s, radix) {
  if (!radix || radix == 10) {
    return BigInt(s);
  } else if (radix == 16) {
    if (s.slice(0, 2) == "0x") {
      return BigInt(s);
    } else {
      return BigInt("0x" + s);
    }
  }
}
var e = fromString;
function fromArray(a, radix) {
  let acc = BigInt(0);
  radix = BigInt(radix);
  for (let i = 0; i < a.length; i++) {
    acc = acc * radix + BigInt(a[i]);
  }
  return acc;
}
function bitLength(a) {
  const aS = a.toString(16);
  return (aS.length - 1) * 4 + hexLen[parseInt(aS[0], 16)];
}
function isNegative(a) {
  return BigInt(a) < BigInt(0);
}
function isZero(a) {
  return !a;
}
function shiftLeft(a, n) {
  return BigInt(a) << BigInt(n);
}
function shiftRight(a, n) {
  return BigInt(a) >> BigInt(n);
}
var shl = shiftLeft;
var shr = shiftRight;
function isOdd(a) {
  return (BigInt(a) & BigInt(1)) == BigInt(1);
}
function naf(n) {
  let E = BigInt(n);
  const res = [];
  while (E) {
    if (E & BigInt(1)) {
      const z = 2 - Number(E % BigInt(4));
      res.push(z);
      E = E - BigInt(z);
    } else {
      res.push(0);
    }
    E = E >> BigInt(1);
  }
  return res;
}
function bits(n) {
  let E = BigInt(n);
  const res = [];
  while (E) {
    if (E & BigInt(1)) {
      res.push(1);
    } else {
      res.push(0);
    }
    E = E >> BigInt(1);
  }
  return res;
}
function toNumber(s) {
  if (s > BigInt(Number.MAX_SAFE_INTEGER)) {
    throw new Error("Number too big");
  }
  return Number(s);
}
function toArray(s, radix) {
  const res = [];
  let rem = BigInt(s);
  radix = BigInt(radix);
  while (rem) {
    res.unshift(Number(rem % radix));
    rem = rem / radix;
  }
  return res;
}
function add(a, b) {
  return BigInt(a) + BigInt(b);
}
function sub(a, b) {
  return BigInt(a) - BigInt(b);
}
function neg(a) {
  return -BigInt(a);
}
function mul(a, b) {
  return BigInt(a) * BigInt(b);
}
function square(a) {
  return BigInt(a) * BigInt(a);
}
function pow(a, b) {
  return BigInt(a) ** BigInt(b);
}
function exp(a, b) {
  return BigInt(a) ** BigInt(b);
}
function abs(a) {
  return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);
}
function div(a, b) {
  return BigInt(a) / BigInt(b);
}
function mod(a, b) {
  return BigInt(a) % BigInt(b);
}
function eq(a, b) {
  return BigInt(a) == BigInt(b);
}
function neq(a, b) {
  return BigInt(a) != BigInt(b);
}
function lt(a, b) {
  return BigInt(a) < BigInt(b);
}
function gt(a, b) {
  return BigInt(a) > BigInt(b);
}
function leq(a, b) {
  return BigInt(a) <= BigInt(b);
}
function geq(a, b) {
  return BigInt(a) >= BigInt(b);
}
function band(a, b) {
  return BigInt(a) & BigInt(b);
}
function bor(a, b) {
  return BigInt(a) | BigInt(b);
}
function bxor(a, b) {
  return BigInt(a) ^ BigInt(b);
}
function land(a, b) {
  return BigInt(a) && BigInt(b);
}
function lor(a, b) {
  return BigInt(a) || BigInt(b);
}
function lnot(a) {
  return !BigInt(a);
}
function toRprLE(buff, o, e4, n8) {
  const s = "0000000" + e4.toString(16);
  const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8 / 4);
  const l = ((s.length - 7) * 4 - 1 >> 5) + 1;
  for (let i = 0; i < l; i++)
    v[i] = parseInt(s.substring(s.length - 8 * i - 8, s.length - 8 * i), 16);
  for (let i = l; i < v.length; i++)
    v[i] = 0;
  for (let i = v.length * 4; i < n8; i++)
    buff[i] = toNumber(band(shiftRight(e4, i * 8), 255));
}
function toRprBE(buff, o, e4, n8) {
  const s = "0000000" + e4.toString(16);
  const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
  const l = ((s.length - 7) * 4 - 1 >> 5) + 1;
  for (let i = 0; i < l; i++)
    v.setUint32(n8 - i * 4 - 4, parseInt(s.substring(s.length - 8 * i - 8, s.length - 8 * i), 16), false);
  for (let i = 0; i < n8 / 4 - l; i++)
    v[i] = 0;
}
function fromRprLE(buff, o, n8) {
  n8 = n8 || buff.byteLength;
  o = o || 0;
  const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8 / 4);
  const a = new Array(n8 / 4);
  v.forEach((ch, i) => a[a.length - i - 1] = ch.toString(16).padStart(8, "0"));
  return fromString(a.join(""), 16);
}
function fromRprBE(buff, o, n8) {
  n8 = n8 || buff.byteLength;
  o = o || 0;
  const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
  const a = new Array(n8 / 4);
  for (let i = 0; i < n8 / 4; i++) {
    a[i] = v.getUint32(i * 4, false).toString(16).padStart(8, "0");
  }
  return fromString(a.join(""), 16);
}
function toString(a, radix) {
  return a.toString(radix);
}
function toLEBuff(a) {
  const buff = new Uint8Array(Math.floor((bitLength(a) - 1) / 8) + 1);
  toRprLE(buff, 0, a, buff.byteLength);
  return buff;
}
var zero = e(0);
var one = e(1);

// ../../node_modules/@iden3/binfileutils/node_modules/ffjavascript/src/polfield.js
var _revTable = [];
for (let i = 0; i < 256; i++) {
  _revTable[i] = _revSlow(i, 8);
}
function _revSlow(idx, bits4) {
  let res = 0;
  let a = idx;
  for (let i = 0; i < bits4; i++) {
    res <<= 1;
    res = res | a & 1;
    a >>= 1;
  }
  return res;
}

// ../../node_modules/@iden3/binfileutils/node_modules/ffjavascript/src/bn128.js
var import_wasmcurves = __toESM(require_wasmcurves(), 1);

// ../../node_modules/@iden3/binfileutils/node_modules/ffjavascript/src/utils.js
var _revTable2 = [];
for (let i = 0; i < 256; i++) {
  _revTable2[i] = _revSlow2(i, 8);
}
function _revSlow2(idx, bits4) {
  let res = 0;
  let a = idx;
  for (let i = 0; i < bits4; i++) {
    res <<= 1;
    res = res | a & 1;
    a >>= 1;
  }
  return res;
}

// ../../node_modules/@iden3/binfileutils/node_modules/ffjavascript/src/bigbuffer.js
var PAGE_SIZE = 1 << 30;
var BigBuffer = class _BigBuffer {
  constructor(size) {
    this.buffers = [];
    this.byteLength = size;
    for (let i = 0; i < size; i += PAGE_SIZE) {
      const n = Math.min(size - i, PAGE_SIZE);
      this.buffers.push(new Uint8Array(n));
    }
  }
  slice(fr, to) {
    if (to === void 0)
      to = this.byteLength;
    if (fr === void 0)
      fr = 0;
    const len = to - fr;
    const firstPage = Math.floor(fr / PAGE_SIZE);
    const lastPage = Math.floor((fr + len - 1) / PAGE_SIZE);
    if (firstPage == lastPage || len == 0)
      return this.buffers[firstPage].slice(fr % PAGE_SIZE, fr % PAGE_SIZE + len);
    let buff;
    let p = firstPage;
    let o = fr % PAGE_SIZE;
    let r = len;
    while (r > 0) {
      const l = o + r > PAGE_SIZE ? PAGE_SIZE - o : r;
      const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);
      if (l == len)
        return srcView.slice();
      if (!buff) {
        if (len <= PAGE_SIZE) {
          buff = new Uint8Array(len);
        } else {
          buff = new _BigBuffer(len);
        }
      }
      buff.set(srcView, len - r);
      r = r - l;
      p++;
      o = 0;
    }
    return buff;
  }
  set(buff, offset) {
    if (offset === void 0)
      offset = 0;
    const len = buff.byteLength;
    if (len == 0)
      return;
    const firstPage = Math.floor(offset / PAGE_SIZE);
    const lastPage = Math.floor((offset + len - 1) / PAGE_SIZE);
    if (firstPage == lastPage) {
      if (buff instanceof _BigBuffer && buff.buffers.length == 1) {
        return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);
      } else {
        return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);
      }
    }
    let p = firstPage;
    let o = offset % PAGE_SIZE;
    let r = len;
    while (r > 0) {
      const l = o + r > PAGE_SIZE ? PAGE_SIZE - o : r;
      const srcView = buff.slice(len - r, len - r + l);
      const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);
      dstView.set(srcView);
      r = r - l;
      p++;
      o = 0;
    }
  }
};

// ../../node_modules/@iden3/binfileutils/node_modules/ffjavascript/src/threadman_thread.js
function thread(self2) {
  const MAXMEM = 32767;
  let instance;
  let memory;
  if (self2) {
    self2.onmessage = function(e4) {
      let data;
      if (e4.data) {
        data = e4.data;
      } else {
        data = e4;
      }
      if (data[0].cmd == "INIT") {
        init2(data[0]).then(function() {
          self2.postMessage(data.result);
        });
      } else if (data[0].cmd == "TERMINATE") {
        self2.close();
      } else {
        const res = runTask(data);
        self2.postMessage(res);
      }
    };
  }
  async function init2(data) {
    const code = new Uint8Array(data.code);
    const wasmModule = await WebAssembly.compile(code);
    memory = new WebAssembly.Memory({ initial: data.init, maximum: MAXMEM });
    instance = await WebAssembly.instantiate(wasmModule, {
      env: {
        "memory": memory
      }
    });
  }
  function alloc(length) {
    const u322 = new Uint32Array(memory.buffer, 0, 1);
    while (u322[0] & 3)
      u322[0]++;
    const res = u322[0];
    u322[0] += length;
    if (u322[0] + length > memory.buffer.byteLength) {
      const currentPages = memory.buffer.byteLength / 65536;
      let requiredPages = Math.floor((u322[0] + length) / 65536) + 1;
      if (requiredPages > MAXMEM)
        requiredPages = MAXMEM;
      memory.grow(requiredPages - currentPages);
    }
    return res;
  }
  function allocBuffer(buffer) {
    const p = alloc(buffer.byteLength);
    setBuffer(p, buffer);
    return p;
  }
  function getBuffer(pointer, length) {
    const u8 = new Uint8Array(memory.buffer);
    return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);
  }
  function setBuffer(pointer, buffer) {
    const u8 = new Uint8Array(memory.buffer);
    u8.set(new Uint8Array(buffer), pointer);
  }
  function runTask(task) {
    if (task[0].cmd == "INIT") {
      return init2(task[0]);
    }
    const ctx = {
      vars: [],
      out: []
    };
    const u32a = new Uint32Array(memory.buffer, 0, 1);
    const oldAlloc = u32a[0];
    for (let i = 0; i < task.length; i++) {
      switch (task[i].cmd) {
        case "ALLOCSET":
          ctx.vars[task[i].var] = allocBuffer(task[i].buff);
          break;
        case "ALLOC":
          ctx.vars[task[i].var] = alloc(task[i].len);
          break;
        case "SET":
          setBuffer(ctx.vars[task[i].var], task[i].buff);
          break;
        case "CALL": {
          const params = [];
          for (let j = 0; j < task[i].params.length; j++) {
            const p = task[i].params[j];
            if (typeof p.var !== "undefined") {
              params.push(ctx.vars[p.var] + (p.offset || 0));
            } else if (typeof p.val != "undefined") {
              params.push(p.val);
            }
          }
          instance.exports[task[i].fnName](...params);
          break;
        }
        case "GET":
          ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();
          break;
        default:
          throw new Error("Invalid cmd");
      }
    }
    const u32b = new Uint32Array(memory.buffer, 0, 1);
    u32b[0] = oldAlloc;
    return ctx.out;
  }
  return runTask;
}

// ../../node_modules/@iden3/binfileutils/node_modules/ffjavascript/src/threadman.js
var import_web_worker = __toESM(require_node(), 1);
function stringToBase64(str) {
  if (process.browser) {
    return globalThis.btoa(str);
  } else {
    return Buffer.from(str).toString("base64");
  }
}
var threadSource = stringToBase64("(" + thread.toString() + ")(self)");
var workerSource = "data:application/javascript;base64," + threadSource;

// ../../node_modules/wasmbuilder/src/utils.js
function toNumber2(n) {
  return BigInt(n);
}
function isNegative2(n) {
  return n < 0n;
}
function isZero2(n) {
  return n === 0n;
}
function bitLength2(n) {
  if (isNegative2(n)) {
    return n.toString(2).length - 1;
  } else {
    return n.toString(2).length;
  }
}
function u32(n) {
  const b = [];
  const v = toNumber2(n);
  b.push(Number(v & 0xFFn));
  b.push(Number(v >> 8n & 0xFFn));
  b.push(Number(v >> 16n & 0xFFn));
  b.push(Number(v >> 24n & 0xFFn));
  return b;
}
function toUTF8Array(str) {
  var utf8 = [];
  for (var i = 0; i < str.length; i++) {
    var charcode = str.charCodeAt(i);
    if (charcode < 128)
      utf8.push(charcode);
    else if (charcode < 2048) {
      utf8.push(
        192 | charcode >> 6,
        128 | charcode & 63
      );
    } else if (charcode < 55296 || charcode >= 57344) {
      utf8.push(
        224 | charcode >> 12,
        128 | charcode >> 6 & 63,
        128 | charcode & 63
      );
    } else {
      i++;
      charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
      utf8.push(
        240 | charcode >> 18,
        128 | charcode >> 12 & 63,
        128 | charcode >> 6 & 63,
        128 | charcode & 63
      );
    }
  }
  return utf8;
}
function string(str) {
  const bytes = toUTF8Array(str);
  return [...varuint32(bytes.length), ...bytes];
}
function varuint(n) {
  const code = [];
  let v = toNumber2(n);
  if (isNegative2(v))
    throw new Error("Number cannot be negative");
  while (!isZero2(v)) {
    code.push(Number(v & 0x7Fn));
    v = v >> 7n;
  }
  if (code.length == 0)
    code.push(0);
  for (let i = 0; i < code.length - 1; i++) {
    code[i] = code[i] | 128;
  }
  return code;
}
function varint(_n) {
  let n, sign;
  const bits4 = bitLength2(_n);
  if (_n < 0) {
    sign = true;
    n = (1n << BigInt(bits4)) + _n;
  } else {
    sign = false;
    n = toNumber2(_n);
  }
  const paddingBits = 7 - bits4 % 7;
  const padding = (1n << BigInt(paddingBits)) - 1n << BigInt(bits4);
  const paddingMask = (1 << 7 - paddingBits) - 1 | 128;
  const code = varuint(n + padding);
  if (!sign) {
    code[code.length - 1] = code[code.length - 1] & paddingMask;
  }
  return code;
}
function varint32(n) {
  let v = toNumber2(n);
  if (v > 0xFFFFFFFFn)
    throw new Error("Number too big");
  if (v > 0x7FFFFFFFn)
    v = v - 0x100000000n;
  if (v < -2147483648n)
    throw new Error("Number too small");
  return varint(v);
}
function varint64(n) {
  let v = toNumber2(n);
  if (v > 0xFFFFFFFFFFFFFFFFn)
    throw new Error("Number too big");
  if (v > 0x7FFFFFFFFFFFFFFFn)
    v = v - 0x10000000000000000n;
  if (v < -9223372036854775808n)
    throw new Error("Number too small");
  return varint(v);
}
function varuint32(n) {
  let v = toNumber2(n);
  if (v > 0xFFFFFFFFn)
    throw new Error("Number too big");
  return varuint(v);
}
function toHexString(byteArray) {
  return Array.from(byteArray, function(byte) {
    return ("0" + (byte & 255).toString(16)).slice(-2);
  }).join("");
}

// ../../node_modules/wasmbuilder/src/codebuilder.js
var CodeBuilder = class {
  constructor(func) {
    this.func = func;
    this.functionName = func.functionName;
    this.module = func.module;
  }
  setLocal(localName, valCode) {
    const idx = this.func.localIdxByName[localName];
    if (idx === void 0)
      throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
    return [...valCode, 33, ...varuint32(idx)];
  }
  teeLocal(localName, valCode) {
    const idx = this.func.localIdxByName[localName];
    if (idx === void 0)
      throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
    return [...valCode, 34, ...varuint32(idx)];
  }
  getLocal(localName) {
    const idx = this.func.localIdxByName[localName];
    if (idx === void 0)
      throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
    return [32, ...varuint32(idx)];
  }
  i64_load8_s(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 0 : _align;
    return [...idxCode, 48, align, ...varuint32(offset)];
  }
  i64_load8_u(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 0 : _align;
    return [...idxCode, 49, align, ...varuint32(offset)];
  }
  i64_load16_s(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 1 : _align;
    return [...idxCode, 50, align, ...varuint32(offset)];
  }
  i64_load16_u(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 1 : _align;
    return [...idxCode, 51, align, ...varuint32(offset)];
  }
  i64_load32_s(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 2 : _align;
    return [...idxCode, 52, align, ...varuint32(offset)];
  }
  i64_load32_u(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 2 : _align;
    return [...idxCode, 53, align, ...varuint32(offset)];
  }
  i64_load(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 3 : _align;
    return [...idxCode, 41, align, ...varuint32(offset)];
  }
  i64_store(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 3;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 3;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 55, align, ...varuint32(offset)];
  }
  i64_store32(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 2;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 2;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 62, align, ...varuint32(offset)];
  }
  i64_store16(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 1;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 1;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 61, align, ...varuint32(offset)];
  }
  i64_store8(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 0;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 0;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 60, align, ...varuint32(offset)];
  }
  i32_load8_s(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 0 : _align;
    return [...idxCode, 44, align, ...varuint32(offset)];
  }
  i32_load8_u(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 0 : _align;
    return [...idxCode, 45, align, ...varuint32(offset)];
  }
  i32_load16_s(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 1 : _align;
    return [...idxCode, 46, align, ...varuint32(offset)];
  }
  i32_load16_u(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 1 : _align;
    return [...idxCode, 47, align, ...varuint32(offset)];
  }
  i32_load(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 2 : _align;
    return [...idxCode, 40, align, ...varuint32(offset)];
  }
  i32_store(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 2;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 2;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 54, align, ...varuint32(offset)];
  }
  i32_store16(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 1;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 1;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 59, align, ...varuint32(offset)];
  }
  i32_store8(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 0;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 0;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 58, align, ...varuint32(offset)];
  }
  call(fnName, ...args) {
    const idx = this.module.functionIdxByName[fnName];
    if (idx === void 0)
      throw new Error(`Function not defined: Function: ${fnName}`);
    return [...[].concat(...args), 16, ...varuint32(idx)];
  }
  call_indirect(fnIdx, ...args) {
    return [...[].concat(...args), ...fnIdx, 17, 0, 0];
  }
  if(condCode, thenCode, elseCode) {
    if (elseCode) {
      return [...condCode, 4, 64, ...thenCode, 5, ...elseCode, 11];
    } else {
      return [...condCode, 4, 64, ...thenCode, 11];
    }
  }
  block(bCode) {
    return [2, 64, ...bCode, 11];
  }
  loop(...args) {
    return [3, 64, ...[].concat(...[...args]), 11];
  }
  br_if(relPath, condCode) {
    return [...condCode, 13, ...varuint32(relPath)];
  }
  br(relPath) {
    return [12, ...varuint32(relPath)];
  }
  ret(rCode) {
    return [...rCode, 15];
  }
  drop(dCode) {
    return [...dCode, 26];
  }
  i64_const(num) {
    return [66, ...varint64(num)];
  }
  i32_const(num) {
    return [65, ...varint32(num)];
  }
  i64_eqz(opcode) {
    return [...opcode, 80];
  }
  i64_eq(op1code, op2code) {
    return [...op1code, ...op2code, 81];
  }
  i64_ne(op1code, op2code) {
    return [...op1code, ...op2code, 82];
  }
  i64_lt_s(op1code, op2code) {
    return [...op1code, ...op2code, 83];
  }
  i64_lt_u(op1code, op2code) {
    return [...op1code, ...op2code, 84];
  }
  i64_gt_s(op1code, op2code) {
    return [...op1code, ...op2code, 85];
  }
  i64_gt_u(op1code, op2code) {
    return [...op1code, ...op2code, 86];
  }
  i64_le_s(op1code, op2code) {
    return [...op1code, ...op2code, 87];
  }
  i64_le_u(op1code, op2code) {
    return [...op1code, ...op2code, 88];
  }
  i64_ge_s(op1code, op2code) {
    return [...op1code, ...op2code, 89];
  }
  i64_ge_u(op1code, op2code) {
    return [...op1code, ...op2code, 90];
  }
  i64_add(op1code, op2code) {
    return [...op1code, ...op2code, 124];
  }
  i64_sub(op1code, op2code) {
    return [...op1code, ...op2code, 125];
  }
  i64_mul(op1code, op2code) {
    return [...op1code, ...op2code, 126];
  }
  i64_div_s(op1code, op2code) {
    return [...op1code, ...op2code, 127];
  }
  i64_div_u(op1code, op2code) {
    return [...op1code, ...op2code, 128];
  }
  i64_rem_s(op1code, op2code) {
    return [...op1code, ...op2code, 129];
  }
  i64_rem_u(op1code, op2code) {
    return [...op1code, ...op2code, 130];
  }
  i64_and(op1code, op2code) {
    return [...op1code, ...op2code, 131];
  }
  i64_or(op1code, op2code) {
    return [...op1code, ...op2code, 132];
  }
  i64_xor(op1code, op2code) {
    return [...op1code, ...op2code, 133];
  }
  i64_shl(op1code, op2code) {
    return [...op1code, ...op2code, 134];
  }
  i64_shr_s(op1code, op2code) {
    return [...op1code, ...op2code, 135];
  }
  i64_shr_u(op1code, op2code) {
    return [...op1code, ...op2code, 136];
  }
  i64_extend_i32_s(op1code) {
    return [...op1code, 172];
  }
  i64_extend_i32_u(op1code) {
    return [...op1code, 173];
  }
  i64_clz(op1code) {
    return [...op1code, 121];
  }
  i64_ctz(op1code) {
    return [...op1code, 122];
  }
  i32_eqz(op1code) {
    return [...op1code, 69];
  }
  i32_eq(op1code, op2code) {
    return [...op1code, ...op2code, 70];
  }
  i32_ne(op1code, op2code) {
    return [...op1code, ...op2code, 71];
  }
  i32_lt_s(op1code, op2code) {
    return [...op1code, ...op2code, 72];
  }
  i32_lt_u(op1code, op2code) {
    return [...op1code, ...op2code, 73];
  }
  i32_gt_s(op1code, op2code) {
    return [...op1code, ...op2code, 74];
  }
  i32_gt_u(op1code, op2code) {
    return [...op1code, ...op2code, 75];
  }
  i32_le_s(op1code, op2code) {
    return [...op1code, ...op2code, 76];
  }
  i32_le_u(op1code, op2code) {
    return [...op1code, ...op2code, 77];
  }
  i32_ge_s(op1code, op2code) {
    return [...op1code, ...op2code, 78];
  }
  i32_ge_u(op1code, op2code) {
    return [...op1code, ...op2code, 79];
  }
  i32_add(op1code, op2code) {
    return [...op1code, ...op2code, 106];
  }
  i32_sub(op1code, op2code) {
    return [...op1code, ...op2code, 107];
  }
  i32_mul(op1code, op2code) {
    return [...op1code, ...op2code, 108];
  }
  i32_div_s(op1code, op2code) {
    return [...op1code, ...op2code, 109];
  }
  i32_div_u(op1code, op2code) {
    return [...op1code, ...op2code, 110];
  }
  i32_rem_s(op1code, op2code) {
    return [...op1code, ...op2code, 111];
  }
  i32_rem_u(op1code, op2code) {
    return [...op1code, ...op2code, 112];
  }
  i32_and(op1code, op2code) {
    return [...op1code, ...op2code, 113];
  }
  i32_or(op1code, op2code) {
    return [...op1code, ...op2code, 114];
  }
  i32_xor(op1code, op2code) {
    return [...op1code, ...op2code, 115];
  }
  i32_shl(op1code, op2code) {
    return [...op1code, ...op2code, 116];
  }
  i32_shr_s(op1code, op2code) {
    return [...op1code, ...op2code, 117];
  }
  i32_shr_u(op1code, op2code) {
    return [...op1code, ...op2code, 118];
  }
  i32_rotl(op1code, op2code) {
    return [...op1code, ...op2code, 119];
  }
  i32_rotr(op1code, op2code) {
    return [...op1code, ...op2code, 120];
  }
  i32_wrap_i64(op1code) {
    return [...op1code, 167];
  }
  i32_clz(op1code) {
    return [...op1code, 103];
  }
  i32_ctz(op1code) {
    return [...op1code, 104];
  }
  unreachable() {
    return [0];
  }
  current_memory() {
    return [63, 0];
  }
  comment() {
    return [];
  }
};

// ../../node_modules/wasmbuilder/src/functionbuilder.js
var typeCodes = {
  "i32": 127,
  "i64": 126,
  "f32": 125,
  "f64": 124,
  "anyfunc": 112,
  "func": 96,
  "emptyblock": 64
};
var FunctionBuilder = class {
  constructor(module2, fnName, fnType, moduleName, fieldName) {
    if (fnType == "import") {
      this.fnType = "import";
      this.moduleName = moduleName;
      this.fieldName = fieldName;
    } else if (fnType == "internal") {
      this.fnType = "internal";
    } else {
      throw new Error("Invalid function fnType: " + fnType);
    }
    this.module = module2;
    this.fnName = fnName;
    this.params = [];
    this.locals = [];
    this.localIdxByName = {};
    this.code = [];
    this.returnType = null;
    this.nextLocal = 0;
  }
  addParam(paramName, paramType) {
    if (this.localIdxByName[paramName])
      throw new Error(`param already exists. Function: ${this.fnName}, Param: ${paramName} `);
    const idx = this.nextLocal++;
    this.localIdxByName[paramName] = idx;
    this.params.push({
      type: paramType
    });
  }
  addLocal(localName, localType, _length) {
    const length = _length || 1;
    if (this.localIdxByName[localName])
      throw new Error(`local already exists. Function: ${this.fnName}, Param: ${localName} `);
    const idx = this.nextLocal++;
    this.localIdxByName[localName] = idx;
    this.locals.push({
      type: localType,
      length
    });
  }
  setReturnType(returnType) {
    if (this.returnType)
      throw new Error(`returnType already defined. Function: ${this.fnName}`);
    this.returnType = returnType;
  }
  getSignature() {
    const params = [...varuint32(this.params.length), ...this.params.map((p) => typeCodes[p.type])];
    const returns = this.returnType ? [1, typeCodes[this.returnType]] : [0];
    return [96, ...params, ...returns];
  }
  getBody() {
    const locals = this.locals.map((l) => [
      ...varuint32(l.length),
      typeCodes[l.type]
    ]);
    const body = [
      ...varuint32(this.locals.length),
      ...[].concat(...locals),
      ...this.code,
      11
    ];
    return [
      ...varuint32(body.length),
      ...body
    ];
  }
  addCode(...code) {
    this.code.push(...[].concat(...[...code]));
  }
  getCodeBuilder() {
    return new CodeBuilder(this);
  }
};

// ../../node_modules/wasmbuilder/src/modulebuilder.js
var ModuleBuilder = class {
  constructor() {
    this.functions = [];
    this.functionIdxByName = {};
    this.nImportFunctions = 0;
    this.nInternalFunctions = 0;
    this.memory = {
      pagesSize: 1,
      moduleName: "env",
      fieldName: "memory"
    };
    this.free = 8;
    this.datas = [];
    this.modules = {};
    this.exports = [];
    this.functionsTable = [];
  }
  build() {
    this._setSignatures();
    return new Uint8Array([
      ...u32(1836278016),
      ...u32(1),
      ...this._buildType(),
      ...this._buildImport(),
      ...this._buildFunctionDeclarations(),
      ...this._buildFunctionsTable(),
      ...this._buildExports(),
      ...this._buildElements(),
      ...this._buildCode(),
      ...this._buildData()
    ]);
  }
  addFunction(fnName) {
    if (typeof this.functionIdxByName[fnName] !== "undefined")
      throw new Error(`Function already defined: ${fnName}`);
    const idx = this.functions.length;
    this.functionIdxByName[fnName] = idx;
    this.functions.push(new FunctionBuilder(this, fnName, "internal"));
    this.nInternalFunctions++;
    return this.functions[idx];
  }
  addIimportFunction(fnName, moduleName, _fieldName) {
    if (typeof this.functionIdxByName[fnName] !== "undefined")
      throw new Error(`Function already defined: ${fnName}`);
    if (this.functions.length > 0 && this.functions[this.functions.length - 1].type == "internal")
      throw new Error(`Import functions must be declared before internal: ${fnName}`);
    let fieldName = _fieldName || fnName;
    const idx = this.functions.length;
    this.functionIdxByName[fnName] = idx;
    this.functions.push(new FunctionBuilder(this, fnName, "import", moduleName, fieldName));
    this.nImportFunctions++;
    return this.functions[idx];
  }
  setMemory(pagesSize, moduleName, fieldName) {
    this.memory = {
      pagesSize,
      moduleName: moduleName || "env",
      fieldName: fieldName || "memory"
    };
  }
  exportFunction(fnName, _exportName) {
    const exportName = _exportName || fnName;
    if (typeof this.functionIdxByName[fnName] === "undefined")
      throw new Error(`Function not defined: ${fnName}`);
    const idx = this.functionIdxByName[fnName];
    if (exportName != fnName) {
      this.functionIdxByName[exportName] = idx;
    }
    this.exports.push({
      exportName,
      idx
    });
  }
  addFunctionToTable(fnName) {
    const idx = this.functionIdxByName[fnName];
    this.functionsTable.push(idx);
  }
  addData(offset, bytes) {
    this.datas.push({
      offset,
      bytes
    });
  }
  alloc(a, b) {
    let size;
    let bytes;
    if ((Array.isArray(a) || ArrayBuffer.isView(a)) && typeof b === "undefined") {
      size = a.length;
      bytes = a;
    } else {
      size = a;
      bytes = b;
    }
    size = (size - 1 >> 3) + 1 << 3;
    const p = this.free;
    this.free += size;
    if (bytes) {
      this.addData(p, bytes);
    }
    return p;
  }
  allocString(s) {
    const encoder = new globalThis.TextEncoder();
    const uint8array = encoder.encode(s);
    return this.alloc([...uint8array, 0]);
  }
  _setSignatures() {
    this.signatures = [];
    const signatureIdxByName = {};
    if (this.functionsTable.length > 0) {
      const signature = this.functions[this.functionsTable[0]].getSignature();
      const signatureName = "s_" + toHexString(signature);
      signatureIdxByName[signatureName] = 0;
      this.signatures.push(signature);
    }
    for (let i = 0; i < this.functions.length; i++) {
      const signature = this.functions[i].getSignature();
      const signatureName = "s_" + toHexString(signature);
      if (typeof signatureIdxByName[signatureName] === "undefined") {
        signatureIdxByName[signatureName] = this.signatures.length;
        this.signatures.push(signature);
      }
      this.functions[i].signatureIdx = signatureIdxByName[signatureName];
    }
  }
  _buildSection(sectionType, section) {
    return [sectionType, ...varuint32(section.length), ...section];
  }
  _buildType() {
    return this._buildSection(
      1,
      [
        ...varuint32(this.signatures.length),
        ...[].concat(...this.signatures)
      ]
    );
  }
  _buildImport() {
    const entries = [];
    entries.push([
      ...string(this.memory.moduleName),
      ...string(this.memory.fieldName),
      2,
      0,
      //Flags no init valua
      ...varuint32(this.memory.pagesSize)
    ]);
    for (let i = 0; i < this.nImportFunctions; i++) {
      entries.push([
        ...string(this.functions[i].moduleName),
        ...string(this.functions[i].fieldName),
        0,
        ...varuint32(this.functions[i].signatureIdx)
      ]);
    }
    return this._buildSection(
      2,
      varuint32(entries.length).concat(...entries)
    );
  }
  _buildFunctionDeclarations() {
    const entries = [];
    for (let i = this.nImportFunctions; i < this.nImportFunctions + this.nInternalFunctions; i++) {
      entries.push(...varuint32(this.functions[i].signatureIdx));
    }
    return this._buildSection(
      3,
      [
        ...varuint32(entries.length),
        ...[...entries]
      ]
    );
  }
  _buildFunctionsTable() {
    if (this.functionsTable.length == 0)
      return [];
    return this._buildSection(
      4,
      [
        ...varuint32(1),
        112,
        0,
        ...varuint32(this.functionsTable.length)
      ]
    );
  }
  _buildElements() {
    if (this.functionsTable.length == 0)
      return [];
    const entries = [];
    for (let i = 0; i < this.functionsTable.length; i++) {
      entries.push(...varuint32(this.functionsTable[i]));
    }
    return this._buildSection(
      9,
      [
        ...varuint32(1),
        // 1 entry
        ...varuint32(0),
        // Table (0 in MVP)
        65,
        // offset 0
        ...varint32(0),
        11,
        ...varuint32(this.functionsTable.length),
        // Number of elements
        ...[...entries]
      ]
    );
  }
  _buildExports() {
    const entries = [];
    for (let i = 0; i < this.exports.length; i++) {
      entries.push([
        ...string(this.exports[i].exportName),
        0,
        ...varuint32(this.exports[i].idx)
      ]);
    }
    return this._buildSection(
      7,
      varuint32(entries.length).concat(...entries)
    );
  }
  _buildCode() {
    const entries = [];
    for (let i = this.nImportFunctions; i < this.nImportFunctions + this.nInternalFunctions; i++) {
      entries.push(this.functions[i].getBody());
    }
    return this._buildSection(
      10,
      varuint32(entries.length).concat(...entries)
    );
  }
  _buildData() {
    const entries = [];
    entries.push([
      0,
      65,
      0,
      11,
      4,
      ...u32(this.free)
    ]);
    for (let i = 0; i < this.datas.length; i++) {
      entries.push([
        0,
        65,
        ...varint32(this.datas[i].offset),
        11,
        ...varuint32(this.datas[i].bytes.length),
        ...this.datas[i].bytes
      ]);
    }
    return this._buildSection(
      11,
      varuint32(entries.length).concat(...entries)
    );
  }
};

// ../../node_modules/@iden3/binfileutils/node_modules/ffjavascript/src/bn128.js
globalThis.curve_bn128 = null;

// ../../node_modules/@iden3/binfileutils/node_modules/ffjavascript/src/bls12381.js
var import_wasmcurves2 = __toESM(require_wasmcurves(), 1);
globalThis.curve_bls12381 = null;

// ../../node_modules/@iden3/binfileutils/node_modules/ffjavascript/src/curves.js
var bls12381r = e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
var bn128r = e("21888242871839275222246405745257275088548364400416034343698204186575808495617");
var bls12381q = e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
var bn128q = e("21888242871839275222246405745257275088696311157297823662689037894645226208583");

// ../../node_modules/@iden3/binfileutils/node_modules/ffjavascript/main.js
var Scalar = scalar_exports;

// ../../node_modules/fastfile/src/osfile.js
var import_fs = __toESM(require("fs"), 1);
async function open(fileName, openFlags, cacheSize, pageSize) {
  cacheSize = cacheSize || 4096 * 64;
  if (typeof openFlags !== "number" && ["w+", "wx+", "r", "ax+", "a+"].indexOf(openFlags) < 0)
    throw new Error("Invalid open option");
  const fd = await import_fs.default.promises.open(fileName, openFlags);
  const stats = await fd.stat();
  return new FastFile(fd, stats, cacheSize, pageSize, fileName);
}
var FastFile = class {
  constructor(fd, stats, cacheSize, pageSize, fileName) {
    this.fileName = fileName;
    this.fd = fd;
    this.pos = 0;
    this.pageSize = pageSize || 1 << 8;
    while (this.pageSize < stats.blksize) {
      this.pageSize *= 2;
    }
    this.totalSize = stats.size;
    this.totalPages = Math.floor((stats.size - 1) / this.pageSize) + 1;
    this.maxPagesLoaded = Math.floor(cacheSize / this.pageSize) + 1;
    this.pages = {};
    this.pendingLoads = [];
    this.writing = false;
    this.reading = false;
    this.avBuffs = [];
    this.history = {};
  }
  _loadPage(p) {
    const self2 = this;
    const P = new Promise((resolve, reject) => {
      self2.pendingLoads.push({
        page: p,
        resolve,
        reject
      });
    });
    self2.__statusPage("After Load request: ", p);
    return P;
  }
  __statusPage(s, p) {
    const logEntry = [];
    const self2 = this;
    if (!self2.logHistory)
      return;
    logEntry.push("==" + s + " " + p);
    let S = "";
    for (let i = 0; i < self2.pendingLoads.length; i++) {
      if (self2.pendingLoads[i].page == p)
        S = S + " " + i;
    }
    if (S)
      logEntry.push("Pending loads:" + S);
    if (typeof self2.pages[p] != "undefined") {
      const page = self2.pages[p];
      logEntry.push("Loaded");
      logEntry.push("pendingOps: " + page.pendingOps);
      if (page.loading)
        logEntry.push("loading: " + page.loading);
      if (page.writing)
        logEntry.push("writing");
      if (page.dirty)
        logEntry.push("dirty");
    }
    logEntry.push("==");
    if (!self2.history[p])
      self2.history[p] = [];
    self2.history[p].push(logEntry);
  }
  __printHistory(p) {
    const self2 = this;
    if (!self2.history[p])
      console.log("Empty History ", p);
    console.log("History " + p);
    for (let i = 0; i < self2.history[p].length; i++) {
      for (let j = 0; j < self2.history[p][i].length; j++) {
        console.log("-> " + self2.history[p][i][j]);
      }
    }
  }
  _triggerLoad() {
    const self2 = this;
    if (self2.reading)
      return;
    if (self2.pendingLoads.length == 0)
      return;
    const pageIdxs = Object.keys(self2.pages);
    const deletablePages = [];
    for (let i = 0; i < pageIdxs.length; i++) {
      const page = self2.pages[parseInt(pageIdxs[i])];
      if (page.dirty == false && page.pendingOps == 0 && !page.writing && !page.loading)
        deletablePages.push(parseInt(pageIdxs[i]));
    }
    let freePages = self2.maxPagesLoaded - pageIdxs.length;
    const ops = [];
    while (self2.pendingLoads.length > 0 && (typeof self2.pages[self2.pendingLoads[0].page] != "undefined" || (freePages > 0 || deletablePages.length > 0))) {
      const load = self2.pendingLoads.shift();
      if (typeof self2.pages[load.page] != "undefined") {
        self2.pages[load.page].pendingOps++;
        const idx = deletablePages.indexOf(load.page);
        if (idx >= 0)
          deletablePages.splice(idx, 1);
        if (self2.pages[load.page].loading) {
          self2.pages[load.page].loading.push(load);
        } else {
          load.resolve();
        }
        self2.__statusPage("After Load (cached): ", load.page);
      } else {
        if (freePages) {
          freePages--;
        } else {
          const fp = deletablePages.shift();
          self2.__statusPage("Before Unload: ", fp);
          self2.avBuffs.unshift(self2.pages[fp]);
          delete self2.pages[fp];
          self2.__statusPage("After Unload: ", fp);
        }
        if (load.page >= self2.totalPages) {
          self2.pages[load.page] = getNewPage();
          load.resolve();
          self2.__statusPage("After Load (new): ", load.page);
        } else {
          self2.reading = true;
          self2.pages[load.page] = getNewPage();
          self2.pages[load.page].loading = [load];
          ops.push(self2.fd.read(self2.pages[load.page].buff, 0, self2.pageSize, load.page * self2.pageSize).then((res) => {
            self2.pages[load.page].size = res.bytesRead;
            const loading = self2.pages[load.page].loading;
            delete self2.pages[load.page].loading;
            for (let i = 0; i < loading.length; i++) {
              loading[i].resolve();
            }
            self2.__statusPage("After Load (loaded): ", load.page);
            return res;
          }, (err) => {
            load.reject(err);
          }));
          self2.__statusPage("After Load (loading): ", load.page);
        }
      }
    }
    Promise.all(ops).then(() => {
      self2.reading = false;
      if (self2.pendingLoads.length > 0)
        setImmediate(self2._triggerLoad.bind(self2));
      self2._tryClose();
    });
    function getNewPage() {
      if (self2.avBuffs.length > 0) {
        const p = self2.avBuffs.shift();
        p.dirty = false;
        p.pendingOps = 1;
        p.size = 0;
        return p;
      } else {
        return {
          dirty: false,
          buff: new Uint8Array(self2.pageSize),
          pendingOps: 1,
          size: 0
        };
      }
    }
  }
  _triggerWrite() {
    const self2 = this;
    if (self2.writing)
      return;
    const pageIdxs = Object.keys(self2.pages);
    const ops = [];
    for (let i = 0; i < pageIdxs.length; i++) {
      const page = self2.pages[parseInt(pageIdxs[i])];
      if (page.dirty) {
        page.dirty = false;
        page.writing = true;
        self2.writing = true;
        ops.push(self2.fd.write(page.buff, 0, page.size, parseInt(pageIdxs[i]) * self2.pageSize).then(() => {
          page.writing = false;
          return;
        }, (err) => {
          console.log("ERROR Writing: " + err);
          self2.error = err;
          self2._tryClose();
        }));
      }
    }
    if (self2.writing) {
      Promise.all(ops).then(() => {
        self2.writing = false;
        setImmediate(self2._triggerWrite.bind(self2));
        self2._tryClose();
        if (self2.pendingLoads.length > 0)
          setImmediate(self2._triggerLoad.bind(self2));
      });
    }
  }
  _getDirtyPage() {
    for (let p in this.pages) {
      if (this.pages[p].dirty)
        return p;
    }
    return -1;
  }
  async write(buff, pos) {
    if (buff.byteLength == 0)
      return;
    const self2 = this;
    if (typeof pos == "undefined")
      pos = self2.pos;
    self2.pos = pos + buff.byteLength;
    if (self2.totalSize < pos + buff.byteLength)
      self2.totalSize = pos + buff.byteLength;
    if (self2.pendingClose)
      throw new Error("Writing a closing file");
    const firstPage = Math.floor(pos / self2.pageSize);
    const lastPage = Math.floor((pos + buff.byteLength - 1) / self2.pageSize);
    const pagePromises = [];
    for (let i = firstPage; i <= lastPage; i++)
      pagePromises.push(self2._loadPage(i));
    self2._triggerLoad();
    let p = firstPage;
    let o = pos % self2.pageSize;
    let r = buff.byteLength;
    while (r > 0) {
      await pagePromises[p - firstPage];
      const l = o + r > self2.pageSize ? self2.pageSize - o : r;
      const srcView = buff.slice(buff.byteLength - r, buff.byteLength - r + l);
      const dstView = new Uint8Array(self2.pages[p].buff.buffer, o, l);
      dstView.set(srcView);
      self2.pages[p].dirty = true;
      self2.pages[p].pendingOps--;
      self2.pages[p].size = Math.max(o + l, self2.pages[p].size);
      if (p >= self2.totalPages) {
        self2.totalPages = p + 1;
      }
      r = r - l;
      p++;
      o = 0;
      if (!self2.writing)
        setImmediate(self2._triggerWrite.bind(self2));
    }
  }
  async read(len, pos) {
    const self2 = this;
    let buff = new Uint8Array(len);
    await self2.readToBuffer(buff, 0, len, pos);
    return buff;
  }
  async readToBuffer(buffDst, offset, len, pos) {
    if (len == 0) {
      return;
    }
    const self2 = this;
    if (len > self2.pageSize * self2.maxPagesLoaded * 0.8) {
      const cacheSize = Math.floor(len * 1.1);
      this.maxPagesLoaded = Math.floor(cacheSize / self2.pageSize) + 1;
    }
    if (typeof pos == "undefined")
      pos = self2.pos;
    self2.pos = pos + len;
    if (self2.pendingClose)
      throw new Error("Reading a closing file");
    const firstPage = Math.floor(pos / self2.pageSize);
    const lastPage = Math.floor((pos + len - 1) / self2.pageSize);
    const pagePromises = [];
    for (let i = firstPage; i <= lastPage; i++)
      pagePromises.push(self2._loadPage(i));
    self2._triggerLoad();
    let p = firstPage;
    let o = pos % self2.pageSize;
    let r = pos + len > self2.totalSize ? len - (pos + len - self2.totalSize) : len;
    while (r > 0) {
      await pagePromises[p - firstPage];
      self2.__statusPage("After Await (read): ", p);
      const l = o + r > self2.pageSize ? self2.pageSize - o : r;
      const srcView = new Uint8Array(self2.pages[p].buff.buffer, self2.pages[p].buff.byteOffset + o, l);
      buffDst.set(srcView, offset + len - r);
      self2.pages[p].pendingOps--;
      self2.__statusPage("After Op done: ", p);
      r = r - l;
      p++;
      o = 0;
      if (self2.pendingLoads.length > 0)
        setImmediate(self2._triggerLoad.bind(self2));
    }
    this.pos = pos + len;
  }
  _tryClose() {
    const self2 = this;
    if (!self2.pendingClose)
      return;
    if (self2.error) {
      self2.pendingCloseReject(self2.error);
    }
    const p = self2._getDirtyPage();
    if (p >= 0 || self2.writing || self2.reading || self2.pendingLoads.length > 0)
      return;
    self2.pendingClose();
  }
  close() {
    const self2 = this;
    if (self2.pendingClose)
      throw new Error("Closing the file twice");
    return new Promise((resolve, reject) => {
      self2.pendingClose = resolve;
      self2.pendingCloseReject = reject;
      self2._tryClose();
    }).then(() => {
      self2.fd.close();
    }, (err) => {
      self2.fd.close();
      throw err;
    });
  }
  async discard() {
    const self2 = this;
    await self2.close();
    await import_fs.default.promises.unlink(this.fileName);
  }
  async writeULE32(v, pos) {
    const self2 = this;
    const tmpBuff323 = new Uint8Array(4);
    const tmpBuff32v3 = new DataView(tmpBuff323.buffer);
    tmpBuff32v3.setUint32(0, v, true);
    await self2.write(tmpBuff323, pos);
  }
  async writeUBE32(v, pos) {
    const self2 = this;
    const tmpBuff323 = new Uint8Array(4);
    const tmpBuff32v3 = new DataView(tmpBuff323.buffer);
    tmpBuff32v3.setUint32(0, v, false);
    await self2.write(tmpBuff323, pos);
  }
  async writeULE64(v, pos) {
    const self2 = this;
    const tmpBuff643 = new Uint8Array(8);
    const tmpBuff64v3 = new DataView(tmpBuff643.buffer);
    tmpBuff64v3.setUint32(0, v & 4294967295, true);
    tmpBuff64v3.setUint32(4, Math.floor(v / 4294967296), true);
    await self2.write(tmpBuff643, pos);
  }
  async readULE32(pos) {
    const self2 = this;
    const b = await self2.read(4, pos);
    const view = new Uint32Array(b.buffer);
    return view[0];
  }
  async readUBE32(pos) {
    const self2 = this;
    const b = await self2.read(4, pos);
    const view = new DataView(b.buffer);
    return view.getUint32(0, false);
  }
  async readULE64(pos) {
    const self2 = this;
    const b = await self2.read(8, pos);
    const view = new Uint32Array(b.buffer);
    return view[1] * 4294967296 + view[0];
  }
  async readString(pos) {
    const self2 = this;
    if (self2.pendingClose) {
      throw new Error("Reading a closing file");
    }
    let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
    let currentPage = Math.floor(currentPosition / self2.pageSize);
    let endOfStringFound = false;
    let str = "";
    while (!endOfStringFound) {
      let pagePromise = self2._loadPage(currentPage);
      self2._triggerLoad();
      await pagePromise;
      self2.__statusPage("After Await (read): ", currentPage);
      let offsetOnPage = currentPosition % self2.pageSize;
      const dataArray = new Uint8Array(
        self2.pages[currentPage].buff.buffer,
        self2.pages[currentPage].buff.byteOffset + offsetOnPage,
        self2.pageSize - offsetOnPage
      );
      let indexEndOfString = dataArray.findIndex((element) => element === 0);
      endOfStringFound = indexEndOfString !== -1;
      if (endOfStringFound) {
        str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
        self2.pos = currentPage * this.pageSize + offsetOnPage + indexEndOfString + 1;
      } else {
        str += new TextDecoder().decode(dataArray);
        self2.pos = currentPage * this.pageSize + offsetOnPage + dataArray.length;
      }
      self2.pages[currentPage].pendingOps--;
      self2.__statusPage("After Op done: ", currentPage);
      currentPosition = self2.pos;
      currentPage++;
      if (self2.pendingLoads.length > 0)
        setImmediate(self2._triggerLoad.bind(self2));
    }
    return str;
  }
};

// ../../node_modules/fastfile/src/memfile.js
function createNew(o) {
  const initialSize = o.initialSize || 1 << 20;
  const fd = new MemFile();
  fd.o = o;
  fd.o.data = new Uint8Array(initialSize);
  fd.allocSize = initialSize;
  fd.totalSize = 0;
  fd.readOnly = false;
  fd.pos = 0;
  return fd;
}
function readExisting(o) {
  const fd = new MemFile();
  fd.o = o;
  fd.allocSize = o.data.byteLength;
  fd.totalSize = o.data.byteLength;
  fd.readOnly = true;
  fd.pos = 0;
  return fd;
}
var tmpBuff32 = new Uint8Array(4);
var tmpBuff32v = new DataView(tmpBuff32.buffer);
var tmpBuff64 = new Uint8Array(8);
var tmpBuff64v = new DataView(tmpBuff64.buffer);
var MemFile = class {
  constructor() {
    this.pageSize = 1 << 14;
  }
  _resizeIfNeeded(newLen) {
    if (newLen > this.allocSize) {
      const newAllocSize = Math.max(
        this.allocSize + (1 << 20),
        Math.floor(this.allocSize * 1.1),
        newLen
      );
      const newData = new Uint8Array(newAllocSize);
      newData.set(this.o.data);
      this.o.data = newData;
      this.allocSize = newAllocSize;
    }
  }
  async write(buff, pos) {
    const self2 = this;
    if (typeof pos == "undefined")
      pos = self2.pos;
    if (this.readOnly)
      throw new Error("Writing a read only file");
    this._resizeIfNeeded(pos + buff.byteLength);
    this.o.data.set(buff.slice(), pos);
    if (pos + buff.byteLength > this.totalSize)
      this.totalSize = pos + buff.byteLength;
    this.pos = pos + buff.byteLength;
  }
  async readToBuffer(buffDest, offset, len, pos) {
    const self2 = this;
    if (typeof pos == "undefined")
      pos = self2.pos;
    if (this.readOnly) {
      if (pos + len > this.totalSize)
        throw new Error("Reading out of bounds");
    }
    this._resizeIfNeeded(pos + len);
    const buffSrc = new Uint8Array(this.o.data.buffer, this.o.data.byteOffset + pos, len);
    buffDest.set(buffSrc, offset);
    this.pos = pos + len;
  }
  async read(len, pos) {
    const self2 = this;
    const buff = new Uint8Array(len);
    await self2.readToBuffer(buff, 0, len, pos);
    return buff;
  }
  close() {
    if (this.o.data.byteLength != this.totalSize) {
      this.o.data = this.o.data.slice(0, this.totalSize);
    }
  }
  async discard() {
  }
  async writeULE32(v, pos) {
    const self2 = this;
    tmpBuff32v.setUint32(0, v, true);
    await self2.write(tmpBuff32, pos);
  }
  async writeUBE32(v, pos) {
    const self2 = this;
    tmpBuff32v.setUint32(0, v, false);
    await self2.write(tmpBuff32, pos);
  }
  async writeULE64(v, pos) {
    const self2 = this;
    tmpBuff64v.setUint32(0, v & 4294967295, true);
    tmpBuff64v.setUint32(4, Math.floor(v / 4294967296), true);
    await self2.write(tmpBuff64, pos);
  }
  async readULE32(pos) {
    const self2 = this;
    const b = await self2.read(4, pos);
    const view = new Uint32Array(b.buffer);
    return view[0];
  }
  async readUBE32(pos) {
    const self2 = this;
    const b = await self2.read(4, pos);
    const view = new DataView(b.buffer);
    return view.getUint32(0, false);
  }
  async readULE64(pos) {
    const self2 = this;
    const b = await self2.read(8, pos);
    const view = new Uint32Array(b.buffer);
    return view[1] * 4294967296 + view[0];
  }
  async readString(pos) {
    const self2 = this;
    let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
    if (currentPosition > this.totalSize) {
      if (this.readOnly) {
        throw new Error("Reading out of bounds");
      }
      this._resizeIfNeeded(pos);
    }
    const dataArray = new Uint8Array(
      self2.o.data.buffer,
      currentPosition,
      this.totalSize - currentPosition
    );
    let indexEndOfString = dataArray.findIndex((element) => element === 0);
    let endOfStringFound = indexEndOfString !== -1;
    let str = "";
    if (endOfStringFound) {
      str = new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
      self2.pos = currentPosition + indexEndOfString + 1;
    } else {
      self2.pos = currentPosition;
    }
    return str;
  }
};

// ../../node_modules/fastfile/src/bigmemfile.js
var PAGE_SIZE2 = 1 << 22;
function createNew2(o) {
  const initialSize = o.initialSize || 0;
  const fd = new BigMemFile();
  fd.o = o;
  const nPages = initialSize ? Math.floor((initialSize - 1) / PAGE_SIZE2) + 1 : 0;
  fd.o.data = [];
  for (let i = 0; i < nPages - 1; i++) {
    fd.o.data.push(new Uint8Array(PAGE_SIZE2));
  }
  if (nPages)
    fd.o.data.push(new Uint8Array(initialSize - PAGE_SIZE2 * (nPages - 1)));
  fd.totalSize = 0;
  fd.readOnly = false;
  fd.pos = 0;
  return fd;
}
function readExisting2(o) {
  const fd = new BigMemFile();
  fd.o = o;
  fd.totalSize = (o.data.length - 1) * PAGE_SIZE2 + o.data[o.data.length - 1].byteLength;
  fd.readOnly = true;
  fd.pos = 0;
  return fd;
}
var tmpBuff322 = new Uint8Array(4);
var tmpBuff32v2 = new DataView(tmpBuff322.buffer);
var tmpBuff642 = new Uint8Array(8);
var tmpBuff64v2 = new DataView(tmpBuff642.buffer);
var BigMemFile = class {
  constructor() {
    this.pageSize = 1 << 14;
  }
  _resizeIfNeeded(newLen) {
    if (newLen <= this.totalSize)
      return;
    if (this.readOnly)
      throw new Error("Reading out of file bounds");
    const nPages = Math.floor((newLen - 1) / PAGE_SIZE2) + 1;
    for (let i = Math.max(this.o.data.length - 1, 0); i < nPages; i++) {
      const newSize = i < nPages - 1 ? PAGE_SIZE2 : newLen - (nPages - 1) * PAGE_SIZE2;
      const p = new Uint8Array(newSize);
      if (i == this.o.data.length - 1)
        p.set(this.o.data[i]);
      this.o.data[i] = p;
    }
    this.totalSize = newLen;
  }
  async write(buff, pos) {
    const self2 = this;
    if (typeof pos == "undefined")
      pos = self2.pos;
    if (this.readOnly)
      throw new Error("Writing a read only file");
    this._resizeIfNeeded(pos + buff.byteLength);
    const firstPage = Math.floor(pos / PAGE_SIZE2);
    let p = firstPage;
    let o = pos % PAGE_SIZE2;
    let r = buff.byteLength;
    while (r > 0) {
      const l = o + r > PAGE_SIZE2 ? PAGE_SIZE2 - o : r;
      const srcView = buff.slice(buff.byteLength - r, buff.byteLength - r + l);
      const dstView = new Uint8Array(self2.o.data[p].buffer, o, l);
      dstView.set(srcView);
      r = r - l;
      p++;
      o = 0;
    }
    this.pos = pos + buff.byteLength;
  }
  async readToBuffer(buffDst, offset, len, pos) {
    const self2 = this;
    if (typeof pos == "undefined")
      pos = self2.pos;
    if (this.readOnly) {
      if (pos + len > this.totalSize)
        throw new Error("Reading out of bounds");
    }
    this._resizeIfNeeded(pos + len);
    const firstPage = Math.floor(pos / PAGE_SIZE2);
    let p = firstPage;
    let o = pos % PAGE_SIZE2;
    let r = len;
    while (r > 0) {
      const l = o + r > PAGE_SIZE2 ? PAGE_SIZE2 - o : r;
      const srcView = new Uint8Array(self2.o.data[p].buffer, o, l);
      buffDst.set(srcView, offset + len - r);
      r = r - l;
      p++;
      o = 0;
    }
    this.pos = pos + len;
  }
  async read(len, pos) {
    const self2 = this;
    const buff = new Uint8Array(len);
    await self2.readToBuffer(buff, 0, len, pos);
    return buff;
  }
  close() {
  }
  async discard() {
  }
  async writeULE32(v, pos) {
    const self2 = this;
    tmpBuff32v2.setUint32(0, v, true);
    await self2.write(tmpBuff322, pos);
  }
  async writeUBE32(v, pos) {
    const self2 = this;
    tmpBuff32v2.setUint32(0, v, false);
    await self2.write(tmpBuff322, pos);
  }
  async writeULE64(v, pos) {
    const self2 = this;
    tmpBuff64v2.setUint32(0, v & 4294967295, true);
    tmpBuff64v2.setUint32(4, Math.floor(v / 4294967296), true);
    await self2.write(tmpBuff642, pos);
  }
  async readULE32(pos) {
    const self2 = this;
    const b = await self2.read(4, pos);
    const view = new Uint32Array(b.buffer);
    return view[0];
  }
  async readUBE32(pos) {
    const self2 = this;
    const b = await self2.read(4, pos);
    const view = new DataView(b.buffer);
    return view.getUint32(0, false);
  }
  async readULE64(pos) {
    const self2 = this;
    const b = await self2.read(8, pos);
    const view = new Uint32Array(b.buffer);
    return view[1] * 4294967296 + view[0];
  }
  async readString(pos) {
    const self2 = this;
    const fixedSize = 2048;
    let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
    if (currentPosition > this.totalSize) {
      if (this.readOnly) {
        throw new Error("Reading out of bounds");
      }
      this._resizeIfNeeded(pos);
    }
    let endOfStringFound = false;
    let str = "";
    while (!endOfStringFound) {
      let currentPage = Math.floor(currentPosition / PAGE_SIZE2);
      let offsetOnPage = currentPosition % PAGE_SIZE2;
      if (self2.o.data[currentPage] === void 0) {
        throw new Error("ERROR");
      }
      let readLength = Math.min(fixedSize, self2.o.data[currentPage].length - offsetOnPage);
      const dataArray = new Uint8Array(self2.o.data[currentPage].buffer, offsetOnPage, readLength);
      let indexEndOfString = dataArray.findIndex((element) => element === 0);
      endOfStringFound = indexEndOfString !== -1;
      if (endOfStringFound) {
        str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
        self2.pos = currentPage * PAGE_SIZE2 + offsetOnPage + indexEndOfString + 1;
      } else {
        str += new TextDecoder().decode(dataArray);
        self2.pos = currentPage * PAGE_SIZE2 + offsetOnPage + dataArray.length;
      }
      currentPosition = self2.pos;
    }
    return str;
  }
};

// ../../node_modules/fastfile/src/fastfile.js
var import_constants = require("constants");
var DEFAULT_CACHE_SIZE = 1 << 16;
var DEFAULT_PAGE_SIZE = 1 << 13;
async function createOverride(o, b, c) {
  if (typeof o === "string") {
    o = {
      type: "file",
      fileName: o,
      cacheSize: b || DEFAULT_CACHE_SIZE,
      pageSize: c || DEFAULT_PAGE_SIZE
    };
  }
  if (o.type == "file") {
    return await open(o.fileName, import_constants.O_TRUNC | import_constants.O_CREAT | import_constants.O_RDWR, o.cacheSize, o.pageSize);
  } else if (o.type == "mem") {
    return createNew(o);
  } else if (o.type == "bigMem") {
    return createNew2(o);
  } else {
    throw new Error("Invalid FastFile type: " + o.type);
  }
}
async function readExisting3(o, b, c) {
  if (o instanceof Uint8Array) {
    o = {
      type: "mem",
      data: o
    };
  }
  if (process.browser) {
    if (typeof o === "string") {
      const buff = await fetch(o).then(function(res) {
        return res.arrayBuffer();
      }).then(function(ab) {
        return new Uint8Array(ab);
      });
      o = {
        type: "mem",
        data: buff
      };
    }
  } else {
    if (typeof o === "string") {
      o = {
        type: "file",
        fileName: o,
        cacheSize: b || DEFAULT_CACHE_SIZE,
        pageSize: c || DEFAULT_PAGE_SIZE
      };
    }
  }
  if (o.type == "file") {
    return await open(o.fileName, import_constants.O_RDONLY, o.cacheSize, o.pageSize);
  } else if (o.type == "mem") {
    return await readExisting(o);
  } else if (o.type == "bigMem") {
    return await readExisting2(o);
  } else {
    throw new Error("Invalid FastFile type: " + o.type);
  }
}

// ../../node_modules/@iden3/binfileutils/src/binfileutils.js
async function readBinFile(fileName, type, maxVersion, cacheSize, pageSize) {
  const fd = await readExisting3(fileName, cacheSize, pageSize);
  const b = await fd.read(4);
  let readedType = "";
  for (let i = 0; i < 4; i++)
    readedType += String.fromCharCode(b[i]);
  if (readedType != type)
    throw new Error(fileName + ": Invalid File format");
  let v = await fd.readULE32();
  if (v > maxVersion)
    throw new Error("Version not supported");
  const nSections = await fd.readULE32();
  let sections = [];
  for (let i = 0; i < nSections; i++) {
    let ht = await fd.readULE32();
    let hl = await fd.readULE64();
    if (typeof sections[ht] == "undefined")
      sections[ht] = [];
    sections[ht].push({
      p: fd.pos,
      size: hl
    });
    fd.pos += hl;
  }
  return { fd, sections };
}
async function createBinFile(fileName, type, version, nSections, cacheSize, pageSize) {
  const fd = await createOverride(fileName, cacheSize, pageSize);
  const buff = new Uint8Array(4);
  for (let i = 0; i < 4; i++)
    buff[i] = type.charCodeAt(i);
  await fd.write(buff, 0);
  await fd.writeULE32(version);
  await fd.writeULE32(nSections);
  return fd;
}
async function startWriteSection(fd, idSection) {
  if (typeof fd.writingSection !== "undefined")
    throw new Error("Already writing a section");
  await fd.writeULE32(idSection);
  fd.writingSection = {
    pSectionSize: fd.pos
  };
  await fd.writeULE64(0);
}
async function endWriteSection(fd) {
  if (typeof fd.writingSection === "undefined")
    throw new Error("Not writing a section");
  const sectionSize = fd.pos - fd.writingSection.pSectionSize - 8;
  const oldPos = fd.pos;
  fd.pos = fd.writingSection.pSectionSize;
  await fd.writeULE64(sectionSize);
  fd.pos = oldPos;
  delete fd.writingSection;
}
async function startReadUniqueSection(fd, sections, idSection) {
  if (typeof fd.readingSection !== "undefined")
    throw new Error("Already reading a section");
  if (!sections[idSection])
    throw new Error(fd.fileName + ": Missing section " + idSection);
  if (sections[idSection].length > 1)
    throw new Error(fd.fileName + ": Section Duplicated " + idSection);
  fd.pos = sections[idSection][0].p;
  fd.readingSection = sections[idSection][0];
}
async function endReadSection(fd, noCheck) {
  if (typeof fd.readingSection === "undefined")
    throw new Error("Not reading a section");
  if (!noCheck) {
    if (fd.pos - fd.readingSection.p != fd.readingSection.size)
      throw new Error("Invalid section size reading");
  }
  delete fd.readingSection;
}
async function writeBigInt(fd, n, n8, pos) {
  const buff = new Uint8Array(n8);
  Scalar.toRprLE(buff, 0, n, n8);
  await fd.write(buff, pos);
}
async function readBigInt(fd, n8, pos) {
  const buff = await fd.read(n8, pos);
  return Scalar.fromRprLE(buff, 0, n8);
}
async function readSection(fd, sections, idSection, offset, length) {
  offset = typeof offset === "undefined" ? 0 : offset;
  length = typeof length === "undefined" ? sections[idSection][0].size - offset : length;
  if (offset + length > sections[idSection][0].size) {
    throw new Error("Reading out of the range of the section");
  }
  let buff;
  if (length < 1 << 30) {
    buff = new Uint8Array(length);
  } else {
    buff = new BigBuffer(length);
  }
  await fd.readToBuffer(buff, 0, length, sections[idSection][0].p + offset);
  return buff;
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js
var scalar_exports2 = {};
__export(scalar_exports2, {
  abs: () => abs2,
  add: () => add2,
  band: () => band2,
  bitLength: () => bitLength3,
  bits: () => bits2,
  bor: () => bor2,
  bxor: () => bxor2,
  div: () => div2,
  e: () => e2,
  eq: () => eq2,
  exp: () => exp3,
  fromArray: () => fromArray2,
  fromRprBE: () => fromRprBE2,
  fromRprLE: () => fromRprLE2,
  fromString: () => fromString2,
  geq: () => geq2,
  gt: () => gt2,
  isNegative: () => isNegative3,
  isOdd: () => isOdd2,
  isZero: () => isZero3,
  land: () => land2,
  leq: () => leq2,
  lnot: () => lnot2,
  lor: () => lor2,
  lt: () => lt2,
  mod: () => mod2,
  mul: () => mul2,
  naf: () => naf2,
  neg: () => neg2,
  neq: () => neq2,
  one: () => one2,
  pow: () => pow2,
  shiftLeft: () => shiftLeft2,
  shiftRight: () => shiftRight2,
  shl: () => shl2,
  shr: () => shr2,
  square: () => square2,
  sub: () => sub2,
  toArray: () => toArray2,
  toLEBuff: () => toLEBuff2,
  toNumber: () => toNumber3,
  toRprBE: () => toRprBE2,
  toRprLE: () => toRprLE2,
  toString: () => toString2,
  zero: () => zero2
});
var hexLen2 = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];
function fromString2(s, radix) {
  if (!radix || radix == 10) {
    return BigInt(s);
  } else if (radix == 16) {
    if (s.slice(0, 2) == "0x") {
      return BigInt(s);
    } else {
      return BigInt("0x" + s);
    }
  }
}
var e2 = fromString2;
function fromArray2(a, radix) {
  let acc = BigInt(0);
  radix = BigInt(radix);
  for (let i = 0; i < a.length; i++) {
    acc = acc * radix + BigInt(a[i]);
  }
  return acc;
}
function bitLength3(a) {
  const aS = a.toString(16);
  return (aS.length - 1) * 4 + hexLen2[parseInt(aS[0], 16)];
}
function isNegative3(a) {
  return BigInt(a) < BigInt(0);
}
function isZero3(a) {
  return !a;
}
function shiftLeft2(a, n) {
  return BigInt(a) << BigInt(n);
}
function shiftRight2(a, n) {
  return BigInt(a) >> BigInt(n);
}
var shl2 = shiftLeft2;
var shr2 = shiftRight2;
function isOdd2(a) {
  return (BigInt(a) & BigInt(1)) == BigInt(1);
}
function naf2(n) {
  let E = BigInt(n);
  const res = [];
  while (E) {
    if (E & BigInt(1)) {
      const z = 2 - Number(E % BigInt(4));
      res.push(z);
      E = E - BigInt(z);
    } else {
      res.push(0);
    }
    E = E >> BigInt(1);
  }
  return res;
}
function bits2(n) {
  let E = BigInt(n);
  const res = [];
  while (E) {
    if (E & BigInt(1)) {
      res.push(1);
    } else {
      res.push(0);
    }
    E = E >> BigInt(1);
  }
  return res;
}
function toNumber3(s) {
  if (s > BigInt(Number.MAX_SAFE_INTEGER)) {
    throw new Error("Number too big");
  }
  return Number(s);
}
function toArray2(s, radix) {
  const res = [];
  let rem = BigInt(s);
  radix = BigInt(radix);
  while (rem) {
    res.unshift(Number(rem % radix));
    rem = rem / radix;
  }
  return res;
}
function add2(a, b) {
  return BigInt(a) + BigInt(b);
}
function sub2(a, b) {
  return BigInt(a) - BigInt(b);
}
function neg2(a) {
  return -BigInt(a);
}
function mul2(a, b) {
  return BigInt(a) * BigInt(b);
}
function square2(a) {
  return BigInt(a) * BigInt(a);
}
function pow2(a, b) {
  return BigInt(a) ** BigInt(b);
}
function exp3(a, b) {
  return BigInt(a) ** BigInt(b);
}
function abs2(a) {
  return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);
}
function div2(a, b) {
  return BigInt(a) / BigInt(b);
}
function mod2(a, b) {
  return BigInt(a) % BigInt(b);
}
function eq2(a, b) {
  return BigInt(a) == BigInt(b);
}
function neq2(a, b) {
  return BigInt(a) != BigInt(b);
}
function lt2(a, b) {
  return BigInt(a) < BigInt(b);
}
function gt2(a, b) {
  return BigInt(a) > BigInt(b);
}
function leq2(a, b) {
  return BigInt(a) <= BigInt(b);
}
function geq2(a, b) {
  return BigInt(a) >= BigInt(b);
}
function band2(a, b) {
  return BigInt(a) & BigInt(b);
}
function bor2(a, b) {
  return BigInt(a) | BigInt(b);
}
function bxor2(a, b) {
  return BigInt(a) ^ BigInt(b);
}
function land2(a, b) {
  return BigInt(a) && BigInt(b);
}
function lor2(a, b) {
  return BigInt(a) || BigInt(b);
}
function lnot2(a) {
  return !BigInt(a);
}
function toRprLE2(buff, o, e4, n8) {
  const s = "0000000" + e4.toString(16);
  const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8 / 4);
  const l = ((s.length - 7) * 4 - 1 >> 5) + 1;
  for (let i = 0; i < l; i++)
    v[i] = parseInt(s.substring(s.length - 8 * i - 8, s.length - 8 * i), 16);
  for (let i = l; i < v.length; i++)
    v[i] = 0;
  for (let i = v.length * 4; i < n8; i++)
    buff[i] = toNumber3(band2(shiftRight2(e4, i * 8), 255));
}
function toRprBE2(buff, o, e4, n8) {
  const s = "0000000" + e4.toString(16);
  const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
  const l = ((s.length - 7) * 4 - 1 >> 5) + 1;
  for (let i = 0; i < l; i++)
    v.setUint32(n8 - i * 4 - 4, parseInt(s.substring(s.length - 8 * i - 8, s.length - 8 * i), 16), false);
  for (let i = 0; i < n8 / 4 - l; i++)
    v[i] = 0;
}
function fromRprLE2(buff, o, n8) {
  n8 = n8 || buff.byteLength;
  o = o || 0;
  const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8 / 4);
  const a = new Array(n8 / 4);
  v.forEach((ch, i) => a[a.length - i - 1] = ch.toString(16).padStart(8, "0"));
  return fromString2(a.join(""), 16);
}
function fromRprBE2(buff, o, n8) {
  n8 = n8 || buff.byteLength;
  o = o || 0;
  const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
  const a = new Array(n8 / 4);
  for (let i = 0; i < n8 / 4; i++) {
    a[i] = v.getUint32(i * 4, false).toString(16).padStart(8, "0");
  }
  return fromString2(a.join(""), 16);
}
function toString2(a, radix) {
  return a.toString(radix);
}
function toLEBuff2(a) {
  const buff = new Uint8Array(Math.floor((bitLength3(a) - 1) / 8) + 1);
  toRprLE2(buff, 0, a, buff.byteLength);
  return buff;
}
var zero2 = e2(0);
var one2 = e2(1);

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/polfield.js
var _revTable3 = [];
for (let i = 0; i < 256; i++) {
  _revTable3[i] = _revSlow3(i, 8);
}
function _revSlow3(idx, bits4) {
  let res = 0;
  let a = idx;
  for (let i = 0; i < bits4; i++) {
    res <<= 1;
    res = res | a & 1;
    a >>= 1;
  }
  return res;
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js
function quarterRound(st, a, b, c, d) {
  st[a] = st[a] + st[b] >>> 0;
  st[d] = (st[d] ^ st[a]) >>> 0;
  st[d] = (st[d] << 16 | st[d] >>> 16 & 65535) >>> 0;
  st[c] = st[c] + st[d] >>> 0;
  st[b] = (st[b] ^ st[c]) >>> 0;
  st[b] = (st[b] << 12 | st[b] >>> 20 & 4095) >>> 0;
  st[a] = st[a] + st[b] >>> 0;
  st[d] = (st[d] ^ st[a]) >>> 0;
  st[d] = (st[d] << 8 | st[d] >>> 24 & 255) >>> 0;
  st[c] = st[c] + st[d] >>> 0;
  st[b] = (st[b] ^ st[c]) >>> 0;
  st[b] = (st[b] << 7 | st[b] >>> 25 & 127) >>> 0;
}
function doubleRound(st) {
  quarterRound(st, 0, 4, 8, 12);
  quarterRound(st, 1, 5, 9, 13);
  quarterRound(st, 2, 6, 10, 14);
  quarterRound(st, 3, 7, 11, 15);
  quarterRound(st, 0, 5, 10, 15);
  quarterRound(st, 1, 6, 11, 12);
  quarterRound(st, 2, 7, 8, 13);
  quarterRound(st, 3, 4, 9, 14);
}
var ChaCha2 = class {
  constructor(seed) {
    seed = seed || [0, 0, 0, 0, 0, 0, 0, 0];
    this.state = [
      1634760805,
      857760878,
      2036477234,
      1797285236,
      seed[0],
      seed[1],
      seed[2],
      seed[3],
      seed[4],
      seed[5],
      seed[6],
      seed[7],
      0,
      0,
      0,
      0
    ];
    this.idx = 16;
    this.buff = new Array(16);
  }
  nextU32() {
    if (this.idx == 16)
      this.update();
    return this.buff[this.idx++];
  }
  nextU64() {
    return add2(mul2(this.nextU32(), 4294967296), this.nextU32());
  }
  nextBool() {
    return (this.nextU32() & 1) == 1;
  }
  update() {
    for (let i = 0; i < 16; i++)
      this.buff[i] = this.state[i];
    for (let i = 0; i < 10; i++)
      doubleRound(this.buff);
    for (let i = 0; i < 16; i++)
      this.buff[i] = this.buff[i] + this.state[i] >>> 0;
    this.idx = 0;
    this.state[12] = this.state[12] + 1 >>> 0;
    if (this.state[12] != 0)
      return;
    this.state[13] = this.state[13] + 1 >>> 0;
    if (this.state[13] != 0)
      return;
    this.state[14] = this.state[14] + 1 >>> 0;
    if (this.state[14] != 0)
      return;
    this.state[15] = this.state[15] + 1 >>> 0;
  }
};

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/random.js
var import_crypto3 = __toESM(require("crypto"), 1);
function getRandomBytes2(n) {
  let array = new Uint8Array(n);
  if (process.browser) {
    if (typeof globalThis.crypto !== "undefined") {
      globalThis.crypto.getRandomValues(array);
    } else {
      for (let i = 0; i < n; i++) {
        array[i] = Math.random() * 4294967296 >>> 0;
      }
    }
  } else {
    import_crypto3.default.randomFillSync(array);
  }
  return array;
}
function getRandomSeed() {
  const arr = getRandomBytes2(32);
  const arrV = new Uint32Array(arr.buffer);
  const seed = [];
  for (let i = 0; i < 8; i++) {
    seed.push(arrV[i]);
  }
  return seed;
}
var threadRng = null;
function getThreadRng2() {
  if (threadRng)
    return threadRng;
  threadRng = new ChaCha2(getRandomSeed());
  return threadRng;
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js
var import_wasmcurves3 = __toESM(require_wasmcurves2(), 1);

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/utils.js
var utils_exports3 = {};
__export(utils_exports3, {
  array2buffer: () => array2buffer2,
  beBuff2int: () => beBuff2int,
  beInt2Buff: () => beInt2Buff,
  bitReverse: () => bitReverse,
  buffReverseBits: () => buffReverseBits2,
  buffer2array: () => buffer2array2,
  leBuff2int: () => leBuff2int,
  leInt2Buff: () => leInt2Buff2,
  log2: () => log22,
  stringifyBigInts: () => stringifyBigInts,
  stringifyFElements: () => stringifyFElements,
  unstringifyBigInts: () => unstringifyBigInts,
  unstringifyFElements: () => unstringifyFElements
});
function stringifyBigInts(o) {
  if (typeof o == "bigint" || o.eq !== void 0) {
    return o.toString(10);
  } else if (o instanceof Uint8Array) {
    return fromRprLE2(o, 0);
  } else if (Array.isArray(o)) {
    return o.map(stringifyBigInts);
  } else if (typeof o == "object") {
    const res = {};
    const keys = Object.keys(o);
    keys.forEach((k) => {
      res[k] = stringifyBigInts(o[k]);
    });
    return res;
  } else {
    return o;
  }
}
function unstringifyBigInts(o) {
  if (typeof o == "string" && /^[0-9]+$/.test(o)) {
    return BigInt(o);
  } else if (typeof o == "string" && /^0x[0-9a-fA-F]+$/.test(o)) {
    return BigInt(o);
  } else if (Array.isArray(o)) {
    return o.map(unstringifyBigInts);
  } else if (typeof o == "object") {
    if (o === null)
      return null;
    const res = {};
    const keys = Object.keys(o);
    keys.forEach((k) => {
      res[k] = unstringifyBigInts(o[k]);
    });
    return res;
  } else {
    return o;
  }
}
function beBuff2int(buff) {
  let res = BigInt(0);
  let i = buff.length;
  let offset = 0;
  const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
  while (i > 0) {
    if (i >= 4) {
      i -= 4;
      res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);
      offset += 4;
    } else if (i >= 2) {
      i -= 2;
      res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);
      offset += 2;
    } else {
      i -= 1;
      res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);
      offset += 1;
    }
  }
  return res;
}
function beInt2Buff(n, len) {
  let r = n;
  const buff = new Uint8Array(len);
  const buffV = new DataView(buff.buffer);
  let o = len;
  while (o > 0) {
    if (o - 4 >= 0) {
      o -= 4;
      buffV.setUint32(o, Number(r & BigInt(4294967295)));
      r = r >> BigInt(32);
    } else if (o - 2 >= 0) {
      o -= 2;
      buffV.setUint16(o, Number(r & BigInt(65535)));
      r = r >> BigInt(16);
    } else {
      o -= 1;
      buffV.setUint8(o, Number(r & BigInt(255)));
      r = r >> BigInt(8);
    }
  }
  if (r) {
    throw new Error("Number does not fit in this length");
  }
  return buff;
}
function leBuff2int(buff) {
  let res = BigInt(0);
  let i = 0;
  const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
  while (i < buff.length) {
    if (i + 4 <= buff.length) {
      res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);
      i += 4;
    } else if (i + 2 <= buff.length) {
      res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);
      i += 2;
    } else {
      res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);
      i += 1;
    }
  }
  return res;
}
function leInt2Buff2(n, len) {
  let r = n;
  if (typeof len === "undefined") {
    len = Math.floor((bitLength3(n) - 1) / 8) + 1;
    if (len == 0)
      len = 1;
  }
  const buff = new Uint8Array(len);
  const buffV = new DataView(buff.buffer);
  let o = 0;
  while (o < len) {
    if (o + 4 <= len) {
      buffV.setUint32(o, Number(r & BigInt(4294967295)), true);
      o += 4;
      r = r >> BigInt(32);
    } else if (o + 2 <= len) {
      buffV.setUint16(o, Number(r & BigInt(65535)), true);
      o += 2;
      r = r >> BigInt(16);
    } else {
      buffV.setUint8(o, Number(r & BigInt(255)), true);
      o += 1;
      r = r >> BigInt(8);
    }
  }
  if (r) {
    throw new Error("Number does not fit in this length");
  }
  return buff;
}
function stringifyFElements(F, o) {
  if (typeof o == "bigint" || o.eq !== void 0) {
    return o.toString(10);
  } else if (o instanceof Uint8Array) {
    return F.toString(F.e(o));
  } else if (Array.isArray(o)) {
    return o.map(stringifyFElements.bind(this, F));
  } else if (typeof o == "object") {
    const res = {};
    const keys = Object.keys(o);
    keys.forEach((k) => {
      res[k] = stringifyFElements(F, o[k]);
    });
    return res;
  } else {
    return o;
  }
}
function unstringifyFElements(F, o) {
  if (typeof o == "string" && /^[0-9]+$/.test(o)) {
    return F.e(o);
  } else if (typeof o == "string" && /^0x[0-9a-fA-F]+$/.test(o)) {
    return F.e(o);
  } else if (Array.isArray(o)) {
    return o.map(unstringifyFElements.bind(this, F));
  } else if (typeof o == "object") {
    if (o === null)
      return null;
    const res = {};
    const keys = Object.keys(o);
    keys.forEach((k) => {
      res[k] = unstringifyFElements(F, o[k]);
    });
    return res;
  } else {
    return o;
  }
}
var _revTable4 = [];
for (let i = 0; i < 256; i++) {
  _revTable4[i] = _revSlow4(i, 8);
}
function _revSlow4(idx, bits4) {
  let res = 0;
  let a = idx;
  for (let i = 0; i < bits4; i++) {
    res <<= 1;
    res = res | a & 1;
    a >>= 1;
  }
  return res;
}
function bitReverse(idx, bits4) {
  return (_revTable4[idx >>> 24] | _revTable4[idx >>> 16 & 255] << 8 | _revTable4[idx >>> 8 & 255] << 16 | _revTable4[idx & 255] << 24) >>> 32 - bits4;
}
function log22(V) {
  return ((V & 4294901760) !== 0 ? (V &= 4294901760, 16) : 0) | ((V & 4278255360) !== 0 ? (V &= 4278255360, 8) : 0) | ((V & 4042322160) !== 0 ? (V &= 4042322160, 4) : 0) | ((V & 3435973836) !== 0 ? (V &= 3435973836, 2) : 0) | (V & 2863311530) !== 0;
}
function buffReverseBits2(buff, eSize) {
  const n = buff.byteLength / eSize;
  const bits4 = log22(n);
  if (n != 1 << bits4) {
    throw new Error("Invalid number of pointers");
  }
  for (let i = 0; i < n; i++) {
    const r = bitReverse(i, bits4);
    if (i > r) {
      const tmp = buff.slice(i * eSize, (i + 1) * eSize);
      buff.set(buff.slice(r * eSize, (r + 1) * eSize), i * eSize);
      buff.set(tmp, r * eSize);
    }
  }
}
function array2buffer2(arr, sG) {
  const buff = new Uint8Array(sG * arr.length);
  for (let i = 0; i < arr.length; i++) {
    buff.set(arr[i], i * sG);
  }
  return buff;
}
function buffer2array2(buff, sG) {
  const n = buff.byteLength / sG;
  const arr = new Array(n);
  for (let i = 0; i < n; i++) {
    arr[i] = buff.slice(i * sG, i * sG + sG);
  }
  return arr;
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js
var PAGE_SIZE3 = 1 << 30;
var BigBuffer2 = class _BigBuffer {
  constructor(size) {
    this.buffers = [];
    this.byteLength = size;
    for (let i = 0; i < size; i += PAGE_SIZE3) {
      const n = Math.min(size - i, PAGE_SIZE3);
      this.buffers.push(new Uint8Array(n));
    }
  }
  slice(fr, to) {
    if (to === void 0)
      to = this.byteLength;
    if (fr === void 0)
      fr = 0;
    const len = to - fr;
    const firstPage = Math.floor(fr / PAGE_SIZE3);
    const lastPage = Math.floor((fr + len - 1) / PAGE_SIZE3);
    if (firstPage == lastPage || len == 0)
      return this.buffers[firstPage].slice(fr % PAGE_SIZE3, fr % PAGE_SIZE3 + len);
    let buff;
    let p = firstPage;
    let o = fr % PAGE_SIZE3;
    let r = len;
    while (r > 0) {
      const l = o + r > PAGE_SIZE3 ? PAGE_SIZE3 - o : r;
      const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);
      if (l == len)
        return srcView.slice();
      if (!buff) {
        if (len <= PAGE_SIZE3) {
          buff = new Uint8Array(len);
        } else {
          buff = new _BigBuffer(len);
        }
      }
      buff.set(srcView, len - r);
      r = r - l;
      p++;
      o = 0;
    }
    return buff;
  }
  set(buff, offset) {
    if (offset === void 0)
      offset = 0;
    const len = buff.byteLength;
    if (len == 0)
      return;
    const firstPage = Math.floor(offset / PAGE_SIZE3);
    const lastPage = Math.floor((offset + len - 1) / PAGE_SIZE3);
    if (firstPage == lastPage) {
      if (buff instanceof _BigBuffer && buff.buffers.length == 1) {
        return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE3);
      } else {
        return this.buffers[firstPage].set(buff, offset % PAGE_SIZE3);
      }
    }
    let p = firstPage;
    let o = offset % PAGE_SIZE3;
    let r = len;
    while (r > 0) {
      const l = o + r > PAGE_SIZE3 ? PAGE_SIZE3 - o : r;
      const srcView = buff.slice(len - r, len - r + l);
      const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);
      dstView.set(srcView);
      r = r - l;
      p++;
      o = 0;
    }
  }
};

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js
function buildBatchConvert2(tm, fnName, sIn, sOut) {
  return async function batchConvert(buffIn) {
    const nPoints = Math.floor(buffIn.byteLength / sIn);
    if (nPoints * sIn !== buffIn.byteLength) {
      throw new Error("Invalid buffer size");
    }
    const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
    const opPromises = [];
    for (let i = 0; i < tm.concurrency; i++) {
      let n;
      if (i < tm.concurrency - 1) {
        n = pointsPerChunk;
      } else {
        n = nPoints - i * pointsPerChunk;
      }
      if (n == 0)
        continue;
      const buffChunk = buffIn.slice(i * pointsPerChunk * sIn, i * pointsPerChunk * sIn + n * sIn);
      const task = [
        { cmd: "ALLOCSET", var: 0, buff: buffChunk },
        { cmd: "ALLOC", var: 1, len: sOut * n },
        { cmd: "CALL", fnName, params: [
          { var: 0 },
          { val: n },
          { var: 1 }
        ] },
        { cmd: "GET", out: 0, var: 1, len: sOut * n }
      ];
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut;
    if (buffIn instanceof BigBuffer2) {
      fullBuffOut = new BigBuffer2(nPoints * sOut);
    } else {
      fullBuffOut = new Uint8Array(nPoints * sOut);
    }
    let p = 0;
    for (let i = 0; i < result.length; i++) {
      fullBuffOut.set(result[i][0], p);
      p += result[i][0].byteLength;
    }
    return fullBuffOut;
  };
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field1.js
var WasmField12 = class {
  constructor(tm, prefix, n8, p) {
    this.tm = tm;
    this.prefix = prefix;
    this.p = p;
    this.n8 = n8;
    this.type = "F1";
    this.m = 1;
    this.half = shiftRight2(p, one2);
    this.bitLength = bitLength3(p);
    this.mask = sub2(shiftLeft2(one2, this.bitLength), one2);
    this.pOp1 = tm.alloc(n8);
    this.pOp2 = tm.alloc(n8);
    this.pOp3 = tm.alloc(n8);
    this.tm.instance.exports[prefix + "_zero"](this.pOp1);
    this.zero = this.tm.getBuff(this.pOp1, this.n8);
    this.tm.instance.exports[prefix + "_one"](this.pOp1);
    this.one = this.tm.getBuff(this.pOp1, this.n8);
    this.negone = this.neg(this.one);
    this.two = this.add(this.one, this.one);
    this.n64 = Math.floor(n8 / 8);
    this.n32 = Math.floor(n8 / 4);
    if (this.n64 * 8 != this.n8) {
      throw new Error("n8 must be a multiple of 8");
    }
    this.half = shiftRight2(this.p, one2);
    this.nqr = this.two;
    let r = this.exp(this.nqr, this.half);
    while (!this.eq(r, this.negone)) {
      this.nqr = this.add(this.nqr, this.one);
      r = this.exp(this.nqr, this.half);
    }
    this.shift = this.mul(this.nqr, this.nqr);
    this.shiftInv = this.inv(this.shift);
    this.s = 0;
    let t = sub2(this.p, one2);
    while (!isOdd2(t)) {
      this.s = this.s + 1;
      t = shiftRight2(t, one2);
    }
    this.w = [];
    this.w[this.s] = this.exp(this.nqr, t);
    for (let i = this.s - 1; i >= 0; i--) {
      this.w[i] = this.square(this.w[i + 1]);
    }
    if (!this.eq(this.w[0], this.one)) {
      throw new Error("Error calculating roots of unity");
    }
    this.batchToMontgomery = buildBatchConvert2(tm, prefix + "_batchToMontgomery", this.n8, this.n8);
    this.batchFromMontgomery = buildBatchConvert2(tm, prefix + "_batchFromMontgomery", this.n8, this.n8);
  }
  op2(opName, a, b) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op2Bool(opName, a, b) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
  }
  op1(opName, a) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op1Bool(opName, a) {
    this.tm.setBuff(this.pOp1, a);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
  }
  add(a, b) {
    return this.op2("_add", a, b);
  }
  eq(a, b) {
    return this.op2Bool("_eq", a, b);
  }
  isZero(a) {
    return this.op1Bool("_isZero", a);
  }
  sub(a, b) {
    return this.op2("_sub", a, b);
  }
  neg(a) {
    return this.op1("_neg", a);
  }
  inv(a) {
    return this.op1("_inverse", a);
  }
  toMontgomery(a) {
    return this.op1("_toMontgomery", a);
  }
  fromMontgomery(a) {
    return this.op1("_fromMontgomery", a);
  }
  mul(a, b) {
    return this.op2("_mul", a, b);
  }
  div(a, b) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
    this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  square(a) {
    return this.op1("_square", a);
  }
  isSquare(a) {
    return this.op1Bool("_isSquare", a);
  }
  sqrt(a) {
    return this.op1("_sqrt", a);
  }
  exp(a, b) {
    if (!(b instanceof Uint8Array)) {
      b = toLEBuff2(e2(b));
    }
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  isNegative(a) {
    return this.op1Bool("_isNegative", a);
  }
  e(a, b) {
    if (a instanceof Uint8Array)
      return a;
    let ra = e2(a, b);
    if (isNegative3(ra)) {
      ra = neg2(ra);
      if (gt2(ra, this.p)) {
        ra = mod2(ra, this.p);
      }
      ra = sub2(this.p, ra);
    } else {
      if (gt2(ra, this.p)) {
        ra = mod2(ra, this.p);
      }
    }
    const buff = leInt2Buff2(ra, this.n8);
    return this.toMontgomery(buff);
  }
  toString(a, radix) {
    const an = this.fromMontgomery(a);
    const s = fromRprLE2(an, 0);
    return toString2(s, radix);
  }
  fromRng(rng2) {
    let v;
    const buff = new Uint8Array(this.n8);
    do {
      v = zero2;
      for (let i = 0; i < this.n64; i++) {
        v = add2(v, shiftLeft2(rng2.nextU64(), 64 * i));
      }
      v = band2(v, this.mask);
    } while (geq2(v, this.p));
    toRprLE2(buff, 0, v, this.n8);
    return buff;
  }
  random() {
    return this.fromRng(getThreadRng2());
  }
  toObject(a) {
    const an = this.fromMontgomery(a);
    return fromRprLE2(an, 0);
  }
  fromObject(a) {
    const buff = new Uint8Array(this.n8);
    toRprLE2(buff, 0, a, this.n8);
    return this.toMontgomery(buff);
  }
  toRprLE(buff, offset, a) {
    buff.set(this.fromMontgomery(a), offset);
  }
  toRprBE(buff, offset, a) {
    const buff2 = this.fromMontgomery(a);
    for (let i = 0; i < this.n8 / 2; i++) {
      const aux = buff2[i];
      buff2[i] = buff2[this.n8 - 1 - i];
      buff2[this.n8 - 1 - i] = aux;
    }
    buff.set(buff2, offset);
  }
  fromRprLE(buff, offset) {
    offset = offset || 0;
    const res = buff.slice(offset, offset + this.n8);
    return this.toMontgomery(res);
  }
  async batchInverse(buffIn) {
    let returnArray = false;
    const sIn = this.n8;
    const sOut = this.n8;
    if (Array.isArray(buffIn)) {
      buffIn = array2buffer2(buffIn, sIn);
      returnArray = true;
    } else {
      buffIn = buffIn.slice(0, buffIn.byteLength);
    }
    const nPoints = Math.floor(buffIn.byteLength / sIn);
    if (nPoints * sIn !== buffIn.byteLength) {
      throw new Error("Invalid buffer size");
    }
    const pointsPerChunk = Math.floor(nPoints / this.tm.concurrency);
    const opPromises = [];
    for (let i = 0; i < this.tm.concurrency; i++) {
      let n;
      if (i < this.tm.concurrency - 1) {
        n = pointsPerChunk;
      } else {
        n = nPoints - i * pointsPerChunk;
      }
      if (n == 0)
        continue;
      const buffChunk = buffIn.slice(i * pointsPerChunk * sIn, i * pointsPerChunk * sIn + n * sIn);
      const task = [
        { cmd: "ALLOCSET", var: 0, buff: buffChunk },
        { cmd: "ALLOC", var: 1, len: sOut * n },
        { cmd: "CALL", fnName: this.prefix + "_batchInverse", params: [
          { var: 0 },
          { val: sIn },
          { val: n },
          { var: 1 },
          { val: sOut }
        ] },
        { cmd: "GET", out: 0, var: 1, len: sOut * n }
      ];
      opPromises.push(
        this.tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut;
    if (buffIn instanceof BigBuffer2) {
      fullBuffOut = new BigBuffer2(nPoints * sOut);
    } else {
      fullBuffOut = new Uint8Array(nPoints * sOut);
    }
    let p = 0;
    for (let i = 0; i < result.length; i++) {
      fullBuffOut.set(result[i][0], p);
      p += result[i][0].byteLength;
    }
    if (returnArray) {
      return buffer2array2(fullBuffOut, sOut);
    } else {
      return fullBuffOut;
    }
  }
};

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field2.js
var WasmField22 = class {
  constructor(tm, prefix, F) {
    this.tm = tm;
    this.prefix = prefix;
    this.F = F;
    this.type = "F2";
    this.m = F.m * 2;
    this.n8 = this.F.n8 * 2;
    this.n32 = this.F.n32 * 2;
    this.n64 = this.F.n64 * 2;
    this.pOp1 = tm.alloc(F.n8 * 2);
    this.pOp2 = tm.alloc(F.n8 * 2);
    this.pOp3 = tm.alloc(F.n8 * 2);
    this.tm.instance.exports[prefix + "_zero"](this.pOp1);
    this.zero = tm.getBuff(this.pOp1, this.n8);
    this.tm.instance.exports[prefix + "_one"](this.pOp1);
    this.one = tm.getBuff(this.pOp1, this.n8);
    this.negone = this.neg(this.one);
    this.two = this.add(this.one, this.one);
  }
  op2(opName, a, b) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op2Bool(opName, a, b) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
  }
  op1(opName, a) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op1Bool(opName, a) {
    this.tm.setBuff(this.pOp1, a);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
  }
  add(a, b) {
    return this.op2("_add", a, b);
  }
  eq(a, b) {
    return this.op2Bool("_eq", a, b);
  }
  isZero(a) {
    return this.op1Bool("_isZero", a);
  }
  sub(a, b) {
    return this.op2("_sub", a, b);
  }
  neg(a) {
    return this.op1("_neg", a);
  }
  inv(a) {
    return this.op1("_inverse", a);
  }
  isNegative(a) {
    return this.op1Bool("_isNegative", a);
  }
  toMontgomery(a) {
    return this.op1("_toMontgomery", a);
  }
  fromMontgomery(a) {
    return this.op1("_fromMontgomery", a);
  }
  mul(a, b) {
    return this.op2("_mul", a, b);
  }
  mul1(a, b) {
    return this.op2("_mul1", a, b);
  }
  div(a, b) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
    this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  square(a) {
    return this.op1("_square", a);
  }
  isSquare(a) {
    return this.op1Bool("_isSquare", a);
  }
  sqrt(a) {
    return this.op1("_sqrt", a);
  }
  exp(a, b) {
    if (!(b instanceof Uint8Array)) {
      b = toLEBuff2(e2(b));
    }
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  e(a, b) {
    if (a instanceof Uint8Array)
      return a;
    if (Array.isArray(a) && a.length == 2) {
      const c1 = this.F.e(a[0], b);
      const c2 = this.F.e(a[1], b);
      const res = new Uint8Array(this.F.n8 * 2);
      res.set(c1);
      res.set(c2, this.F.n8 * 2);
      return res;
    } else {
      throw new Error("invalid F2");
    }
  }
  toString(a, radix) {
    const s1 = this.F.toString(a.slice(0, this.F.n8), radix);
    const s2 = this.F.toString(a.slice(this.F.n8), radix);
    return `[${s1}, ${s2}]`;
  }
  fromRng(rng2) {
    const c1 = this.F.fromRng(rng2);
    const c2 = this.F.fromRng(rng2);
    const res = new Uint8Array(this.F.n8 * 2);
    res.set(c1);
    res.set(c2, this.F.n8);
    return res;
  }
  random() {
    return this.fromRng(getThreadRng2());
  }
  toObject(a) {
    const c1 = this.F.toObject(a.slice(0, this.F.n8));
    const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8 * 2));
    return [c1, c2];
  }
  fromObject(a) {
    const buff = new Uint8Array(this.F.n8 * 2);
    const b1 = this.F.fromObject(a[0]);
    const b2 = this.F.fromObject(a[1]);
    buff.set(b1);
    buff.set(b2, this.F.n8);
    return buff;
  }
  c1(a) {
    return a.slice(0, this.F.n8);
  }
  c2(a) {
    return a.slice(this.F.n8);
  }
};

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field3.js
var WasmField32 = class {
  constructor(tm, prefix, F) {
    this.tm = tm;
    this.prefix = prefix;
    this.F = F;
    this.type = "F3";
    this.m = F.m * 3;
    this.n8 = this.F.n8 * 3;
    this.n32 = this.F.n32 * 3;
    this.n64 = this.F.n64 * 3;
    this.pOp1 = tm.alloc(F.n8 * 3);
    this.pOp2 = tm.alloc(F.n8 * 3);
    this.pOp3 = tm.alloc(F.n8 * 3);
    this.tm.instance.exports[prefix + "_zero"](this.pOp1);
    this.zero = tm.getBuff(this.pOp1, this.n8);
    this.tm.instance.exports[prefix + "_one"](this.pOp1);
    this.one = tm.getBuff(this.pOp1, this.n8);
    this.negone = this.neg(this.one);
    this.two = this.add(this.one, this.one);
  }
  op2(opName, a, b) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op2Bool(opName, a, b) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
  }
  op1(opName, a) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op1Bool(opName, a) {
    this.tm.setBuff(this.pOp1, a);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
  }
  eq(a, b) {
    return this.op2Bool("_eq", a, b);
  }
  isZero(a) {
    return this.op1Bool("_isZero", a);
  }
  add(a, b) {
    return this.op2("_add", a, b);
  }
  sub(a, b) {
    return this.op2("_sub", a, b);
  }
  neg(a) {
    return this.op1("_neg", a);
  }
  inv(a) {
    return this.op1("_inverse", a);
  }
  isNegative(a) {
    return this.op1Bool("_isNegative", a);
  }
  toMontgomery(a) {
    return this.op1("_toMontgomery", a);
  }
  fromMontgomery(a) {
    return this.op1("_fromMontgomery", a);
  }
  mul(a, b) {
    return this.op2("_mul", a, b);
  }
  div(a, b) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
    this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  square(a) {
    return this.op1("_square", a);
  }
  isSquare(a) {
    return this.op1Bool("_isSquare", a);
  }
  sqrt(a) {
    return this.op1("_sqrt", a);
  }
  exp(a, b) {
    if (!(b instanceof Uint8Array)) {
      b = toLEBuff2(e2(b));
    }
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);
    return this.getBuff(this.pOp3, this.n8);
  }
  e(a, b) {
    if (a instanceof Uint8Array)
      return a;
    if (Array.isArray(a) && a.length == 3) {
      const c1 = this.F.e(a[0], b);
      const c2 = this.F.e(a[1], b);
      const c3 = this.F.e(a[2], b);
      const res = new Uint8Array(this.F.n8 * 3);
      res.set(c1);
      res.set(c2, this.F.n8);
      res.set(c3, this.F.n8 * 2);
      return res;
    } else {
      throw new Error("invalid F3");
    }
  }
  toString(a, radix) {
    const s1 = this.F.toString(a.slice(0, this.F.n8), radix);
    const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8 * 2), radix);
    const s3 = this.F.toString(a.slice(this.F.n8 * 2), radix);
    return `[${s1}, ${s2}, ${s3}]`;
  }
  fromRng(rng2) {
    const c1 = this.F.fromRng(rng2);
    const c2 = this.F.fromRng(rng2);
    const c3 = this.F.fromRng(rng2);
    const res = new Uint8Array(this.F.n8 * 3);
    res.set(c1);
    res.set(c2, this.F.n8);
    res.set(c3, this.F.n8 * 2);
    return res;
  }
  random() {
    return this.fromRng(getThreadRng2());
  }
  toObject(a) {
    const c1 = this.F.toObject(a.slice(0, this.F.n8));
    const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8 * 2));
    const c3 = this.F.toObject(a.slice(this.F.n8 * 2, this.F.n8 * 3));
    return [c1, c2, c3];
  }
  fromObject(a) {
    const buff = new Uint8Array(this.F.n8 * 3);
    const b1 = this.F.fromObject(a[0]);
    const b2 = this.F.fromObject(a[1]);
    const b3 = this.F.fromObject(a[2]);
    buff.set(b1);
    buff.set(b2, this.F.n8);
    buff.set(b3, this.F.n8 * 2);
    return buff;
  }
  c1(a) {
    return a.slice(0, this.F.n8);
  }
  c2(a) {
    return a.slice(this.F.n8, this.F.n8 * 2);
  }
  c3(a) {
    return a.slice(this.F.n8 * 2);
  }
};

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/wasm_curve.js
var WasmCurve2 = class {
  constructor(tm, prefix, F, pGen, pGb, cofactor) {
    this.tm = tm;
    this.prefix = prefix;
    this.F = F;
    this.pOp1 = tm.alloc(F.n8 * 3);
    this.pOp2 = tm.alloc(F.n8 * 3);
    this.pOp3 = tm.alloc(F.n8 * 3);
    this.tm.instance.exports[prefix + "_zero"](this.pOp1);
    this.zero = this.tm.getBuff(this.pOp1, F.n8 * 3);
    this.tm.instance.exports[prefix + "_zeroAffine"](this.pOp1);
    this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8 * 2);
    this.one = this.tm.getBuff(pGen, F.n8 * 3);
    this.g = this.one;
    this.oneAffine = this.tm.getBuff(pGen, F.n8 * 2);
    this.gAffine = this.oneAffine;
    this.b = this.tm.getBuff(pGb, F.n8);
    if (cofactor) {
      this.cofactor = toLEBuff2(cofactor);
    }
    this.negone = this.neg(this.one);
    this.two = this.add(this.one, this.one);
    this.batchLEMtoC = buildBatchConvert2(tm, prefix + "_batchLEMtoC", F.n8 * 2, F.n8);
    this.batchLEMtoU = buildBatchConvert2(tm, prefix + "_batchLEMtoU", F.n8 * 2, F.n8 * 2);
    this.batchCtoLEM = buildBatchConvert2(tm, prefix + "_batchCtoLEM", F.n8, F.n8 * 2);
    this.batchUtoLEM = buildBatchConvert2(tm, prefix + "_batchUtoLEM", F.n8 * 2, F.n8 * 2);
    this.batchToJacobian = buildBatchConvert2(tm, prefix + "_batchToJacobian", F.n8 * 2, F.n8 * 3);
    this.batchToAffine = buildBatchConvert2(tm, prefix + "_batchToAffine", F.n8 * 3, F.n8 * 2);
  }
  op2(opName, a, b) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
  }
  op2bool(opName, a, b) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, b);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
  }
  op1(opName, a) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
  }
  op1Affine(opName, a) {
    this.tm.setBuff(this.pOp1, a);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.F.n8 * 2);
  }
  op1Bool(opName, a) {
    this.tm.setBuff(this.pOp1, a);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
  }
  add(a, b) {
    if (a.byteLength == this.F.n8 * 3) {
      if (b.byteLength == this.F.n8 * 3) {
        return this.op2("_add", a, b);
      } else if (b.byteLength == this.F.n8 * 2) {
        return this.op2("_addMixed", a, b);
      } else {
        throw new Error("invalid point size");
      }
    } else if (a.byteLength == this.F.n8 * 2) {
      if (b.byteLength == this.F.n8 * 3) {
        return this.op2("_addMixed", b, a);
      } else if (b.byteLength == this.F.n8 * 2) {
        return this.op2("_addAffine", a, b);
      } else {
        throw new Error("invalid point size");
      }
    } else {
      throw new Error("invalid point size");
    }
  }
  sub(a, b) {
    if (a.byteLength == this.F.n8 * 3) {
      if (b.byteLength == this.F.n8 * 3) {
        return this.op2("_sub", a, b);
      } else if (b.byteLength == this.F.n8 * 2) {
        return this.op2("_subMixed", a, b);
      } else {
        throw new Error("invalid point size");
      }
    } else if (a.byteLength == this.F.n8 * 2) {
      if (b.byteLength == this.F.n8 * 3) {
        return this.op2("_subMixed", b, a);
      } else if (b.byteLength == this.F.n8 * 2) {
        return this.op2("_subAffine", a, b);
      } else {
        throw new Error("invalid point size");
      }
    } else {
      throw new Error("invalid point size");
    }
  }
  neg(a) {
    if (a.byteLength == this.F.n8 * 3) {
      return this.op1("_neg", a);
    } else if (a.byteLength == this.F.n8 * 2) {
      return this.op1Affine("_negAffine", a);
    } else {
      throw new Error("invalid point size");
    }
  }
  double(a) {
    if (a.byteLength == this.F.n8 * 3) {
      return this.op1("_double", a);
    } else if (a.byteLength == this.F.n8 * 2) {
      return this.op1("_doubleAffine", a);
    } else {
      throw new Error("invalid point size");
    }
  }
  isZero(a) {
    if (a.byteLength == this.F.n8 * 3) {
      return this.op1Bool("_isZero", a);
    } else if (a.byteLength == this.F.n8 * 2) {
      return this.op1Bool("_isZeroAffine", a);
    } else {
      throw new Error("invalid point size");
    }
  }
  timesScalar(a, s) {
    if (!(s instanceof Uint8Array)) {
      s = toLEBuff2(e2(s));
    }
    let fnName;
    if (a.byteLength == this.F.n8 * 3) {
      fnName = this.prefix + "_timesScalar";
    } else if (a.byteLength == this.F.n8 * 2) {
      fnName = this.prefix + "_timesScalarAffine";
    } else {
      throw new Error("invalid point size");
    }
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, s);
    this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s.byteLength, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
  }
  timesFr(a, s) {
    let fnName;
    if (a.byteLength == this.F.n8 * 3) {
      fnName = this.prefix + "_timesFr";
    } else if (a.byteLength == this.F.n8 * 2) {
      fnName = this.prefix + "_timesFrAffine";
    } else {
      throw new Error("invalid point size");
    }
    this.tm.setBuff(this.pOp1, a);
    this.tm.setBuff(this.pOp2, s);
    this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
  }
  eq(a, b) {
    if (a.byteLength == this.F.n8 * 3) {
      if (b.byteLength == this.F.n8 * 3) {
        return this.op2bool("_eq", a, b);
      } else if (b.byteLength == this.F.n8 * 2) {
        return this.op2bool("_eqMixed", a, b);
      } else {
        throw new Error("invalid point size");
      }
    } else if (a.byteLength == this.F.n8 * 2) {
      if (b.byteLength == this.F.n8 * 3) {
        return this.op2bool("_eqMixed", b, a);
      } else if (b.byteLength == this.F.n8 * 2) {
        return this.op2bool("_eqAffine", a, b);
      } else {
        throw new Error("invalid point size");
      }
    } else {
      throw new Error("invalid point size");
    }
  }
  toAffine(a) {
    if (a.byteLength == this.F.n8 * 3) {
      return this.op1Affine("_toAffine", a);
    } else if (a.byteLength == this.F.n8 * 2) {
      return a;
    } else {
      throw new Error("invalid point size");
    }
  }
  toJacobian(a) {
    if (a.byteLength == this.F.n8 * 3) {
      return a;
    } else if (a.byteLength == this.F.n8 * 2) {
      return this.op1("_toJacobian", a);
    } else {
      throw new Error("invalid point size");
    }
  }
  toRprUncompressed(arr, offset, a) {
    this.tm.setBuff(this.pOp1, a);
    if (a.byteLength == this.F.n8 * 3) {
      this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
    } else if (a.byteLength != this.F.n8 * 2) {
      throw new Error("invalid point size");
    }
    this.tm.instance.exports[this.prefix + "_LEMtoU"](this.pOp1, this.pOp1);
    const res = this.tm.getBuff(this.pOp1, this.F.n8 * 2);
    arr.set(res, offset);
  }
  fromRprUncompressed(arr, offset) {
    const buff = arr.slice(offset, offset + this.F.n8 * 2);
    this.tm.setBuff(this.pOp1, buff);
    this.tm.instance.exports[this.prefix + "_UtoLEM"](this.pOp1, this.pOp1);
    return this.tm.getBuff(this.pOp1, this.F.n8 * 2);
  }
  toRprCompressed(arr, offset, a) {
    this.tm.setBuff(this.pOp1, a);
    if (a.byteLength == this.F.n8 * 3) {
      this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
    } else if (a.byteLength != this.F.n8 * 2) {
      throw new Error("invalid point size");
    }
    this.tm.instance.exports[this.prefix + "_LEMtoC"](this.pOp1, this.pOp1);
    const res = this.tm.getBuff(this.pOp1, this.F.n8);
    arr.set(res, offset);
  }
  fromRprCompressed(arr, offset) {
    const buff = arr.slice(offset, offset + this.F.n8);
    this.tm.setBuff(this.pOp1, buff);
    this.tm.instance.exports[this.prefix + "_CtoLEM"](this.pOp1, this.pOp2);
    return this.tm.getBuff(this.pOp2, this.F.n8 * 2);
  }
  toUncompressed(a) {
    const buff = new Uint8Array(this.F.n8 * 2);
    this.toRprUncompressed(buff, 0, a);
    return buff;
  }
  toRprLEM(arr, offset, a) {
    if (a.byteLength == this.F.n8 * 2) {
      arr.set(a, offset);
      return;
    } else if (a.byteLength == this.F.n8 * 3) {
      this.tm.setBuff(this.pOp1, a);
      this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
      const res = this.tm.getBuff(this.pOp1, this.F.n8 * 2);
      arr.set(res, offset);
    } else {
      throw new Error("invalid point size");
    }
  }
  fromRprLEM(arr, offset) {
    offset = offset || 0;
    return arr.slice(offset, offset + this.F.n8 * 2);
  }
  toString(a, radix) {
    if (a.byteLength == this.F.n8 * 3) {
      const x = this.F.toString(a.slice(0, this.F.n8), radix);
      const y = this.F.toString(a.slice(this.F.n8, this.F.n8 * 2), radix);
      const z = this.F.toString(a.slice(this.F.n8 * 2), radix);
      return `[ ${x}, ${y}, ${z} ]`;
    } else if (a.byteLength == this.F.n8 * 2) {
      const x = this.F.toString(a.slice(0, this.F.n8), radix);
      const y = this.F.toString(a.slice(this.F.n8), radix);
      return `[ ${x}, ${y} ]`;
    } else {
      throw new Error("invalid point size");
    }
  }
  isValid(a) {
    if (this.isZero(a))
      return true;
    const F = this.F;
    const aa = this.toAffine(a);
    const x = aa.slice(0, this.F.n8);
    const y = aa.slice(this.F.n8, this.F.n8 * 2);
    const x3b = F.add(F.mul(F.square(x), x), this.b);
    const y2 = F.square(y);
    return F.eq(x3b, y2);
  }
  fromRng(rng2) {
    const F = this.F;
    let P = [];
    let greatest;
    let x3b;
    do {
      P[0] = F.fromRng(rng2);
      greatest = rng2.nextBool();
      x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);
    } while (!F.isSquare(x3b));
    P[1] = F.sqrt(x3b);
    const s = F.isNegative(P[1]);
    if (greatest ^ s)
      P[1] = F.neg(P[1]);
    let Pbuff = new Uint8Array(this.F.n8 * 2);
    Pbuff.set(P[0]);
    Pbuff.set(P[1], this.F.n8);
    if (this.cofactor) {
      Pbuff = this.timesScalar(Pbuff, this.cofactor);
    }
    return Pbuff;
  }
  toObject(a) {
    if (this.isZero(a)) {
      return [
        this.F.toObject(this.F.zero),
        this.F.toObject(this.F.one),
        this.F.toObject(this.F.zero)
      ];
    }
    const x = this.F.toObject(a.slice(0, this.F.n8));
    const y = this.F.toObject(a.slice(this.F.n8, this.F.n8 * 2));
    let z;
    if (a.byteLength == this.F.n8 * 3) {
      z = this.F.toObject(a.slice(this.F.n8 * 2, this.F.n8 * 3));
    } else {
      z = this.F.toObject(this.F.one);
    }
    return [x, y, z];
  }
  fromObject(a) {
    const x = this.F.fromObject(a[0]);
    const y = this.F.fromObject(a[1]);
    let z;
    if (a.length == 3) {
      z = this.F.fromObject(a[2]);
    } else {
      z = this.F.one;
    }
    if (this.F.isZero(z, this.F.one)) {
      return this.zeroAffine;
    } else if (this.F.eq(z, this.F.one)) {
      const buff = new Uint8Array(this.F.n8 * 2);
      buff.set(x);
      buff.set(y, this.F.n8);
      return buff;
    } else {
      const buff = new Uint8Array(this.F.n8 * 3);
      buff.set(x);
      buff.set(y, this.F.n8);
      buff.set(z, this.F.n8 * 2);
      return buff;
    }
  }
  e(a) {
    if (a instanceof Uint8Array)
      return a;
    return this.fromObject(a);
  }
  x(a) {
    const tmp = this.toAffine(a);
    return tmp.slice(0, this.F.n8);
  }
  y(a) {
    const tmp = this.toAffine(a);
    return tmp.slice(this.F.n8);
  }
};

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/threadman_thread.js
function thread2(self2) {
  const MAXMEM = 32767;
  let instance;
  let memory;
  if (self2) {
    self2.onmessage = function(e4) {
      let data;
      if (e4.data) {
        data = e4.data;
      } else {
        data = e4;
      }
      if (data[0].cmd == "INIT") {
        init2(data[0]).then(function() {
          self2.postMessage(data.result);
        });
      } else if (data[0].cmd == "TERMINATE") {
        self2.close();
      } else {
        const res = runTask(data);
        self2.postMessage(res);
      }
    };
  }
  async function init2(data) {
    const code = new Uint8Array(data.code);
    const wasmModule = await WebAssembly.compile(code);
    memory = new WebAssembly.Memory({ initial: data.init, maximum: MAXMEM });
    instance = await WebAssembly.instantiate(wasmModule, {
      env: {
        "memory": memory
      }
    });
  }
  function alloc(length) {
    const u322 = new Uint32Array(memory.buffer, 0, 1);
    while (u322[0] & 3)
      u322[0]++;
    const res = u322[0];
    u322[0] += length;
    if (u322[0] + length > memory.buffer.byteLength) {
      const currentPages = memory.buffer.byteLength / 65536;
      let requiredPages = Math.floor((u322[0] + length) / 65536) + 1;
      if (requiredPages > MAXMEM)
        requiredPages = MAXMEM;
      memory.grow(requiredPages - currentPages);
    }
    return res;
  }
  function allocBuffer(buffer) {
    const p = alloc(buffer.byteLength);
    setBuffer(p, buffer);
    return p;
  }
  function getBuffer(pointer, length) {
    const u8 = new Uint8Array(memory.buffer);
    return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);
  }
  function setBuffer(pointer, buffer) {
    const u8 = new Uint8Array(memory.buffer);
    u8.set(new Uint8Array(buffer), pointer);
  }
  function runTask(task) {
    if (task[0].cmd == "INIT") {
      return init2(task[0]);
    }
    const ctx = {
      vars: [],
      out: []
    };
    const u32a = new Uint32Array(memory.buffer, 0, 1);
    const oldAlloc = u32a[0];
    for (let i = 0; i < task.length; i++) {
      switch (task[i].cmd) {
        case "ALLOCSET":
          ctx.vars[task[i].var] = allocBuffer(task[i].buff);
          break;
        case "ALLOC":
          ctx.vars[task[i].var] = alloc(task[i].len);
          break;
        case "SET":
          setBuffer(ctx.vars[task[i].var], task[i].buff);
          break;
        case "CALL": {
          const params = [];
          for (let j = 0; j < task[i].params.length; j++) {
            const p = task[i].params[j];
            if (typeof p.var !== "undefined") {
              params.push(ctx.vars[p.var] + (p.offset || 0));
            } else if (typeof p.val != "undefined") {
              params.push(p.val);
            }
          }
          instance.exports[task[i].fnName](...params);
          break;
        }
        case "GET":
          ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();
          break;
        default:
          throw new Error("Invalid cmd");
      }
    }
    const u32b = new Uint32Array(memory.buffer, 0, 1);
    u32b[0] = oldAlloc;
    return ctx.out;
  }
  return runTask;
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/threadman.js
var import_os = __toESM(require("os"), 1);
var import_web_worker2 = __toESM(require_node(), 1);
var MEM_SIZE = 25;
var Deferred = class {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.reject = reject;
      this.resolve = resolve;
    });
  }
};
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function stringToBase642(str) {
  if (process.browser) {
    return globalThis.btoa(str);
  } else {
    return Buffer.from(str).toString("base64");
  }
}
var threadSource2 = stringToBase642("(" + thread2.toString() + ")(self)");
var workerSource2 = "data:application/javascript;base64," + threadSource2;
async function buildThreadManager2(wasm, singleThread) {
  const tm = new ThreadManager();
  tm.memory = new WebAssembly.Memory({ initial: MEM_SIZE });
  tm.u8 = new Uint8Array(tm.memory.buffer);
  tm.u32 = new Uint32Array(tm.memory.buffer);
  const wasmModule = await WebAssembly.compile(wasm.code);
  tm.instance = await WebAssembly.instantiate(wasmModule, {
    env: {
      "memory": tm.memory
    }
  });
  tm.singleThread = singleThread;
  tm.initalPFree = tm.u32[0];
  tm.pq = wasm.pq;
  tm.pr = wasm.pr;
  tm.pG1gen = wasm.pG1gen;
  tm.pG1zero = wasm.pG1zero;
  tm.pG2gen = wasm.pG2gen;
  tm.pG2zero = wasm.pG2zero;
  tm.pOneT = wasm.pOneT;
  if (singleThread) {
    tm.code = wasm.code;
    tm.taskManager = thread2();
    await tm.taskManager([{
      cmd: "INIT",
      init: MEM_SIZE,
      code: tm.code.slice()
    }]);
    tm.concurrency = 1;
  } else {
    tm.workers = [];
    tm.pendingDeferreds = [];
    tm.working = [];
    let concurrency;
    if (typeof navigator === "object" && navigator.hardwareConcurrency) {
      concurrency = navigator.hardwareConcurrency;
    } else {
      concurrency = import_os.default.cpus().length;
    }
    if (concurrency == 0) {
      concurrency = 2;
    }
    if (concurrency > 64)
      concurrency = 64;
    tm.concurrency = concurrency;
    for (let i = 0; i < concurrency; i++) {
      tm.workers[i] = new import_web_worker2.default(workerSource2);
      tm.workers[i].addEventListener("message", getOnMsg(i));
      tm.working[i] = false;
    }
    const initPromises = [];
    for (let i = 0; i < tm.workers.length; i++) {
      const copyCode = wasm.code.slice();
      initPromises.push(tm.postAction(i, [{
        cmd: "INIT",
        init: MEM_SIZE,
        code: copyCode
      }], [copyCode.buffer]));
    }
    await Promise.all(initPromises);
  }
  return tm;
  function getOnMsg(i) {
    return function(e4) {
      let data;
      if (e4 && e4.data) {
        data = e4.data;
      } else {
        data = e4;
      }
      tm.working[i] = false;
      tm.pendingDeferreds[i].resolve(data);
      tm.processWorks();
    };
  }
}
var ThreadManager = class {
  constructor() {
    this.actionQueue = [];
    this.oldPFree = 0;
  }
  startSyncOp() {
    if (this.oldPFree != 0)
      throw new Error("Sync operation in progress");
    this.oldPFree = this.u32[0];
  }
  endSyncOp() {
    if (this.oldPFree == 0)
      throw new Error("No sync operation in progress");
    this.u32[0] = this.oldPFree;
    this.oldPFree = 0;
  }
  postAction(workerId, e4, transfers, _deferred) {
    if (this.working[workerId]) {
      throw new Error("Posting a job t a working worker");
    }
    this.working[workerId] = true;
    this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();
    this.workers[workerId].postMessage(e4, transfers);
    return this.pendingDeferreds[workerId].promise;
  }
  processWorks() {
    for (let i = 0; i < this.workers.length && this.actionQueue.length > 0; i++) {
      if (this.working[i] == false) {
        const work = this.actionQueue.shift();
        this.postAction(i, work.data, work.transfers, work.deferred);
      }
    }
  }
  queueAction(actionData, transfers) {
    const d = new Deferred();
    if (this.singleThread) {
      const res = this.taskManager(actionData);
      d.resolve(res);
    } else {
      this.actionQueue.push({
        data: actionData,
        transfers,
        deferred: d
      });
      this.processWorks();
    }
    return d.promise;
  }
  resetMemory() {
    this.u32[0] = this.initalPFree;
  }
  allocBuff(buff) {
    const pointer = this.alloc(buff.byteLength);
    this.setBuff(pointer, buff);
    return pointer;
  }
  getBuff(pointer, length) {
    return this.u8.slice(pointer, pointer + length);
  }
  setBuff(pointer, buffer) {
    this.u8.set(new Uint8Array(buffer), pointer);
  }
  alloc(length) {
    while (this.u32[0] & 3)
      this.u32[0]++;
    const res = this.u32[0];
    this.u32[0] += length;
    return res;
  }
  async terminate() {
    for (let i = 0; i < this.workers.length; i++) {
      this.workers[i].postMessage([{ cmd: "TERMINATE" }]);
    }
    await sleep(200);
  }
};

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/engine_applykey.js
function buildBatchApplyKey2(curve2, groupName) {
  const G = curve2[groupName];
  const Fr = curve2.Fr;
  const tm = curve2.tm;
  curve2[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {
    inType = inType || "affine";
    outType = outType || "affine";
    let fnName, fnAffine;
    let sGin, sGmid, sGout;
    if (groupName == "G1") {
      if (inType == "jacobian") {
        sGin = G.F.n8 * 3;
        fnName = "g1m_batchApplyKey";
      } else {
        sGin = G.F.n8 * 2;
        fnName = "g1m_batchApplyKeyMixed";
      }
      sGmid = G.F.n8 * 3;
      if (outType == "jacobian") {
        sGout = G.F.n8 * 3;
      } else {
        fnAffine = "g1m_batchToAffine";
        sGout = G.F.n8 * 2;
      }
    } else if (groupName == "G2") {
      if (inType == "jacobian") {
        sGin = G.F.n8 * 3;
        fnName = "g2m_batchApplyKey";
      } else {
        sGin = G.F.n8 * 2;
        fnName = "g2m_batchApplyKeyMixed";
      }
      sGmid = G.F.n8 * 3;
      if (outType == "jacobian") {
        sGout = G.F.n8 * 3;
      } else {
        fnAffine = "g2m_batchToAffine";
        sGout = G.F.n8 * 2;
      }
    } else if (groupName == "Fr") {
      fnName = "frm_batchApplyKey";
      sGin = G.n8;
      sGmid = G.n8;
      sGout = G.n8;
    } else {
      throw new Error("Invalid group: " + groupName);
    }
    const nPoints = Math.floor(buff.byteLength / sGin);
    const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
    const opPromises = [];
    inc = Fr.e(inc);
    let t = Fr.e(first);
    for (let i = 0; i < tm.concurrency; i++) {
      let n;
      if (i < tm.concurrency - 1) {
        n = pointsPerChunk;
      } else {
        n = nPoints - i * pointsPerChunk;
      }
      if (n == 0)
        continue;
      const task = [];
      task.push({
        cmd: "ALLOCSET",
        var: 0,
        buff: buff.slice(i * pointsPerChunk * sGin, i * pointsPerChunk * sGin + n * sGin)
      });
      task.push({ cmd: "ALLOCSET", var: 1, buff: t });
      task.push({ cmd: "ALLOCSET", var: 2, buff: inc });
      task.push({ cmd: "ALLOC", var: 3, len: n * Math.max(sGmid, sGout) });
      task.push({
        cmd: "CALL",
        fnName,
        params: [
          { var: 0 },
          { val: n },
          { var: 1 },
          { var: 2 },
          { var: 3 }
        ]
      });
      if (fnAffine) {
        task.push({
          cmd: "CALL",
          fnName: fnAffine,
          params: [
            { var: 3 },
            { val: n },
            { var: 3 }
          ]
        });
      }
      task.push({ cmd: "GET", out: 0, var: 3, len: n * sGout });
      opPromises.push(tm.queueAction(task));
      t = Fr.mul(t, Fr.exp(inc, n));
    }
    const result = await Promise.all(opPromises);
    let outBuff;
    if (buff instanceof BigBuffer2) {
      outBuff = new BigBuffer2(nPoints * sGout);
    } else {
      outBuff = new Uint8Array(nPoints * sGout);
    }
    let p = 0;
    for (let i = 0; i < result.length; i++) {
      outBuff.set(result[i][0], p);
      p += result[i][0].byteLength;
    }
    return outBuff;
  };
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/engine_pairing.js
function buildPairing2(curve2) {
  const tm = curve2.tm;
  curve2.pairing = function pairing(a, b) {
    tm.startSyncOp();
    const pA = tm.allocBuff(curve2.G1.toJacobian(a));
    const pB = tm.allocBuff(curve2.G2.toJacobian(b));
    const pRes = tm.alloc(curve2.Gt.n8);
    tm.instance.exports[curve2.name + "_pairing"](pA, pB, pRes);
    const res = tm.getBuff(pRes, curve2.Gt.n8);
    tm.endSyncOp();
    return res;
  };
  curve2.pairingEq = async function pairingEq() {
    let buffCt;
    let nEqs;
    if (arguments.length % 2 == 1) {
      buffCt = arguments[arguments.length - 1];
      nEqs = (arguments.length - 1) / 2;
    } else {
      buffCt = curve2.Gt.one;
      nEqs = arguments.length / 2;
    }
    const opPromises = [];
    for (let i = 0; i < nEqs; i++) {
      const task = [];
      const g1Buff = curve2.G1.toJacobian(arguments[i * 2]);
      task.push({ cmd: "ALLOCSET", var: 0, buff: g1Buff });
      task.push({ cmd: "ALLOC", var: 1, len: curve2.prePSize });
      const g2Buff = curve2.G2.toJacobian(arguments[i * 2 + 1]);
      task.push({ cmd: "ALLOCSET", var: 2, buff: g2Buff });
      task.push({ cmd: "ALLOC", var: 3, len: curve2.preQSize });
      task.push({ cmd: "ALLOC", var: 4, len: curve2.Gt.n8 });
      task.push({ cmd: "CALL", fnName: curve2.name + "_prepareG1", params: [
        { var: 0 },
        { var: 1 }
      ] });
      task.push({ cmd: "CALL", fnName: curve2.name + "_prepareG2", params: [
        { var: 2 },
        { var: 3 }
      ] });
      task.push({ cmd: "CALL", fnName: curve2.name + "_millerLoop", params: [
        { var: 1 },
        { var: 3 },
        { var: 4 }
      ] });
      task.push({ cmd: "GET", out: 0, var: 4, len: curve2.Gt.n8 });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    tm.startSyncOp();
    const pRes = tm.alloc(curve2.Gt.n8);
    tm.instance.exports.ftm_one(pRes);
    for (let i = 0; i < result.length; i++) {
      const pMR = tm.allocBuff(result[i][0]);
      tm.instance.exports.ftm_mul(pRes, pMR, pRes);
    }
    tm.instance.exports[curve2.name + "_finalExponentiation"](pRes, pRes);
    const pCt = tm.allocBuff(buffCt);
    const r = !!tm.instance.exports.ftm_eq(pRes, pCt);
    tm.endSyncOp();
    return r;
  };
  curve2.prepareG1 = function(p) {
    this.tm.startSyncOp();
    const pP = this.tm.allocBuff(p);
    const pPrepP = this.tm.alloc(this.prePSize);
    this.tm.instance.exports[this.name + "_prepareG1"](pP, pPrepP);
    const res = this.tm.getBuff(pPrepP, this.prePSize);
    this.tm.endSyncOp();
    return res;
  };
  curve2.prepareG2 = function(q) {
    this.tm.startSyncOp();
    const pQ = this.tm.allocBuff(q);
    const pPrepQ = this.tm.alloc(this.preQSize);
    this.tm.instance.exports[this.name + "_prepareG2"](pQ, pPrepQ);
    const res = this.tm.getBuff(pPrepQ, this.preQSize);
    this.tm.endSyncOp();
    return res;
  };
  curve2.millerLoop = function(preP, preQ) {
    this.tm.startSyncOp();
    const pPreP = this.tm.allocBuff(preP);
    const pPreQ = this.tm.allocBuff(preQ);
    const pRes = this.tm.alloc(this.Gt.n8);
    this.tm.instance.exports[this.name + "_millerLoop"](pPreP, pPreQ, pRes);
    const res = this.tm.getBuff(pRes, this.Gt.n8);
    this.tm.endSyncOp();
    return res;
  };
  curve2.finalExponentiation = function(a) {
    this.tm.startSyncOp();
    const pA = this.tm.allocBuff(a);
    const pRes = this.tm.alloc(this.Gt.n8);
    this.tm.instance.exports[this.name + "_finalExponentiation"](pA, pRes);
    const res = this.tm.getBuff(pRes, this.Gt.n8);
    this.tm.endSyncOp();
    return res;
  };
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/engine_multiexp.js
var pTSizes = [
  1,
  1,
  1,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  13,
  14,
  15,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17
];
function buildMultiexp2(curve2, groupName) {
  const G = curve2[groupName];
  const tm = G.tm;
  async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {
    if (!(buffBases instanceof Uint8Array)) {
      if (logger)
        logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);
      throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);
    }
    if (!(buffScalars instanceof Uint8Array)) {
      if (logger)
        logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);
      throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);
    }
    inType = inType || "affine";
    let sGIn;
    let fnName;
    if (groupName == "G1") {
      if (inType == "affine") {
        fnName = "g1m_multiexpAffine_chunk";
        sGIn = G.F.n8 * 2;
      } else {
        fnName = "g1m_multiexp_chunk";
        sGIn = G.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        fnName = "g2m_multiexpAffine_chunk";
        sGIn = G.F.n8 * 2;
      } else {
        fnName = "g2m_multiexp_chunk";
        sGIn = G.F.n8 * 3;
      }
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buffBases.byteLength / sGIn);
    if (nPoints == 0)
      return G.zero;
    const sScalar = Math.floor(buffScalars.byteLength / nPoints);
    if (sScalar * nPoints != buffScalars.byteLength) {
      throw new Error("Scalar size does not match");
    }
    const bitChunkSize = pTSizes[log22(nPoints)];
    const nChunks = Math.floor((sScalar * 8 - 1) / bitChunkSize) + 1;
    const opPromises = [];
    for (let i = 0; i < nChunks; i++) {
      const task = [
        { cmd: "ALLOCSET", var: 0, buff: buffBases },
        { cmd: "ALLOCSET", var: 1, buff: buffScalars },
        { cmd: "ALLOC", var: 2, len: G.F.n8 * 3 },
        { cmd: "CALL", fnName, params: [
          { var: 0 },
          { var: 1 },
          { val: sScalar },
          { val: nPoints },
          { val: i * bitChunkSize },
          { val: Math.min(sScalar * 8 - i * bitChunkSize, bitChunkSize) },
          { var: 2 }
        ] },
        { cmd: "GET", out: 0, var: 2, len: G.F.n8 * 3 }
      ];
      opPromises.push(
        G.tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let res = G.zero;
    for (let i = result.length - 1; i >= 0; i--) {
      if (!G.isZero(res)) {
        for (let j = 0; j < bitChunkSize; j++)
          res = G.double(res);
      }
      res = G.add(res, result[i][0]);
    }
    return res;
  }
  async function _multiExp(buffBases, buffScalars, inType, logger, logText) {
    const MAX_CHUNK_SIZE = 1 << 22;
    const MIN_CHUNK_SIZE = 1 << 10;
    let sGIn;
    if (groupName == "G1") {
      if (inType == "affine") {
        sGIn = G.F.n8 * 2;
      } else {
        sGIn = G.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sGIn = G.F.n8 * 2;
      } else {
        sGIn = G.F.n8 * 3;
      }
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buffBases.byteLength / sGIn);
    const sScalar = Math.floor(buffScalars.byteLength / nPoints);
    if (sScalar * nPoints != buffScalars.byteLength) {
      throw new Error("Scalar size does not match");
    }
    const bitChunkSize = pTSizes[log22(nPoints)];
    const nChunks = Math.floor((sScalar * 8 - 1) / bitChunkSize) + 1;
    let chunkSize;
    chunkSize = Math.floor(nPoints / (tm.concurrency / nChunks));
    if (chunkSize > MAX_CHUNK_SIZE)
      chunkSize = MAX_CHUNK_SIZE;
    if (chunkSize < MIN_CHUNK_SIZE)
      chunkSize = MIN_CHUNK_SIZE;
    const opPromises = [];
    for (let i = 0; i < nPoints; i += chunkSize) {
      if (logger)
        logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);
      const n = Math.min(nPoints - i, chunkSize);
      const buffBasesChunk = buffBases.slice(i * sGIn, (i + n) * sGIn);
      const buffScalarsChunk = buffScalars.slice(i * sScalar, (i + n) * sScalar);
      opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then((r) => {
        if (logger)
          logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);
        return r;
      }));
    }
    const result = await Promise.all(opPromises);
    let res = G.zero;
    for (let i = result.length - 1; i >= 0; i--) {
      res = G.add(res, result[i]);
    }
    return res;
  }
  G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {
    return await _multiExp(buffBases, buffScalars, "jacobian", logger, logText);
  };
  G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {
    return await _multiExp(buffBases, buffScalars, "affine", logger, logText);
  };
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/engine_fft.js
function buildFFT2(curve2, groupName) {
  const G = curve2[groupName];
  const Fr = curve2.Fr;
  const tm = G.tm;
  async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {
    inType = inType || "affine";
    outType = outType || "affine";
    const MAX_BITS_THREAD = 14;
    let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;
    if (groupName == "G1") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
        fnIn2Mid = "g1m_batchToJacobian";
      } else {
        sIn = G.F.n8 * 3;
      }
      sMid = G.F.n8 * 3;
      if (inverse) {
        fnFFTFinal = "g1m_fftFinal";
      }
      fnFFTJoin = "g1m_fftJoin";
      fnFFTMix = "g1m_fftMix";
      if (outType == "affine") {
        sOut = G.F.n8 * 2;
        fnMid2Out = "g1m_batchToAffine";
      } else {
        sOut = G.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
        fnIn2Mid = "g2m_batchToJacobian";
      } else {
        sIn = G.F.n8 * 3;
      }
      sMid = G.F.n8 * 3;
      if (inverse) {
        fnFFTFinal = "g2m_fftFinal";
      }
      fnFFTJoin = "g2m_fftJoin";
      fnFFTMix = "g2m_fftMix";
      if (outType == "affine") {
        sOut = G.F.n8 * 2;
        fnMid2Out = "g2m_batchToAffine";
      } else {
        sOut = G.F.n8 * 3;
      }
    } else if (groupName == "Fr") {
      sIn = G.n8;
      sMid = G.n8;
      sOut = G.n8;
      if (inverse) {
        fnFFTFinal = "frm_fftFinal";
      }
      fnFFTMix = "frm_fftMix";
      fnFFTJoin = "frm_fftJoin";
    }
    let returnArray = false;
    if (Array.isArray(buff)) {
      buff = array2buffer2(buff, sIn);
      returnArray = true;
    } else {
      buff = buff.slice(0, buff.byteLength);
    }
    const nPoints = buff.byteLength / sIn;
    const bits4 = log22(nPoints);
    if (1 << bits4 != nPoints) {
      throw new Error("fft must be multiple of 2");
    }
    if (bits4 == Fr.s + 1) {
      let buffOut2;
      if (inverse) {
        buffOut2 = await _fftExtInv(buff, inType, outType, logger, loggerTxt);
      } else {
        buffOut2 = await _fftExt(buff, inType, outType, logger, loggerTxt);
      }
      if (returnArray) {
        return buffer2array2(buffOut2, sOut);
      } else {
        return buffOut2;
      }
    }
    let inv;
    if (inverse) {
      inv = Fr.inv(Fr.e(nPoints));
    }
    let buffOut;
    buffReverseBits2(buff, sIn);
    let chunks;
    let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);
    let nChunks = nPoints / pointsInChunk;
    while (nChunks < tm.concurrency && pointsInChunk >= 16) {
      nChunks *= 2;
      pointsInChunk /= 2;
    }
    const l2Chunk = log22(pointsInChunk);
    const promises = [];
    for (let i = 0; i < nChunks; i++) {
      if (logger)
        logger.debug(`${loggerTxt}: fft ${bits4} mix start: ${i}/${nChunks}`);
      const task = [];
      task.push({ cmd: "ALLOC", var: 0, len: sMid * pointsInChunk });
      const buffChunk = buff.slice(pointsInChunk * i * sIn, pointsInChunk * (i + 1) * sIn);
      task.push({ cmd: "SET", var: 0, buff: buffChunk });
      if (fnIn2Mid) {
        task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
      }
      for (let j = 1; j <= l2Chunk; j++) {
        task.push({ cmd: "CALL", fnName: fnFFTMix, params: [{ var: 0 }, { val: pointsInChunk }, { val: j }] });
      }
      if (l2Chunk == bits4) {
        if (fnFFTFinal) {
          task.push({ cmd: "ALLOCSET", var: 1, buff: inv });
          task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
            { var: 0 },
            { val: pointsInChunk },
            { var: 1 }
          ] });
        }
        if (fnMid2Out) {
          task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
        }
        task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sOut });
      } else {
        task.push({ cmd: "GET", out: 0, var: 0, len: sMid * pointsInChunk });
      }
      promises.push(tm.queueAction(task).then((r) => {
        if (logger)
          logger.debug(`${loggerTxt}: fft ${bits4} mix end: ${i}/${nChunks}`);
        return r;
      }));
    }
    chunks = await Promise.all(promises);
    for (let i = 0; i < nChunks; i++)
      chunks[i] = chunks[i][0];
    for (let i = l2Chunk + 1; i <= bits4; i++) {
      if (logger)
        logger.debug(`${loggerTxt}: fft  ${bits4}  join: ${i}/${bits4}`);
      const nGroups = 1 << bits4 - i;
      const nChunksPerGroup = nChunks / nGroups;
      const opPromises = [];
      for (let j = 0; j < nGroups; j++) {
        for (let k = 0; k < nChunksPerGroup / 2; k++) {
          const first = Fr.exp(Fr.w[i], k * pointsInChunk);
          const inc = Fr.w[i];
          const o1 = j * nChunksPerGroup + k;
          const o2 = j * nChunksPerGroup + k + nChunksPerGroup / 2;
          const task = [];
          task.push({ cmd: "ALLOCSET", var: 0, buff: chunks[o1] });
          task.push({ cmd: "ALLOCSET", var: 1, buff: chunks[o2] });
          task.push({ cmd: "ALLOCSET", var: 2, buff: first });
          task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
          task.push({ cmd: "CALL", fnName: fnFFTJoin, params: [
            { var: 0 },
            { var: 1 },
            { val: pointsInChunk },
            { var: 2 },
            { var: 3 }
          ] });
          if (i == bits4) {
            if (fnFFTFinal) {
              task.push({ cmd: "ALLOCSET", var: 4, buff: inv });
              task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
                { var: 0 },
                { val: pointsInChunk },
                { var: 4 }
              ] });
              task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
                { var: 1 },
                { val: pointsInChunk },
                { var: 4 }
              ] });
            }
            if (fnMid2Out) {
              task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
              task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 1 }, { val: pointsInChunk }, { var: 1 }] });
            }
            task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sOut });
            task.push({ cmd: "GET", out: 1, var: 1, len: pointsInChunk * sOut });
          } else {
            task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sMid });
            task.push({ cmd: "GET", out: 1, var: 1, len: pointsInChunk * sMid });
          }
          opPromises.push(tm.queueAction(task).then((r) => {
            if (logger)
              logger.debug(`${loggerTxt}: fft ${bits4} join  ${i}/${bits4}  ${j + 1}/${nGroups} ${k}/${nChunksPerGroup / 2}`);
            return r;
          }));
        }
      }
      const res = await Promise.all(opPromises);
      for (let j = 0; j < nGroups; j++) {
        for (let k = 0; k < nChunksPerGroup / 2; k++) {
          const o1 = j * nChunksPerGroup + k;
          const o2 = j * nChunksPerGroup + k + nChunksPerGroup / 2;
          const resChunk = res.shift();
          chunks[o1] = resChunk[0];
          chunks[o2] = resChunk[1];
        }
      }
    }
    if (buff instanceof BigBuffer2) {
      buffOut = new BigBuffer2(nPoints * sOut);
    } else {
      buffOut = new Uint8Array(nPoints * sOut);
    }
    if (inverse) {
      buffOut.set(chunks[0].slice((pointsInChunk - 1) * sOut));
      let p = sOut;
      for (let i = nChunks - 1; i > 0; i--) {
        buffOut.set(chunks[i], p);
        p += pointsInChunk * sOut;
        delete chunks[i];
      }
      buffOut.set(chunks[0].slice(0, (pointsInChunk - 1) * sOut), p);
      delete chunks[0];
    } else {
      for (let i = 0; i < nChunks; i++) {
        buffOut.set(chunks[i], pointsInChunk * sOut * i);
        delete chunks[i];
      }
    }
    if (returnArray) {
      return buffer2array2(buffOut, sOut);
    } else {
      return buffOut;
    }
  }
  async function _fftExt(buff, inType, outType, logger, loggerTxt) {
    let b1, b2;
    b1 = buff.slice(0, buff.byteLength / 2);
    b2 = buff.slice(buff.byteLength / 2, buff.byteLength);
    const promises = [];
    [b1, b2] = await _fftJoinExt(b1, b2, "fftJoinExt", Fr.one, Fr.shift, inType, "jacobian", logger, loggerTxt);
    promises.push(_fft(b1, false, "jacobian", outType, logger, loggerTxt));
    promises.push(_fft(b2, false, "jacobian", outType, logger, loggerTxt));
    const res1 = await Promise.all(promises);
    let buffOut;
    if (res1[0].byteLength > 1 << 28) {
      buffOut = new BigBuffer2(res1[0].byteLength * 2);
    } else {
      buffOut = new Uint8Array(res1[0].byteLength * 2);
    }
    buffOut.set(res1[0]);
    buffOut.set(res1[1], res1[0].byteLength);
    return buffOut;
  }
  async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {
    let b1, b2;
    b1 = buff.slice(0, buff.byteLength / 2);
    b2 = buff.slice(buff.byteLength / 2, buff.byteLength);
    const promises = [];
    promises.push(_fft(b1, true, inType, "jacobian", logger, loggerTxt));
    promises.push(_fft(b2, true, inType, "jacobian", logger, loggerTxt));
    [b1, b2] = await Promise.all(promises);
    const res1 = await _fftJoinExt(b1, b2, "fftJoinExtInv", Fr.one, Fr.shiftInv, "jacobian", outType, logger, loggerTxt);
    let buffOut;
    if (res1[0].byteLength > 1 << 28) {
      buffOut = new BigBuffer2(res1[0].byteLength * 2);
    } else {
      buffOut = new Uint8Array(res1[0].byteLength * 2);
    }
    buffOut.set(res1[0]);
    buffOut.set(res1[1], res1[0].byteLength);
    return buffOut;
  }
  async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {
    const MAX_CHUNK_SIZE = 1 << 16;
    const MIN_CHUNK_SIZE = 1 << 4;
    let fnName;
    let fnIn2Mid, fnMid2Out;
    let sOut, sIn, sMid;
    if (groupName == "G1") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
        fnIn2Mid = "g1m_batchToJacobian";
      } else {
        sIn = G.F.n8 * 3;
      }
      sMid = G.F.n8 * 3;
      fnName = "g1m_" + fn;
      if (outType == "affine") {
        fnMid2Out = "g1m_batchToAffine";
        sOut = G.F.n8 * 2;
      } else {
        sOut = G.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
        fnIn2Mid = "g2m_batchToJacobian";
      } else {
        sIn = G.F.n8 * 3;
      }
      fnName = "g2m_" + fn;
      sMid = G.F.n8 * 3;
      if (outType == "affine") {
        fnMid2Out = "g2m_batchToAffine";
        sOut = G.F.n8 * 2;
      } else {
        sOut = G.F.n8 * 3;
      }
    } else if (groupName == "Fr") {
      sIn = Fr.n8;
      sOut = Fr.n8;
      sMid = Fr.n8;
      fnName = "frm_" + fn;
    } else {
      throw new Error("Invalid group");
    }
    if (buff1.byteLength != buff2.byteLength) {
      throw new Error("Invalid buffer size");
    }
    const nPoints = Math.floor(buff1.byteLength / sIn);
    if (nPoints != 1 << log22(nPoints)) {
      throw new Error("Invalid number of points");
    }
    let chunkSize = Math.floor(nPoints / tm.concurrency);
    if (chunkSize < MIN_CHUNK_SIZE)
      chunkSize = MIN_CHUNK_SIZE;
    if (chunkSize > MAX_CHUNK_SIZE)
      chunkSize = MAX_CHUNK_SIZE;
    const opPromises = [];
    for (let i = 0; i < nPoints; i += chunkSize) {
      if (logger)
        logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);
      const n = Math.min(nPoints - i, chunkSize);
      const firstChunk = Fr.mul(first, Fr.exp(inc, i));
      const task = [];
      const b1 = buff1.slice(i * sIn, (i + n) * sIn);
      const b2 = buff2.slice(i * sIn, (i + n) * sIn);
      task.push({ cmd: "ALLOC", var: 0, len: sMid * n });
      task.push({ cmd: "SET", var: 0, buff: b1 });
      task.push({ cmd: "ALLOC", var: 1, len: sMid * n });
      task.push({ cmd: "SET", var: 1, buff: b2 });
      task.push({ cmd: "ALLOCSET", var: 2, buff: firstChunk });
      task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
      if (fnIn2Mid) {
        task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 0 }, { val: n }, { var: 0 }] });
        task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 1 }, { val: n }, { var: 1 }] });
      }
      task.push({ cmd: "CALL", fnName, params: [
        { var: 0 },
        { var: 1 },
        { val: n },
        { var: 2 },
        { var: 3 },
        { val: Fr.s }
      ] });
      if (fnMid2Out) {
        task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: n }, { var: 0 }] });
        task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 1 }, { val: n }, { var: 1 }] });
      }
      task.push({ cmd: "GET", out: 0, var: 0, len: n * sOut });
      task.push({ cmd: "GET", out: 1, var: 1, len: n * sOut });
      opPromises.push(
        tm.queueAction(task).then((r) => {
          if (logger)
            logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);
          return r;
        })
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut1;
    let fullBuffOut2;
    if (nPoints * sOut > 1 << 28) {
      fullBuffOut1 = new BigBuffer2(nPoints * sOut);
      fullBuffOut2 = new BigBuffer2(nPoints * sOut);
    } else {
      fullBuffOut1 = new Uint8Array(nPoints * sOut);
      fullBuffOut2 = new Uint8Array(nPoints * sOut);
    }
    let p = 0;
    for (let i = 0; i < result.length; i++) {
      fullBuffOut1.set(result[i][0], p);
      fullBuffOut2.set(result[i][1], p);
      p += result[i][0].byteLength;
    }
    return [fullBuffOut1, fullBuffOut2];
  }
  G.fft = async function(buff, inType, outType, logger, loggerTxt) {
    return await _fft(buff, false, inType, outType, logger, loggerTxt);
  };
  G.ifft = async function(buff, inType, outType, logger, loggerTxt) {
    return await _fft(buff, true, inType, outType, logger, loggerTxt);
  };
  G.lagrangeEvaluations = async function(buff, inType, outType, logger, loggerTxt) {
    inType = inType || "affine";
    outType = outType || "affine";
    let sIn;
    if (groupName == "G1") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
      } else {
        sIn = G.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
      } else {
        sIn = G.F.n8 * 3;
      }
    } else if (groupName == "Fr") {
      sIn = Fr.n8;
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = buff.byteLength / sIn;
    const bits4 = log22(nPoints);
    if (2 ** bits4 * sIn != buff.byteLength) {
      if (logger)
        logger.error("lagrangeEvaluations iinvalid input size");
      throw new Error("lagrangeEvaluations invalid Input size");
    }
    if (bits4 <= Fr.s) {
      return await G.ifft(buff, inType, outType, logger, loggerTxt);
    }
    if (bits4 > Fr.s + 1) {
      if (logger)
        logger.error("lagrangeEvaluations input too big");
      throw new Error("lagrangeEvaluations input too big");
    }
    let t0 = buff.slice(0, buff.byteLength / 2);
    let t1 = buff.slice(buff.byteLength / 2, buff.byteLength);
    const shiftToSmallM = Fr.exp(Fr.shift, nPoints / 2);
    const sConst = Fr.inv(Fr.sub(Fr.one, shiftToSmallM));
    [t0, t1] = await _fftJoinExt(t0, t1, "prepareLagrangeEvaluation", sConst, Fr.shiftInv, inType, "jacobian", logger, loggerTxt + " prep");
    const promises = [];
    promises.push(_fft(t0, true, "jacobian", outType, logger, loggerTxt + " t0"));
    promises.push(_fft(t1, true, "jacobian", outType, logger, loggerTxt + " t1"));
    [t0, t1] = await Promise.all(promises);
    let buffOut;
    if (t0.byteLength > 1 << 28) {
      buffOut = new BigBuffer2(t0.byteLength * 2);
    } else {
      buffOut = new Uint8Array(t0.byteLength * 2);
    }
    buffOut.set(t0);
    buffOut.set(t1, t0.byteLength);
    return buffOut;
  };
  G.fftMix = async function fftMix(buff) {
    const sG = G.F.n8 * 3;
    let fnName, fnFFTJoin;
    if (groupName == "G1") {
      fnName = "g1m_fftMix";
      fnFFTJoin = "g1m_fftJoin";
    } else if (groupName == "G2") {
      fnName = "g2m_fftMix";
      fnFFTJoin = "g2m_fftJoin";
    } else if (groupName == "Fr") {
      fnName = "frm_fftMix";
      fnFFTJoin = "frm_fftJoin";
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buff.byteLength / sG);
    const power = log22(nPoints);
    let nChunks = 1 << log22(tm.concurrency);
    if (nPoints <= nChunks * 2)
      nChunks = 1;
    const pointsPerChunk = nPoints / nChunks;
    const powerChunk = log22(pointsPerChunk);
    const opPromises = [];
    for (let i = 0; i < nChunks; i++) {
      const task = [];
      const b = buff.slice(i * pointsPerChunk * sG, (i + 1) * pointsPerChunk * sG);
      task.push({ cmd: "ALLOCSET", var: 0, buff: b });
      for (let j = 1; j <= powerChunk; j++) {
        task.push({ cmd: "CALL", fnName, params: [
          { var: 0 },
          { val: pointsPerChunk },
          { val: j }
        ] });
      }
      task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    const chunks = [];
    for (let i = 0; i < result.length; i++)
      chunks[i] = result[i][0];
    for (let i = powerChunk + 1; i <= power; i++) {
      const nGroups = 1 << power - i;
      const nChunksPerGroup = nChunks / nGroups;
      const opPromises2 = [];
      for (let j = 0; j < nGroups; j++) {
        for (let k = 0; k < nChunksPerGroup / 2; k++) {
          const first = Fr.exp(Fr.w[i], k * pointsPerChunk);
          const inc = Fr.w[i];
          const o1 = j * nChunksPerGroup + k;
          const o2 = j * nChunksPerGroup + k + nChunksPerGroup / 2;
          const task = [];
          task.push({ cmd: "ALLOCSET", var: 0, buff: chunks[o1] });
          task.push({ cmd: "ALLOCSET", var: 1, buff: chunks[o2] });
          task.push({ cmd: "ALLOCSET", var: 2, buff: first });
          task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
          task.push({ cmd: "CALL", fnName: fnFFTJoin, params: [
            { var: 0 },
            { var: 1 },
            { val: pointsPerChunk },
            { var: 2 },
            { var: 3 }
          ] });
          task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
          task.push({ cmd: "GET", out: 1, var: 1, len: pointsPerChunk * sG });
          opPromises2.push(tm.queueAction(task));
        }
      }
      const res = await Promise.all(opPromises2);
      for (let j = 0; j < nGroups; j++) {
        for (let k = 0; k < nChunksPerGroup / 2; k++) {
          const o1 = j * nChunksPerGroup + k;
          const o2 = j * nChunksPerGroup + k + nChunksPerGroup / 2;
          const resChunk = res.shift();
          chunks[o1] = resChunk[0];
          chunks[o2] = resChunk[1];
        }
      }
    }
    let fullBuffOut;
    if (buff instanceof BigBuffer2) {
      fullBuffOut = new BigBuffer2(nPoints * sG);
    } else {
      fullBuffOut = new Uint8Array(nPoints * sG);
    }
    let p = 0;
    for (let i = 0; i < nChunks; i++) {
      fullBuffOut.set(chunks[i], p);
      p += chunks[i].byteLength;
    }
    return fullBuffOut;
  };
  G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {
    const sG = G.F.n8 * 3;
    let fnName;
    if (groupName == "G1") {
      fnName = "g1m_fftJoin";
    } else if (groupName == "G2") {
      fnName = "g2m_fftJoin";
    } else if (groupName == "Fr") {
      fnName = "frm_fftJoin";
    } else {
      throw new Error("Invalid group");
    }
    if (buff1.byteLength != buff2.byteLength) {
      throw new Error("Invalid buffer size");
    }
    const nPoints = Math.floor(buff1.byteLength / sG);
    if (nPoints != 1 << log22(nPoints)) {
      throw new Error("Invalid number of points");
    }
    let nChunks = 1 << log22(tm.concurrency);
    if (nPoints <= nChunks * 2)
      nChunks = 1;
    const pointsPerChunk = nPoints / nChunks;
    const opPromises = [];
    for (let i = 0; i < nChunks; i++) {
      const task = [];
      const firstChunk = Fr.mul(first, Fr.exp(inc, i * pointsPerChunk));
      const b1 = buff1.slice(i * pointsPerChunk * sG, (i + 1) * pointsPerChunk * sG);
      const b2 = buff2.slice(i * pointsPerChunk * sG, (i + 1) * pointsPerChunk * sG);
      task.push({ cmd: "ALLOCSET", var: 0, buff: b1 });
      task.push({ cmd: "ALLOCSET", var: 1, buff: b2 });
      task.push({ cmd: "ALLOCSET", var: 2, buff: firstChunk });
      task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
      task.push({ cmd: "CALL", fnName, params: [
        { var: 0 },
        { var: 1 },
        { val: pointsPerChunk },
        { var: 2 },
        { var: 3 }
      ] });
      task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
      task.push({ cmd: "GET", out: 1, var: 1, len: pointsPerChunk * sG });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut1;
    let fullBuffOut2;
    if (buff1 instanceof BigBuffer2) {
      fullBuffOut1 = new BigBuffer2(nPoints * sG);
      fullBuffOut2 = new BigBuffer2(nPoints * sG);
    } else {
      fullBuffOut1 = new Uint8Array(nPoints * sG);
      fullBuffOut2 = new Uint8Array(nPoints * sG);
    }
    let p = 0;
    for (let i = 0; i < result.length; i++) {
      fullBuffOut1.set(result[i][0], p);
      fullBuffOut2.set(result[i][1], p);
      p += result[i][0].byteLength;
    }
    return [fullBuffOut1, fullBuffOut2];
  };
  G.fftFinal = async function fftFinal(buff, factor) {
    const sG = G.F.n8 * 3;
    const sGout = G.F.n8 * 2;
    let fnName, fnToAffine;
    if (groupName == "G1") {
      fnName = "g1m_fftFinal";
      fnToAffine = "g1m_batchToAffine";
    } else if (groupName == "G2") {
      fnName = "g2m_fftFinal";
      fnToAffine = "g2m_batchToAffine";
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buff.byteLength / sG);
    if (nPoints != 1 << log22(nPoints)) {
      throw new Error("Invalid number of points");
    }
    const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
    const opPromises = [];
    for (let i = 0; i < tm.concurrency; i++) {
      let n;
      if (i < tm.concurrency - 1) {
        n = pointsPerChunk;
      } else {
        n = nPoints - i * pointsPerChunk;
      }
      if (n == 0)
        continue;
      const task = [];
      const b = buff.slice(i * pointsPerChunk * sG, (i * pointsPerChunk + n) * sG);
      task.push({ cmd: "ALLOCSET", var: 0, buff: b });
      task.push({ cmd: "ALLOCSET", var: 1, buff: factor });
      task.push({ cmd: "CALL", fnName, params: [
        { var: 0 },
        { val: n },
        { var: 1 }
      ] });
      task.push({ cmd: "CALL", fnName: fnToAffine, params: [
        { var: 0 },
        { val: n },
        { var: 0 }
      ] });
      task.push({ cmd: "GET", out: 0, var: 0, len: n * sGout });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut;
    if (buff instanceof BigBuffer2) {
      fullBuffOut = new BigBuffer2(nPoints * sGout);
    } else {
      fullBuffOut = new Uint8Array(nPoints * sGout);
    }
    let p = 0;
    for (let i = result.length - 1; i >= 0; i--) {
      fullBuffOut.set(result[i][0], p);
      p += result[i][0].byteLength;
    }
    return fullBuffOut;
  };
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/engine.js
async function buildEngine2(params) {
  const tm = await buildThreadManager2(params.wasm, params.singleThread);
  const curve2 = {};
  curve2.q = e2(params.wasm.q.toString());
  curve2.r = e2(params.wasm.r.toString());
  curve2.name = params.name;
  curve2.tm = tm;
  curve2.prePSize = params.wasm.prePSize;
  curve2.preQSize = params.wasm.preQSize;
  curve2.Fr = new WasmField12(tm, "frm", params.n8r, params.r);
  curve2.F1 = new WasmField12(tm, "f1m", params.n8q, params.q);
  curve2.F2 = new WasmField22(tm, "f2m", curve2.F1);
  curve2.G1 = new WasmCurve2(tm, "g1m", curve2.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);
  curve2.G2 = new WasmCurve2(tm, "g2m", curve2.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);
  curve2.F6 = new WasmField32(tm, "f6m", curve2.F2);
  curve2.F12 = new WasmField22(tm, "ftm", curve2.F6);
  curve2.Gt = curve2.F12;
  buildBatchApplyKey2(curve2, "G1");
  buildBatchApplyKey2(curve2, "G2");
  buildBatchApplyKey2(curve2, "Fr");
  buildMultiexp2(curve2, "G1");
  buildMultiexp2(curve2, "G2");
  buildFFT2(curve2, "G1");
  buildFFT2(curve2, "G2");
  buildFFT2(curve2, "Fr");
  buildPairing2(curve2);
  curve2.array2buffer = function(arr, sG) {
    const buff = new Uint8Array(sG * arr.length);
    for (let i = 0; i < arr.length; i++) {
      buff.set(arr[i], i * sG);
    }
    return buff;
  };
  curve2.buffer2array = function(buff, sG) {
    const n = buff.byteLength / sG;
    const arr = new Array(n);
    for (let i = 0; i < n; i++) {
      arr[i] = buff.slice(i * sG, i * sG + sG);
    }
    return arr;
  };
  return curve2;
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js
globalThis.curve_bn128 = null;
async function buildBn1282(singleThread, plugins) {
  const moduleBuilder = new ModuleBuilder();
  moduleBuilder.setMemory(25);
  (0, import_wasmcurves3.buildBn128)(moduleBuilder);
  if (plugins)
    plugins(moduleBuilder);
  const bn128wasm = {};
  bn128wasm.code = moduleBuilder.build();
  bn128wasm.pq = moduleBuilder.modules.f1m.pq;
  bn128wasm.pr = moduleBuilder.modules.frm.pq;
  bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;
  bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;
  bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;
  bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;
  bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;
  bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;
  bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;
  bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;
  bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;
  bn128wasm.n8q = 32;
  bn128wasm.n8r = 32;
  bn128wasm.q = moduleBuilder.modules.bn128.q;
  bn128wasm.r = moduleBuilder.modules.bn128.r;
  if (!singleThread && globalThis.curve_bn128)
    return globalThis.curve_bn128;
  const params = {
    name: "bn128",
    wasm: bn128wasm,
    q: e2("21888242871839275222246405745257275088696311157297823662689037894645226208583"),
    r: e2("21888242871839275222246405745257275088548364400416034343698204186575808495617"),
    n8q: 32,
    n8r: 32,
    cofactorG2: e2("30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d", 16),
    singleThread: singleThread ? true : false
  };
  const curve2 = await buildEngine2(params);
  curve2.terminate = async function() {
    if (!params.singleThread) {
      globalThis.curve_bn128 = null;
      await this.tm.terminate();
    }
  };
  if (!singleThread) {
    globalThis.curve_bn128 = curve2;
  }
  return curve2;
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js
var import_wasmcurves4 = __toESM(require_wasmcurves2(), 1);
globalThis.curve_bls12381 = null;
async function buildBls123812(singleThread, plugins) {
  const moduleBuilder = new ModuleBuilder();
  moduleBuilder.setMemory(25);
  (0, import_wasmcurves4.buildBls12381)(moduleBuilder);
  if (plugins)
    plugins(moduleBuilder);
  const bls12381wasm = {};
  bls12381wasm.code = moduleBuilder.build();
  bls12381wasm.pq = moduleBuilder.modules.f1m.pq;
  bls12381wasm.pr = moduleBuilder.modules.frm.pq;
  bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;
  bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;
  bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;
  bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;
  bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;
  bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;
  bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;
  bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;
  bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;
  bls12381wasm.n8q = 48;
  bls12381wasm.n8r = 32;
  bls12381wasm.q = moduleBuilder.modules.bls12381.q;
  bls12381wasm.r = moduleBuilder.modules.bls12381.r;
  if (!singleThread && globalThis.curve_bls12381)
    return globalThis.curve_bls12381;
  const params = {
    name: "bls12381",
    wasm: bls12381wasm,
    q: e2("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16),
    r: e2("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16),
    n8q: 48,
    n8r: 32,
    cofactorG1: e2("0x396c8c005555e1568c00aaab0000aaab", 16),
    cofactorG2: e2("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5", 16),
    singleThread: singleThread ? true : false
  };
  const curve2 = await buildEngine2(params);
  curve2.terminate = async function() {
    if (!params.singleThread) {
      globalThis.curve_bls12381 = null;
      await this.tm.terminate();
    }
  };
  if (!singleThread) {
    globalThis.curve_bls12381 = curve2;
  }
  return curve2;
}

// ../../node_modules/snarkjs/node_modules/ffjavascript/src/curves.js
var bls12381r2 = e2("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
var bn128r2 = e2("21888242871839275222246405745257275088548364400416034343698204186575808495617");
var bls12381q2 = e2("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
var bn128q2 = e2("21888242871839275222246405745257275088696311157297823662689037894645226208583");

// ../../node_modules/snarkjs/node_modules/ffjavascript/main.js
var Scalar2 = scalar_exports2;
var utils = utils_exports3;

// ../../node_modules/snarkjs/src/curves.js
var bls12381r3 = Scalar2.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
var bn128r3 = Scalar2.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");
var bls12381q3 = Scalar2.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
var bn128q3 = Scalar2.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");
async function getCurveFromQ3(q) {
  let curve2;
  if (Scalar2.eq(q, bn128q3)) {
    curve2 = await buildBn1282();
  } else if (Scalar2.eq(q, bls12381q3)) {
    curve2 = await buildBls123812();
  } else {
    throw new Error(`Curve not supported: ${Scalar2.toString(q)}`);
  }
  return curve2;
}
async function getCurveFromName3(name) {
  let curve2;
  const normName = normalizeName(name);
  if (["BN128", "BN254", "ALTBN128"].indexOf(normName) >= 0) {
    curve2 = await buildBn1282();
  } else if (["BLS12381"].indexOf(normName) >= 0) {
    curve2 = await buildBls123812();
  } else {
    throw new Error(`Curve not supported: ${name}`);
  }
  return curve2;
  function normalizeName(n) {
    return n.toUpperCase().match(/[A-Za-z0-9]+/g).join("");
  }
}

// ../../node_modules/snarkjs/src/misc.js
var import_blake2b_wasm = __toESM(require_blake2b_wasm(), 1);
var _revTable5 = [];
for (let i = 0; i < 256; i++) {
  _revTable5[i] = _revSlow5(i, 8);
}
function _revSlow5(idx, bits4) {
  let res = 0;
  let a = idx;
  for (let i = 0; i < bits4; i++) {
    res <<= 1;
    res = res | a & 1;
    a >>= 1;
  }
  return res;
}
function log23(V) {
  return ((V & 4294901760) !== 0 ? (V &= 4294901760, 16) : 0) | ((V & 4278255360) !== 0 ? (V &= 4278255360, 8) : 0) | ((V & 4042322160) !== 0 ? (V &= 4042322160, 4) : 0) | ((V & 3435973836) !== 0 ? (V &= 3435973836, 2) : 0) | (V & 2863311530) !== 0;
}

// ../../node_modules/snarkjs/src/zkey_constants.js
var GROTH16_PROTOCOL_ID = 1;
var PLONK_PROTOCOL_ID = 2;
var FFLONK_PROTOCOL_ID = 10;

// ../../node_modules/snarkjs/src/fflonk_constants.js
var ZKEY_FF_HEADER_SECTION = 2;

// ../../node_modules/snarkjs/src/zkey_utils.js
async function readG1(fd, curve2, toObject) {
  const buff = await fd.read(curve2.G1.F.n8 * 2);
  const res = curve2.G1.fromRprLEM(buff, 0);
  return toObject ? curve2.G1.toObject(res) : res;
}
async function readG2(fd, curve2, toObject) {
  const buff = await fd.read(curve2.G2.F.n8 * 2);
  const res = curve2.G2.fromRprLEM(buff, 0);
  return toObject ? curve2.G2.toObject(res) : res;
}
async function readHeader(fd, sections, toObject) {
  await startReadUniqueSection(fd, sections, 1);
  const protocolId = await fd.readULE32();
  await endReadSection(fd);
  if (protocolId === GROTH16_PROTOCOL_ID) {
    return await readHeaderGroth16(fd, sections, toObject);
  } else if (protocolId === PLONK_PROTOCOL_ID) {
    return await readHeaderPlonk(fd, sections, toObject);
  } else if (protocolId === FFLONK_PROTOCOL_ID) {
    return await readHeaderFFlonk(fd, sections, toObject);
  } else {
    throw new Error("Protocol not supported: ");
  }
}
async function readHeaderGroth16(fd, sections, toObject) {
  const zkey = {};
  zkey.protocol = "groth16";
  await startReadUniqueSection(fd, sections, 2);
  const n8q = await fd.readULE32();
  zkey.n8q = n8q;
  zkey.q = await readBigInt(fd, n8q);
  const n8r = await fd.readULE32();
  zkey.n8r = n8r;
  zkey.r = await readBigInt(fd, n8r);
  zkey.curve = await getCurveFromQ3(zkey.q);
  zkey.nVars = await fd.readULE32();
  zkey.nPublic = await fd.readULE32();
  zkey.domainSize = await fd.readULE32();
  zkey.power = log23(zkey.domainSize);
  zkey.vk_alpha_1 = await readG1(fd, zkey.curve, toObject);
  zkey.vk_beta_1 = await readG1(fd, zkey.curve, toObject);
  zkey.vk_beta_2 = await readG2(fd, zkey.curve, toObject);
  zkey.vk_gamma_2 = await readG2(fd, zkey.curve, toObject);
  zkey.vk_delta_1 = await readG1(fd, zkey.curve, toObject);
  zkey.vk_delta_2 = await readG2(fd, zkey.curve, toObject);
  await endReadSection(fd);
  return zkey;
}
async function readHeaderPlonk(fd, sections, toObject) {
  const zkey = {};
  zkey.protocol = "plonk";
  await startReadUniqueSection(fd, sections, 2);
  const n8q = await fd.readULE32();
  zkey.n8q = n8q;
  zkey.q = await readBigInt(fd, n8q);
  const n8r = await fd.readULE32();
  zkey.n8r = n8r;
  zkey.r = await readBigInt(fd, n8r);
  zkey.curve = await getCurveFromQ3(zkey.q);
  zkey.nVars = await fd.readULE32();
  zkey.nPublic = await fd.readULE32();
  zkey.domainSize = await fd.readULE32();
  zkey.power = log23(zkey.domainSize);
  zkey.nAdditions = await fd.readULE32();
  zkey.nConstraints = await fd.readULE32();
  zkey.k1 = await fd.read(n8r);
  zkey.k2 = await fd.read(n8r);
  zkey.Qm = await readG1(fd, zkey.curve, toObject);
  zkey.Ql = await readG1(fd, zkey.curve, toObject);
  zkey.Qr = await readG1(fd, zkey.curve, toObject);
  zkey.Qo = await readG1(fd, zkey.curve, toObject);
  zkey.Qc = await readG1(fd, zkey.curve, toObject);
  zkey.S1 = await readG1(fd, zkey.curve, toObject);
  zkey.S2 = await readG1(fd, zkey.curve, toObject);
  zkey.S3 = await readG1(fd, zkey.curve, toObject);
  zkey.X_2 = await readG2(fd, zkey.curve, toObject);
  await endReadSection(fd);
  return zkey;
}
async function readHeaderFFlonk(fd, sections, toObject) {
  const zkey = {};
  zkey.protocol = "fflonk";
  zkey.protocolId = FFLONK_PROTOCOL_ID;
  await startReadUniqueSection(fd, sections, ZKEY_FF_HEADER_SECTION);
  const n8q = await fd.readULE32();
  zkey.n8q = n8q;
  zkey.q = await readBigInt(fd, n8q);
  zkey.curve = await getCurveFromQ3(zkey.q);
  const n8r = await fd.readULE32();
  zkey.n8r = n8r;
  zkey.r = await readBigInt(fd, n8r);
  zkey.nVars = await fd.readULE32();
  zkey.nPublic = await fd.readULE32();
  zkey.domainSize = await fd.readULE32();
  zkey.power = log23(zkey.domainSize);
  zkey.nAdditions = await fd.readULE32();
  zkey.nConstraints = await fd.readULE32();
  zkey.k1 = await fd.read(n8r);
  zkey.k2 = await fd.read(n8r);
  zkey.w3 = await fd.read(n8r);
  zkey.w4 = await fd.read(n8r);
  zkey.w8 = await fd.read(n8r);
  zkey.wr = await fd.read(n8r);
  zkey.X_2 = await readG2(fd, zkey.curve, toObject);
  zkey.C0 = await readG1(fd, zkey.curve, toObject);
  await endReadSection(fd);
  return zkey;
}

// ../../node_modules/snarkjs/src/wtns_utils.js
async function writeBin(fd, witnessBin, prime) {
  await startWriteSection(fd, 1);
  const n8 = (Math.floor((Scalar2.bitLength(prime) - 1) / 64) + 1) * 8;
  await fd.writeULE32(n8);
  await writeBigInt(fd, prime, n8);
  if (witnessBin.byteLength % n8 != 0) {
    throw new Error("Invalid witness length");
  }
  await fd.writeULE32(witnessBin.byteLength / n8);
  await endWriteSection(fd);
  await startWriteSection(fd, 2);
  await fd.write(witnessBin);
  await endWriteSection(fd);
}
async function readHeader2(fd, sections) {
  await startReadUniqueSection(fd, sections, 1);
  const n8 = await fd.readULE32();
  const q = await readBigInt(fd, n8);
  const nWitness = await fd.readULE32();
  await endReadSection(fd);
  return { n8, q, nWitness };
}

// ../../node_modules/snarkjs/src/groth16_prove.js
var { stringifyBigInts: stringifyBigInts2 } = utils;
async function groth16Prove(zkeyFileName, witnessFileName, logger) {
  const { fd: fdWtns, sections: sectionsWtns } = await readBinFile(witnessFileName, "wtns", 2, 1 << 25, 1 << 23);
  const wtns = await readHeader2(fdWtns, sectionsWtns);
  const { fd: fdZKey, sections: sectionsZKey } = await readBinFile(zkeyFileName, "zkey", 2, 1 << 25, 1 << 23);
  const zkey = await readHeader(fdZKey, sectionsZKey);
  if (zkey.protocol != "groth16") {
    throw new Error("zkey file is not groth16");
  }
  if (!Scalar2.eq(zkey.r, wtns.q)) {
    throw new Error("Curve of the witness does not match the curve of the proving key");
  }
  if (wtns.nWitness != zkey.nVars) {
    throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);
  }
  const curve2 = zkey.curve;
  const Fr = curve2.Fr;
  const G1 = curve2.G1;
  const G2 = curve2.G2;
  const power = log23(zkey.domainSize);
  if (logger)
    logger.debug("Reading Wtns");
  const buffWitness = await readSection(fdWtns, sectionsWtns, 2);
  if (logger)
    logger.debug("Reading Coeffs");
  const buffCoeffs = await readSection(fdZKey, sectionsZKey, 4);
  if (logger)
    logger.debug("Building ABC");
  const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve2, zkey, buffWitness, buffCoeffs, logger);
  const inc = power == Fr.s ? curve2.Fr.shift : curve2.Fr.w[power + 1];
  const buffA = await Fr.ifft(buffA_T, "", "", logger, "IFFT_A");
  const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);
  const buffAodd_T = await Fr.fft(buffAodd, "", "", logger, "FFT_A");
  const buffB = await Fr.ifft(buffB_T, "", "", logger, "IFFT_B");
  const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);
  const buffBodd_T = await Fr.fft(buffBodd, "", "", logger, "FFT_B");
  const buffC = await Fr.ifft(buffC_T, "", "", logger, "IFFT_C");
  const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);
  const buffCodd_T = await Fr.fft(buffCodd, "", "", logger, "FFT_C");
  if (logger)
    logger.debug("Join ABC");
  const buffPodd_T = await joinABC(curve2, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);
  let proof = {};
  if (logger)
    logger.debug("Reading A Points");
  const buffBasesA = await readSection(fdZKey, sectionsZKey, 5);
  proof.pi_a = await curve2.G1.multiExpAffine(buffBasesA, buffWitness, logger, "multiexp A");
  if (logger)
    logger.debug("Reading B1 Points");
  const buffBasesB1 = await readSection(fdZKey, sectionsZKey, 6);
  let pib1 = await curve2.G1.multiExpAffine(buffBasesB1, buffWitness, logger, "multiexp B1");
  if (logger)
    logger.debug("Reading B2 Points");
  const buffBasesB2 = await readSection(fdZKey, sectionsZKey, 7);
  proof.pi_b = await curve2.G2.multiExpAffine(buffBasesB2, buffWitness, logger, "multiexp B2");
  if (logger)
    logger.debug("Reading C Points");
  const buffBasesC = await readSection(fdZKey, sectionsZKey, 8);
  proof.pi_c = await curve2.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic + 1) * curve2.Fr.n8), logger, "multiexp C");
  if (logger)
    logger.debug("Reading H Points");
  const buffBasesH = await readSection(fdZKey, sectionsZKey, 9);
  const resH = await curve2.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, "multiexp H");
  const r = curve2.Fr.random();
  const s = curve2.Fr.random();
  proof.pi_a = G1.add(proof.pi_a, zkey.vk_alpha_1);
  proof.pi_a = G1.add(proof.pi_a, G1.timesFr(zkey.vk_delta_1, r));
  proof.pi_b = G2.add(proof.pi_b, zkey.vk_beta_2);
  proof.pi_b = G2.add(proof.pi_b, G2.timesFr(zkey.vk_delta_2, s));
  pib1 = G1.add(pib1, zkey.vk_beta_1);
  pib1 = G1.add(pib1, G1.timesFr(zkey.vk_delta_1, s));
  proof.pi_c = G1.add(proof.pi_c, resH);
  proof.pi_c = G1.add(proof.pi_c, G1.timesFr(proof.pi_a, s));
  proof.pi_c = G1.add(proof.pi_c, G1.timesFr(pib1, r));
  proof.pi_c = G1.add(proof.pi_c, G1.timesFr(zkey.vk_delta_1, Fr.neg(Fr.mul(r, s))));
  let publicSignals = [];
  for (let i = 1; i <= zkey.nPublic; i++) {
    const b = buffWitness.slice(i * Fr.n8, i * Fr.n8 + Fr.n8);
    publicSignals.push(Scalar2.fromRprLE(b));
  }
  proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));
  proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));
  proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));
  proof.protocol = "groth16";
  proof.curve = curve2.name;
  await fdZKey.close();
  await fdWtns.close();
  proof = stringifyBigInts2(proof);
  publicSignals = stringifyBigInts2(publicSignals);
  return { proof, publicSignals };
}
async function buildABC1(curve2, zkey, witness, coeffs, logger) {
  const n8 = curve2.Fr.n8;
  const sCoef = 4 * 3 + zkey.n8r;
  const nCoef = (coeffs.byteLength - 4) / sCoef;
  const outBuffA = new BigBuffer2(zkey.domainSize * n8);
  const outBuffB = new BigBuffer2(zkey.domainSize * n8);
  const outBuffC = new BigBuffer2(zkey.domainSize * n8);
  const outBuf = [outBuffA, outBuffB];
  for (let i = 0; i < nCoef; i++) {
    if (logger && i % 1e6 == 0)
      logger.debug(`QAP AB: ${i}/${nCoef}`);
    const buffCoef = coeffs.slice(4 + i * sCoef, 4 + i * sCoef + sCoef);
    const buffCoefV = new DataView(buffCoef.buffer);
    const m = buffCoefV.getUint32(0, true);
    const c = buffCoefV.getUint32(4, true);
    const s = buffCoefV.getUint32(8, true);
    const coef = buffCoef.slice(12, 12 + n8);
    outBuf[m].set(
      curve2.Fr.add(
        outBuf[m].slice(c * n8, c * n8 + n8),
        curve2.Fr.mul(coef, witness.slice(s * n8, s * n8 + n8))
      ),
      c * n8
    );
  }
  for (let i = 0; i < zkey.domainSize; i++) {
    if (logger && i % 1e6 == 0)
      logger.debug(`QAP C: ${i}/${zkey.domainSize}`);
    outBuffC.set(
      curve2.Fr.mul(
        outBuffA.slice(i * n8, i * n8 + n8),
        outBuffB.slice(i * n8, i * n8 + n8)
      ),
      i * n8
    );
  }
  return [outBuffA, outBuffB, outBuffC];
}
async function joinABC(curve2, zkey, a, b, c, logger) {
  const MAX_CHUNK_SIZE = 1 << 22;
  const n8 = curve2.Fr.n8;
  const nElements = Math.floor(a.byteLength / curve2.Fr.n8);
  const promises = [];
  for (let i = 0; i < nElements; i += MAX_CHUNK_SIZE) {
    if (logger)
      logger.debug(`JoinABC: ${i}/${nElements}`);
    const n = Math.min(nElements - i, MAX_CHUNK_SIZE);
    const task = [];
    const aChunk = a.slice(i * n8, (i + n) * n8);
    const bChunk = b.slice(i * n8, (i + n) * n8);
    const cChunk = c.slice(i * n8, (i + n) * n8);
    task.push({ cmd: "ALLOCSET", var: 0, buff: aChunk });
    task.push({ cmd: "ALLOCSET", var: 1, buff: bChunk });
    task.push({ cmd: "ALLOCSET", var: 2, buff: cChunk });
    task.push({ cmd: "ALLOC", var: 3, len: n * n8 });
    task.push({ cmd: "CALL", fnName: "qap_joinABC", params: [
      { var: 0 },
      { var: 1 },
      { var: 2 },
      { val: n },
      { var: 3 }
    ] });
    task.push({ cmd: "CALL", fnName: "frm_batchFromMontgomery", params: [
      { var: 3 },
      { val: n },
      { var: 3 }
    ] });
    task.push({ cmd: "GET", out: 0, var: 3, len: n * n8 });
    promises.push(curve2.tm.queueAction(task));
  }
  const result = await Promise.all(promises);
  let outBuff;
  if (a instanceof BigBuffer2) {
    outBuff = new BigBuffer2(a.byteLength);
  } else {
    outBuff = new Uint8Array(a.byteLength);
  }
  let p = 0;
  for (let i = 0; i < result.length; i++) {
    outBuff.set(result[i][0], p);
    p += result[i][0].byteLength;
  }
  return outBuff;
}

// ../../node_modules/circom_runtime/js/utils.js
function flatArray(a) {
  var res = [];
  fillArray(res, a);
  return res;
  function fillArray(res2, a2) {
    if (Array.isArray(a2)) {
      for (let i = 0; i < a2.length; i++) {
        fillArray(res2, a2[i]);
      }
    } else {
      res2.push(a2);
    }
  }
}
function fnvHash(str) {
  const uint64_max = BigInt(2) ** BigInt(64);
  let hash = BigInt("0xCBF29CE484222325");
  for (var i = 0; i < str.length; i++) {
    hash ^= BigInt(str[i].charCodeAt());
    hash *= BigInt(1099511628211);
    hash %= uint64_max;
  }
  let shash = hash.toString(16);
  let n = 16 - shash.length;
  shash = "0".repeat(n).concat(shash);
  return shash;
}
function toArray32(s, size) {
  const res = [];
  let rem = BigInt(s);
  const radix = BigInt(4294967296);
  while (rem) {
    res.unshift(Number(rem % radix));
    rem = rem / radix;
  }
  if (size) {
    var i = size - res.length;
    while (i > 0) {
      res.unshift(0);
      i--;
    }
  }
  return res;
}

// ../../node_modules/ffjavascript/src/scalar.js
var scalar_exports3 = {};
__export(scalar_exports3, {
  abs: () => abs3,
  add: () => add3,
  band: () => band3,
  bitLength: () => bitLength4,
  bits: () => bits3,
  bor: () => bor3,
  bxor: () => bxor3,
  div: () => div3,
  e: () => e3,
  eq: () => eq3,
  exp: () => exp5,
  fromArray: () => fromArray3,
  fromRprBE: () => fromRprBE3,
  fromRprLE: () => fromRprLE3,
  fromString: () => fromString3,
  geq: () => geq3,
  gt: () => gt3,
  isNegative: () => isNegative4,
  isOdd: () => isOdd3,
  isZero: () => isZero4,
  land: () => land3,
  leq: () => leq3,
  lnot: () => lnot3,
  lor: () => lor3,
  lt: () => lt3,
  mod: () => mod3,
  mul: () => mul3,
  naf: () => naf3,
  neg: () => neg3,
  neq: () => neq3,
  one: () => one3,
  pow: () => pow3,
  shiftLeft: () => shiftLeft3,
  shiftRight: () => shiftRight3,
  shl: () => shl3,
  shr: () => shr3,
  square: () => square3,
  sub: () => sub3,
  toArray: () => toArray3,
  toLEBuff: () => toLEBuff3,
  toNumber: () => toNumber4,
  toRprBE: () => toRprBE3,
  toRprLE: () => toRprLE3,
  toString: () => toString3,
  zero: () => zero3
});
var hexLen3 = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];
function fromString3(s, radix) {
  if (!radix || radix == 10) {
    return BigInt(s);
  } else if (radix == 16) {
    if (s.slice(0, 2) == "0x") {
      return BigInt(s);
    } else {
      return BigInt("0x" + s);
    }
  }
}
var e3 = fromString3;
function fromArray3(a, radix) {
  let acc = BigInt(0);
  radix = BigInt(radix);
  for (let i = 0; i < a.length; i++) {
    acc = acc * radix + BigInt(a[i]);
  }
  return acc;
}
function bitLength4(a) {
  const aS = a.toString(16);
  return (aS.length - 1) * 4 + hexLen3[parseInt(aS[0], 16)];
}
function isNegative4(a) {
  return BigInt(a) < BigInt(0);
}
function isZero4(a) {
  return !a;
}
function shiftLeft3(a, n) {
  return BigInt(a) << BigInt(n);
}
function shiftRight3(a, n) {
  return BigInt(a) >> BigInt(n);
}
var shl3 = shiftLeft3;
var shr3 = shiftRight3;
function isOdd3(a) {
  return (BigInt(a) & BigInt(1)) == BigInt(1);
}
function naf3(n) {
  let E = BigInt(n);
  const res = [];
  while (E) {
    if (E & BigInt(1)) {
      const z = 2 - Number(E % BigInt(4));
      res.push(z);
      E = E - BigInt(z);
    } else {
      res.push(0);
    }
    E = E >> BigInt(1);
  }
  return res;
}
function bits3(n) {
  let E = BigInt(n);
  const res = [];
  while (E) {
    if (E & BigInt(1)) {
      res.push(1);
    } else {
      res.push(0);
    }
    E = E >> BigInt(1);
  }
  return res;
}
function toNumber4(s) {
  if (s > BigInt(Number.MAX_SAFE_INTEGER)) {
    throw new Error("Number too big");
  }
  return Number(s);
}
function toArray3(s, radix) {
  const res = [];
  let rem = BigInt(s);
  radix = BigInt(radix);
  while (rem) {
    res.unshift(Number(rem % radix));
    rem = rem / radix;
  }
  return res;
}
function add3(a, b) {
  return BigInt(a) + BigInt(b);
}
function sub3(a, b) {
  return BigInt(a) - BigInt(b);
}
function neg3(a) {
  return -BigInt(a);
}
function mul3(a, b) {
  return BigInt(a) * BigInt(b);
}
function square3(a) {
  return BigInt(a) * BigInt(a);
}
function pow3(a, b) {
  return BigInt(a) ** BigInt(b);
}
function exp5(a, b) {
  return BigInt(a) ** BigInt(b);
}
function abs3(a) {
  return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);
}
function div3(a, b) {
  return BigInt(a) / BigInt(b);
}
function mod3(a, b) {
  return BigInt(a) % BigInt(b);
}
function eq3(a, b) {
  return BigInt(a) == BigInt(b);
}
function neq3(a, b) {
  return BigInt(a) != BigInt(b);
}
function lt3(a, b) {
  return BigInt(a) < BigInt(b);
}
function gt3(a, b) {
  return BigInt(a) > BigInt(b);
}
function leq3(a, b) {
  return BigInt(a) <= BigInt(b);
}
function geq3(a, b) {
  return BigInt(a) >= BigInt(b);
}
function band3(a, b) {
  return BigInt(a) & BigInt(b);
}
function bor3(a, b) {
  return BigInt(a) | BigInt(b);
}
function bxor3(a, b) {
  return BigInt(a) ^ BigInt(b);
}
function land3(a, b) {
  return BigInt(a) && BigInt(b);
}
function lor3(a, b) {
  return BigInt(a) || BigInt(b);
}
function lnot3(a) {
  return !BigInt(a);
}
function toRprLE3(buff, o, e4, n8) {
  const s = "0000000" + e4.toString(16);
  const v = new Uint32Array(buff.buffer, o, n8 / 4);
  const l = ((s.length - 7) * 4 - 1 >> 5) + 1;
  for (let i = 0; i < l; i++)
    v[i] = parseInt(s.substring(s.length - 8 * i - 8, s.length - 8 * i), 16);
  for (let i = l; i < v.length; i++)
    v[i] = 0;
  for (let i = v.length * 4; i < n8; i++)
    buff[i] = toNumber4(band3(shiftRight3(e4, i * 8), 255));
}
function toRprBE3(buff, o, e4, n8) {
  const s = "0000000" + e4.toString(16);
  const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
  const l = ((s.length - 7) * 4 - 1 >> 5) + 1;
  for (let i = 0; i < l; i++)
    v.setUint32(n8 - i * 4 - 4, parseInt(s.substring(s.length - 8 * i - 8, s.length - 8 * i), 16), false);
  for (let i = 0; i < n8 / 4 - l; i++)
    v[i] = 0;
}
function fromRprLE3(buff, o, n8) {
  n8 = n8 || buff.byteLength;
  o = o || 0;
  const v = new Uint32Array(buff.buffer, o, n8 / 4);
  const a = new Array(n8 / 4);
  v.forEach((ch, i) => a[a.length - i - 1] = ch.toString(16).padStart(8, "0"));
  return fromString3(a.join(""), 16);
}
function fromRprBE3(buff, o, n8) {
  n8 = n8 || buff.byteLength;
  o = o || 0;
  const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
  const a = new Array(n8 / 4);
  for (let i = 0; i < n8 / 4; i++) {
    a[i] = v.getUint32(i * 4, false).toString(16).padStart(8, "0");
  }
  return fromString3(a.join(""), 16);
}
function toString3(a, radix) {
  return a.toString(radix);
}
function toLEBuff3(a) {
  const buff = new Uint8Array(Math.floor((bitLength4(a) - 1) / 8) + 1);
  toRprLE3(buff, 0, a, buff.byteLength);
  return buff;
}
var zero3 = e3(0);
var one3 = e3(1);

// ../../node_modules/ffjavascript/src/polfield.js
var _revTable6 = [];
for (let i = 0; i < 256; i++) {
  _revTable6[i] = _revSlow6(i, 8);
}
function _revSlow6(idx, bits4) {
  let res = 0;
  let a = idx;
  for (let i = 0; i < bits4; i++) {
    res <<= 1;
    res = res | a & 1;
    a >>= 1;
  }
  return res;
}

// ../../node_modules/ffjavascript/src/futils.js
function exp6(F, base, e4) {
  if (isZero4(e4))
    return F.one;
  const n = bits3(e4);
  if (n.length == 0)
    return F.one;
  let res = base;
  for (let i = n.length - 2; i >= 0; i--) {
    res = F.square(res);
    if (n[i]) {
      res = F.mul(res, base);
    }
  }
  return res;
}

// ../../node_modules/ffjavascript/src/fsqrt.js
function buildSqrt3(F) {
  if (F.m % 2 == 1) {
    if (eq3(mod3(F.p, 4), 1)) {
      if (eq3(mod3(F.p, 8), 1)) {
        if (eq3(mod3(F.p, 16), 1)) {
          alg5_tonelliShanks(F);
        } else if (eq3(mod3(F.p, 16), 9)) {
          alg4_kong(F);
        } else {
          throw new Error("Field withot sqrt");
        }
      } else if (eq3(mod3(F.p, 8), 5)) {
        alg3_atkin(F);
      } else {
        throw new Error("Field withot sqrt");
      }
    } else if (eq3(mod3(F.p, 4), 3)) {
      alg2_shanks(F);
    }
  } else {
    const pm2mod4 = mod3(pow3(F.p, F.m / 2), 4);
    if (pm2mod4 == 1) {
      alg10_adj(F);
    } else if (pm2mod4 == 3) {
      alg9_adj(F);
    } else {
      alg8_complex(F);
    }
  }
}
function alg5_tonelliShanks(F) {
  F.sqrt_q = pow3(F.p, F.m);
  F.sqrt_s = 0;
  F.sqrt_t = sub3(F.sqrt_q, 1);
  while (!isOdd3(F.sqrt_t)) {
    F.sqrt_s = F.sqrt_s + 1;
    F.sqrt_t = div3(F.sqrt_t, 2);
  }
  let c0 = F.one;
  while (F.eq(c0, F.one)) {
    const c = F.random();
    F.sqrt_z = F.pow(c, F.sqrt_t);
    c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s - 1));
  }
  F.sqrt_tm1d2 = div3(sub3(F.sqrt_t, 1), 2);
  F.sqrt = function(a) {
    const F2 = this;
    if (F2.isZero(a))
      return F2.zero;
    let w = F2.pow(a, F2.sqrt_tm1d2);
    const a0 = F2.pow(F2.mul(F2.square(w), a), 2 ** (F2.sqrt_s - 1));
    if (F2.eq(a0, F2.negone))
      return null;
    let v = F2.sqrt_s;
    let x = F2.mul(a, w);
    let b = F2.mul(x, w);
    let z = F2.sqrt_z;
    while (!F2.eq(b, F2.one)) {
      let b2k = F2.square(b);
      let k = 1;
      while (!F2.eq(b2k, F2.one)) {
        b2k = F2.square(b2k);
        k++;
      }
      w = z;
      for (let i = 0; i < v - k - 1; i++) {
        w = F2.square(w);
      }
      z = F2.square(w);
      b = F2.mul(b, z);
      x = F2.mul(x, w);
      v = k;
    }
    return F2.geq(x, F2.zero) ? x : F2.neg(x);
  };
}
function alg4_kong(F) {
  F.sqrt = function() {
    throw new Error("Sqrt alg 4 not implemented");
  };
}
function alg3_atkin(F) {
  F.sqrt = function() {
    throw new Error("Sqrt alg 3 not implemented");
  };
}
function alg2_shanks(F) {
  F.sqrt_q = pow3(F.p, F.m);
  F.sqrt_e1 = div3(sub3(F.sqrt_q, 3), 4);
  F.sqrt = function(a) {
    if (this.isZero(a))
      return this.zero;
    const a1 = this.pow(a, this.sqrt_e1);
    const a0 = this.mul(this.square(a1), a);
    if (this.eq(a0, this.negone))
      return null;
    const x = this.mul(a1, a);
    return F.geq(x, F.zero) ? x : F.neg(x);
  };
}
function alg10_adj(F) {
  F.sqrt = function() {
    throw new Error("Sqrt alg 10 not implemented");
  };
}
function alg9_adj(F) {
  F.sqrt_q = pow3(F.p, F.m / 2);
  F.sqrt_e34 = div3(sub3(F.sqrt_q, 3), 4);
  F.sqrt_e12 = div3(sub3(F.sqrt_q, 1), 2);
  F.frobenius = function(n, x) {
    if (n % 2 == 1) {
      return F.conjugate(x);
    } else {
      return x;
    }
  };
  F.sqrt = function(a) {
    const F2 = this;
    const a1 = F2.pow(a, F2.sqrt_e34);
    const alfa = F2.mul(F2.square(a1), a);
    const a0 = F2.mul(F2.frobenius(1, alfa), alfa);
    if (F2.eq(a0, F2.negone))
      return null;
    const x0 = F2.mul(a1, a);
    let x;
    if (F2.eq(alfa, F2.negone)) {
      x = F2.mul(x0, [F2.F.zero, F2.F.one]);
    } else {
      const b = F2.pow(F2.add(F2.one, alfa), F2.sqrt_e12);
      x = F2.mul(b, x0);
    }
    return F2.geq(x, F2.zero) ? x : F2.neg(x);
  };
}
function alg8_complex(F) {
  F.sqrt = function() {
    throw new Error("Sqrt alg 8 not implemented");
  };
}

// ../../node_modules/ffjavascript/src/random.js
var import_crypto4 = __toESM(require("crypto"), 1);
function getRandomBytes3(n) {
  let array = new Uint8Array(n);
  if (process.browser) {
    if (typeof globalThis.crypto !== "undefined") {
      globalThis.crypto.getRandomValues(array);
    } else {
      for (let i = 0; i < n; i++) {
        array[i] = Math.random() * 4294967296 >>> 0;
      }
    }
  } else {
    import_crypto4.default.randomFillSync(array);
  }
  return array;
}

// ../../node_modules/ffjavascript/src/fft.js
var FFT3 = class {
  constructor(G, F, opMulGF) {
    this.F = F;
    this.G = G;
    this.opMulGF = opMulGF;
    let rem = F.sqrt_t || F.t;
    let s = F.sqrt_s || F.s;
    let nqr = F.one;
    while (F.eq(F.pow(nqr, F.half), F.one))
      nqr = F.add(nqr, F.one);
    this.w = new Array(s + 1);
    this.wi = new Array(s + 1);
    this.w[s] = this.F.pow(nqr, rem);
    this.wi[s] = this.F.inv(this.w[s]);
    let n = s - 1;
    while (n >= 0) {
      this.w[n] = this.F.square(this.w[n + 1]);
      this.wi[n] = this.F.square(this.wi[n + 1]);
      n--;
    }
    this.roots = [];
    this._setRoots(Math.min(s, 15));
  }
  _setRoots(n) {
    for (let i = n; i >= 0 && !this.roots[i]; i--) {
      let r = this.F.one;
      const nroots = 1 << i;
      const rootsi = new Array(nroots);
      for (let j = 0; j < nroots; j++) {
        rootsi[j] = r;
        r = this.F.mul(r, this.w[i]);
      }
      this.roots[i] = rootsi;
    }
  }
  fft(p) {
    if (p.length <= 1)
      return p;
    const bits4 = log24(p.length - 1) + 1;
    this._setRoots(bits4);
    const m = 1 << bits4;
    if (p.length != m) {
      throw new Error("Size must be multiple of 2");
    }
    const res = __fft(this, p, bits4, 0, 1);
    return res;
  }
  ifft(p) {
    if (p.length <= 1)
      return p;
    const bits4 = log24(p.length - 1) + 1;
    this._setRoots(bits4);
    const m = 1 << bits4;
    if (p.length != m) {
      throw new Error("Size must be multiple of 2");
    }
    const res = __fft(this, p, bits4, 0, 1);
    const twoinvm = this.F.inv(this.F.mulScalar(this.F.one, m));
    const resn = new Array(m);
    for (let i = 0; i < m; i++) {
      resn[i] = this.opMulGF(res[(m - i) % m], twoinvm);
    }
    return resn;
  }
};
function log24(V) {
  return ((V & 4294901760) !== 0 ? (V &= 4294901760, 16) : 0) | ((V & 4278255360) !== 0 ? (V &= 4278255360, 8) : 0) | ((V & 4042322160) !== 0 ? (V &= 4042322160, 4) : 0) | ((V & 3435973836) !== 0 ? (V &= 3435973836, 2) : 0) | (V & 2863311530) !== 0;
}
function __fft(PF, pall, bits4, offset, step) {
  const n = 1 << bits4;
  if (n == 1) {
    return [pall[offset]];
  } else if (n == 2) {
    return [
      PF.G.add(pall[offset], pall[offset + step]),
      PF.G.sub(pall[offset], pall[offset + step])
    ];
  }
  const ndiv2 = n >> 1;
  const p1 = __fft(PF, pall, bits4 - 1, offset, step * 2);
  const p2 = __fft(PF, pall, bits4 - 1, offset + step, step * 2);
  const out = new Array(n);
  for (let i = 0; i < ndiv2; i++) {
    out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits4][i]));
    out[i + ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits4][i]));
  }
  return out;
}

// ../../node_modules/ffjavascript/src/f1field.js
var ZqField3 = class {
  constructor(p) {
    this.type = "F1";
    this.one = BigInt(1);
    this.zero = BigInt(0);
    this.p = BigInt(p);
    this.m = 1;
    this.negone = this.p - this.one;
    this.two = BigInt(2);
    this.half = this.p >> this.one;
    this.bitLength = bitLength4(this.p);
    this.mask = (this.one << BigInt(this.bitLength)) - this.one;
    this.n64 = Math.floor((this.bitLength - 1) / 64) + 1;
    this.n32 = this.n64 * 2;
    this.n8 = this.n64 * 8;
    this.R = this.e(this.one << BigInt(this.n64 * 64));
    this.Ri = this.inv(this.R);
    const e4 = this.negone >> this.one;
    this.nqr = this.two;
    let r = this.pow(this.nqr, e4);
    while (!this.eq(r, this.negone)) {
      this.nqr = this.nqr + this.one;
      r = this.pow(this.nqr, e4);
    }
    this.s = 0;
    this.t = this.negone;
    while ((this.t & this.one) == this.zero) {
      this.s = this.s + 1;
      this.t = this.t >> this.one;
    }
    this.nqr_to_t = this.pow(this.nqr, this.t);
    buildSqrt3(this);
    this.FFT = new FFT3(this, this, this.mul.bind(this));
    this.fft = this.FFT.fft.bind(this.FFT);
    this.ifft = this.FFT.ifft.bind(this.FFT);
    this.w = this.FFT.w;
    this.wi = this.FFT.wi;
    this.shift = this.square(this.nqr);
    this.k = this.exp(this.nqr, 2 ** this.s);
  }
  e(a, b) {
    let res;
    if (!b) {
      res = BigInt(a);
    } else if (b == 16) {
      res = BigInt("0x" + a);
    }
    if (res < 0) {
      let nres = -res;
      if (nres >= this.p)
        nres = nres % this.p;
      return this.p - nres;
    } else {
      return res >= this.p ? res % this.p : res;
    }
  }
  add(a, b) {
    const res = a + b;
    return res >= this.p ? res - this.p : res;
  }
  sub(a, b) {
    return a >= b ? a - b : this.p - b + a;
  }
  neg(a) {
    return a ? this.p - a : a;
  }
  mul(a, b) {
    return a * b % this.p;
  }
  mulScalar(base, s) {
    return base * this.e(s) % this.p;
  }
  square(a) {
    return a * a % this.p;
  }
  eq(a, b) {
    return a == b;
  }
  neq(a, b) {
    return a != b;
  }
  lt(a, b) {
    const aa = a > this.half ? a - this.p : a;
    const bb = b > this.half ? b - this.p : b;
    return aa < bb;
  }
  gt(a, b) {
    const aa = a > this.half ? a - this.p : a;
    const bb = b > this.half ? b - this.p : b;
    return aa > bb;
  }
  leq(a, b) {
    const aa = a > this.half ? a - this.p : a;
    const bb = b > this.half ? b - this.p : b;
    return aa <= bb;
  }
  geq(a, b) {
    const aa = a > this.half ? a - this.p : a;
    const bb = b > this.half ? b - this.p : b;
    return aa >= bb;
  }
  div(a, b) {
    return this.mul(a, this.inv(b));
  }
  idiv(a, b) {
    if (!b)
      throw new Error("Division by zero");
    return a / b;
  }
  inv(a) {
    if (!a)
      throw new Error("Division by zero");
    let t = this.zero;
    let r = this.p;
    let newt = this.one;
    let newr = a % this.p;
    while (newr) {
      let q = r / newr;
      [t, newt] = [newt, t - q * newt];
      [r, newr] = [newr, r - q * newr];
    }
    if (t < this.zero)
      t += this.p;
    return t;
  }
  mod(a, b) {
    return a % b;
  }
  pow(b, e4) {
    return exp6(this, b, e4);
  }
  exp(b, e4) {
    return exp6(this, b, e4);
  }
  band(a, b) {
    const res = a & b & this.mask;
    return res >= this.p ? res - this.p : res;
  }
  bor(a, b) {
    const res = (a | b) & this.mask;
    return res >= this.p ? res - this.p : res;
  }
  bxor(a, b) {
    const res = (a ^ b) & this.mask;
    return res >= this.p ? res - this.p : res;
  }
  bnot(a) {
    const res = a ^ this.mask;
    return res >= this.p ? res - this.p : res;
  }
  shl(a, b) {
    if (Number(b) < this.bitLength) {
      const res = a << b & this.mask;
      return res >= this.p ? res - this.p : res;
    } else {
      const nb = this.p - b;
      if (Number(nb) < this.bitLength) {
        return a >> nb;
      } else {
        return this.zero;
      }
    }
  }
  shr(a, b) {
    if (Number(b) < this.bitLength) {
      return a >> b;
    } else {
      const nb = this.p - b;
      if (Number(nb) < this.bitLength) {
        const res = a << nb & this.mask;
        return res >= this.p ? res - this.p : res;
      } else {
        return 0;
      }
    }
  }
  land(a, b) {
    return a && b ? this.one : this.zero;
  }
  lor(a, b) {
    return a || b ? this.one : this.zero;
  }
  lnot(a) {
    return a ? this.zero : this.one;
  }
  sqrt_old(n) {
    if (n == this.zero)
      return this.zero;
    const res = this.pow(n, this.negone >> this.one);
    if (res != this.one)
      return null;
    let m = this.s;
    let c = this.nqr_to_t;
    let t = this.pow(n, this.t);
    let r = this.pow(n, this.add(this.t, this.one) >> this.one);
    while (t != this.one) {
      let sq = this.square(t);
      let i = 1;
      while (sq != this.one) {
        i++;
        sq = this.square(sq);
      }
      let b = c;
      for (let j = 0; j < m - i - 1; j++)
        b = this.square(b);
      m = i;
      c = this.square(b);
      t = this.mul(t, c);
      r = this.mul(r, b);
    }
    if (r > this.p >> this.one) {
      r = this.neg(r);
    }
    return r;
  }
  normalize(a, b) {
    a = BigInt(a, b);
    if (a < 0) {
      let na = -a;
      if (na >= this.p)
        na = na % this.p;
      return this.p - na;
    } else {
      return a >= this.p ? a % this.p : a;
    }
  }
  random() {
    const nBytes = this.bitLength * 2 / 8;
    let res = this.zero;
    for (let i = 0; i < nBytes; i++) {
      res = (res << BigInt(8)) + BigInt(getRandomBytes3(1)[0]);
    }
    return res % this.p;
  }
  toString(a, base) {
    base = base || 10;
    let vs;
    if (a > this.half && base == 10) {
      const v = this.p - a;
      vs = "-" + v.toString(base);
    } else {
      vs = a.toString(base);
    }
    return vs;
  }
  isZero(a) {
    return a == this.zero;
  }
  fromRng(rng2) {
    let v;
    do {
      v = this.zero;
      for (let i = 0; i < this.n64; i++) {
        v += rng2.nextU64() << BigInt(64 * i);
      }
      v &= this.mask;
    } while (v >= this.p);
    v = v * this.Ri % this.p;
    return v;
  }
  fft(a) {
    return this.FFT.fft(a);
  }
  ifft(a) {
    return this.FFT.ifft(a);
  }
  // Returns a buffer with Little Endian Representation
  toRprLE(buff, o, e4) {
    toRprLE3(buff, o, e4, this.n64 * 8);
  }
  // Returns a buffer with Big Endian Representation
  toRprBE(buff, o, e4) {
    toRprBE3(buff, o, e4, this.n64 * 8);
  }
  // Returns a buffer with Big Endian Montgomery Representation
  toRprBEM(buff, o, e4) {
    return this.toRprBE(buff, o, this.mul(this.R, e4));
  }
  toRprLEM(buff, o, e4) {
    return this.toRprLE(buff, o, this.mul(this.R, e4));
  }
  // Pases a buffer with Little Endian Representation
  fromRprLE(buff, o) {
    return fromRprLE3(buff, o, this.n8);
  }
  // Pases a buffer with Big Endian Representation
  fromRprBE(buff, o) {
    return fromRprBE3(buff, o, this.n8);
  }
  fromRprLEM(buff, o) {
    return this.mul(this.fromRprLE(buff, o), this.Ri);
  }
  fromRprBEM(buff, o) {
    return this.mul(this.fromRprBE(buff, o), this.Ri);
  }
  toObject(a) {
    return a;
  }
};

// ../../node_modules/ffjavascript/src/bn128.js
var import_wasmcurves5 = __toESM(require_wasmcurves3(), 1);

// ../../node_modules/ffjavascript/src/utils.js
var _revTable7 = [];
for (let i = 0; i < 256; i++) {
  _revTable7[i] = _revSlow7(i, 8);
}
function _revSlow7(idx, bits4) {
  let res = 0;
  let a = idx;
  for (let i = 0; i < bits4; i++) {
    res <<= 1;
    res = res | a & 1;
    a >>= 1;
  }
  return res;
}

// ../../node_modules/ffjavascript/src/bigbuffer.js
var PAGE_SIZE4 = 1 << 30;

// ../../node_modules/ffjavascript/src/threadman_thread.js
function thread3(self2) {
  const MAXMEM = 32767;
  let instance;
  let memory;
  if (self2) {
    self2.onmessage = function(e4) {
      let data;
      if (e4.data) {
        data = e4.data;
      } else {
        data = e4;
      }
      if (data[0].cmd == "INIT") {
        init2(data[0]).then(function() {
          self2.postMessage(data.result);
        });
      } else if (data[0].cmd == "TERMINATE") {
        self2.close();
      } else {
        const res = runTask(data);
        self2.postMessage(res);
      }
    };
  }
  async function init2(data) {
    const code = new Uint8Array(data.code);
    const wasmModule = await WebAssembly.compile(code);
    memory = new WebAssembly.Memory({ initial: data.init, maximum: MAXMEM });
    instance = await WebAssembly.instantiate(wasmModule, {
      env: {
        "memory": memory
      }
    });
  }
  function alloc(length) {
    const u322 = new Uint32Array(memory.buffer, 0, 1);
    while (u322[0] & 3)
      u322[0]++;
    const res = u322[0];
    u322[0] += length;
    if (u322[0] + length > memory.buffer.byteLength) {
      const currentPages = memory.buffer.byteLength / 65536;
      let requiredPages = Math.floor((u322[0] + length) / 65536) + 1;
      if (requiredPages > MAXMEM)
        requiredPages = MAXMEM;
      memory.grow(requiredPages - currentPages);
    }
    return res;
  }
  function allocBuffer(buffer) {
    const p = alloc(buffer.byteLength);
    setBuffer(p, buffer);
    return p;
  }
  function getBuffer(pointer, length) {
    const u8 = new Uint8Array(memory.buffer);
    return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);
  }
  function setBuffer(pointer, buffer) {
    const u8 = new Uint8Array(memory.buffer);
    u8.set(new Uint8Array(buffer), pointer);
  }
  function runTask(task) {
    if (task[0].cmd == "INIT") {
      return init2(task[0]);
    }
    const ctx = {
      vars: [],
      out: []
    };
    const u32a = new Uint32Array(memory.buffer, 0, 1);
    const oldAlloc = u32a[0];
    for (let i = 0; i < task.length; i++) {
      switch (task[i].cmd) {
        case "ALLOCSET":
          ctx.vars[task[i].var] = allocBuffer(task[i].buff);
          break;
        case "ALLOC":
          ctx.vars[task[i].var] = alloc(task[i].len);
          break;
        case "SET":
          setBuffer(ctx.vars[task[i].var], task[i].buff);
          break;
        case "CALL": {
          const params = [];
          for (let j = 0; j < task[i].params.length; j++) {
            const p = task[i].params[j];
            if (typeof p.var !== "undefined") {
              params.push(ctx.vars[p.var] + (p.offset || 0));
            } else if (typeof p.val != "undefined") {
              params.push(p.val);
            }
          }
          instance.exports[task[i].fnName](...params);
          break;
        }
        case "GET":
          ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();
          break;
        default:
          throw new Error("Invalid cmd");
      }
    }
    const u32b = new Uint32Array(memory.buffer, 0, 1);
    u32b[0] = oldAlloc;
    return ctx.out;
  }
  return runTask;
}

// ../../node_modules/ffjavascript/src/threadman.js
var import_web_worker3 = __toESM(require_node(), 1);
function stringToBase643(str) {
  if (process.browser) {
    return globalThis.btoa(str);
  } else {
    return Buffer.from(str).toString("base64");
  }
}
var threadSource3 = stringToBase643("(" + thread3.toString() + ")(self)");
var workerSource3 = "data:application/javascript;base64," + threadSource3;

// ../../node_modules/ffjavascript/src/bn128.js
globalThis.curve_bn128 = null;

// ../../node_modules/ffjavascript/src/bls12381.js
var import_wasmcurves6 = __toESM(require_wasmcurves3(), 1);
globalThis.curve_bls12381 = null;

// ../../node_modules/ffjavascript/src/curves.js
var bls12381r4 = e3("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
var bn128r4 = e3("21888242871839275222246405745257275088548364400416034343698204186575808495617");
var bls12381q4 = e3("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
var bn128q4 = e3("21888242871839275222246405745257275088696311157297823662689037894645226208583");

// ../../node_modules/ffjavascript/main.js
var Scalar3 = scalar_exports3;

// ../../node_modules/circom_runtime/js/witness_calculator.js
async function builder(code, options) {
  options = options || {};
  let memorySize = 32767;
  let memory;
  let memoryAllocated = false;
  while (!memoryAllocated) {
    try {
      memory = new WebAssembly.Memory({ initial: memorySize });
      memoryAllocated = true;
    } catch (err) {
      if (memorySize === 1) {
        throw err;
      }
      console.warn("Could not allocate " + memorySize * 1024 * 64 + " bytes. This may cause severe instability. Trying with " + memorySize * 1024 * 64 / 2 + " bytes");
      memorySize = Math.floor(memorySize / 2);
    }
  }
  const wasmModule = await WebAssembly.compile(code);
  let wc;
  let errStr = "";
  let msgStr = "";
  let majorVersion = 1;
  let minorVersion = 0;
  let patchVersion = 0;
  const instance = await WebAssembly.instantiate(wasmModule, {
    env: {
      "memory": memory
    },
    runtime: {
      exceptionHandler: function(code2) {
        let err;
        if (code2 == 1) {
          err = "Signal not found. ";
        } else if (code2 == 2) {
          err = "Too many signals set. ";
        } else if (code2 == 3) {
          err = "Signal already set. ";
        } else if (code2 == 4) {
          err = "Assert Failed. ";
        } else if (code2 == 5) {
          err = "Not enough memory. ";
        } else if (code2 == 6) {
          err = "Input signal array access exceeds the size. ";
        } else {
          err = "Unknown error. ";
        }
        console.error("ERROR: ", code2, errStr);
        throw new Error(err + errStr);
      },
      // A new way of logging messages was added in Circom 2.0.7 that requires 2 new imports
      // `printErrorMessage` and `writeBufferMessage`.
      printErrorMessage: function() {
        errStr += getMessage() + "\n";
      },
      writeBufferMessage: function() {
        const msg = getMessage();
        if (msg === "\n") {
          console.log(msgStr);
          msgStr = "";
        } else {
          if (msgStr !== "") {
            msgStr += " ";
          }
          msgStr += msg;
        }
      },
      showSharedRWMemory: function() {
        const shared_rw_memory_size = instance.exports.getFieldNumLen32();
        const arr = new Uint32Array(shared_rw_memory_size);
        for (let j = 0; j < shared_rw_memory_size; j++) {
          arr[shared_rw_memory_size - 1 - j] = instance.exports.readSharedRWMemory(j);
        }
        if (majorVersion >= 2 && (minorVersion >= 1 || patchVersion >= 7)) {
          if (msgStr !== "") {
            msgStr += " ";
          }
          const msg = Scalar3.fromArray(arr, 4294967296).toString();
          msgStr += msg;
        } else {
          console.log(Scalar3.fromArray(arr, 4294967296));
        }
      },
      error: function(code2, pstr, a, b, c, d) {
        let errStr2;
        if (code2 == 7) {
          errStr2 = p2str(pstr) + " " + wc.getFr(b).toString() + " != " + wc.getFr(c).toString() + " " + p2str(d);
        } else if (code2 == 9) {
          errStr2 = p2str(pstr) + " " + wc.getFr(b).toString() + " " + p2str(c);
        } else if (code2 == 5 && options.sym) {
          errStr2 = p2str(pstr) + " " + options.sym.labelIdx2Name[c];
        } else {
          errStr2 = p2str(pstr) + " " + a + " " + b + " " + c + " " + d;
        }
        console.log("ERROR: ", code2, errStr2);
        throw new Error(errStr2);
      },
      log: function(a) {
        console.log(wc.getFr(a).toString());
      },
      logGetSignal: function(signal, pVal) {
        if (options.logGetSignal) {
          options.logGetSignal(signal, wc.getFr(pVal));
        }
      },
      logSetSignal: function(signal, pVal) {
        if (options.logSetSignal) {
          options.logSetSignal(signal, wc.getFr(pVal));
        }
      },
      logStartComponent: function(cIdx) {
        if (options.logStartComponent) {
          options.logStartComponent(cIdx);
        }
      },
      logFinishComponent: function(cIdx) {
        if (options.logFinishComponent) {
          options.logFinishComponent(cIdx);
        }
      }
    }
  });
  if (typeof instance.exports.getVersion == "function") {
    majorVersion = instance.exports.getVersion();
  }
  if (typeof instance.exports.getMinorVersion == "function") {
    minorVersion = instance.exports.getMinorVersion();
  }
  if (typeof instance.exports.getPatchVersion == "function") {
    patchVersion = instance.exports.getPatchVersion();
  }
  const sanityCheck = options && (options.sanityCheck || options.logGetSignal || options.logSetSignal || options.logStartComponent || options.logFinishComponent);
  if (majorVersion === 2) {
    wc = new WitnessCalculatorCircom2(instance, sanityCheck);
  } else {
    wc = new WitnessCalculatorCircom1(memory, instance, sanityCheck);
  }
  return wc;
  function getMessage() {
    var message = "";
    var c = instance.exports.getMessageChar();
    while (c != 0) {
      message += String.fromCharCode(c);
      c = instance.exports.getMessageChar();
    }
    return message;
  }
  function p2str(p) {
    const i8 = new Uint8Array(memory.buffer);
    const bytes = [];
    for (let i = 0; i8[p + i] > 0; i++)
      bytes.push(i8[p + i]);
    return String.fromCharCode.apply(null, bytes);
  }
}
var WitnessCalculatorCircom1 = class {
  constructor(memory, instance, sanityCheck) {
    this.memory = memory;
    this.i32 = new Uint32Array(memory.buffer);
    this.instance = instance;
    this.n32 = (this.instance.exports.getFrLen() >> 2) - 2;
    const pRawPrime = this.instance.exports.getPRawPrime();
    const arr = new Array(this.n32);
    for (let i = 0; i < this.n32; i++) {
      arr[this.n32 - 1 - i] = this.i32[(pRawPrime >> 2) + i];
    }
    this.prime = Scalar3.fromArray(arr, 4294967296);
    this.Fr = new ZqField3(this.prime);
    this.mask32 = Scalar3.fromString("FFFFFFFF", 16);
    this.NVars = this.instance.exports.getNVars();
    this.n64 = Math.floor((this.Fr.bitLength - 1) / 64) + 1;
    this.R = this.Fr.e(Scalar3.shiftLeft(1, this.n64 * 64));
    this.RInv = this.Fr.inv(this.R);
    this.sanityCheck = sanityCheck;
  }
  circom_version() {
    return 1;
  }
  async _doCalculateWitness(input, sanityCheck) {
    this.instance.exports.init(this.sanityCheck || sanityCheck ? 1 : 0);
    const pSigOffset = this.allocInt();
    const pFr = this.allocFr();
    const keys = Object.keys(input);
    keys.forEach((k) => {
      const h = fnvHash(k);
      const hMSB = parseInt(h.slice(0, 8), 16);
      const hLSB = parseInt(h.slice(8, 16), 16);
      try {
        this.instance.exports.getSignalOffset32(pSigOffset, 0, hMSB, hLSB);
      } catch (err) {
        throw new Error(`Signal ${k} is not an input of the circuit.`);
      }
      const sigOffset = this.getInt(pSigOffset);
      const fArr = flatArray(input[k]);
      for (let i = 0; i < fArr.length; i++) {
        this.setFr(pFr, fArr[i]);
        this.instance.exports.setSignal(0, 0, sigOffset + i, pFr);
      }
    });
  }
  async calculateWitness(input, sanityCheck) {
    const self2 = this;
    const old0 = self2.i32[0];
    const w = [];
    await self2._doCalculateWitness(input, sanityCheck);
    for (let i = 0; i < self2.NVars; i++) {
      const pWitness = self2.instance.exports.getPWitness(i);
      w.push(self2.getFr(pWitness));
    }
    self2.i32[0] = old0;
    return w;
  }
  async calculateBinWitness(input, sanityCheck) {
    const self2 = this;
    const old0 = self2.i32[0];
    await self2._doCalculateWitness(input, sanityCheck);
    const pWitnessBuffer = self2.instance.exports.getWitnessBuffer();
    self2.i32[0] = old0;
    const buff = self2.memory.buffer.slice(pWitnessBuffer, pWitnessBuffer + self2.NVars * self2.n64 * 8);
    return new Uint8Array(buff);
  }
  allocInt() {
    const p = this.i32[0];
    this.i32[0] = p + 8;
    return p;
  }
  allocFr() {
    const p = this.i32[0];
    this.i32[0] = p + this.n32 * 4 + 8;
    return p;
  }
  getInt(p) {
    return this.i32[p >> 2];
  }
  setInt(p, v) {
    this.i32[p >> 2] = v;
  }
  getFr(p) {
    const self2 = this;
    const idx = p >> 2;
    if (self2.i32[idx + 1] & 2147483648) {
      const arr = new Array(self2.n32);
      for (let i = 0; i < self2.n32; i++) {
        arr[self2.n32 - 1 - i] = self2.i32[idx + 2 + i];
      }
      const res = self2.Fr.e(Scalar3.fromArray(arr, 4294967296));
      if (self2.i32[idx + 1] & 1073741824) {
        return fromMontgomery(res);
      } else {
        return res;
      }
    } else {
      if (self2.i32[idx] & 2147483648) {
        return self2.Fr.e(self2.i32[idx] - 4294967296);
      } else {
        return self2.Fr.e(self2.i32[idx]);
      }
    }
    function fromMontgomery(n) {
      return self2.Fr.mul(self2.RInv, n);
    }
  }
  setFr(p, v) {
    const self2 = this;
    v = self2.Fr.e(v);
    const minShort = self2.Fr.neg(self2.Fr.e("80000000", 16));
    const maxShort = self2.Fr.e("7FFFFFFF", 16);
    if (self2.Fr.geq(v, minShort) && self2.Fr.leq(v, maxShort)) {
      let a;
      if (self2.Fr.geq(v, self2.Fr.zero)) {
        a = Scalar3.toNumber(v);
      } else {
        a = Scalar3.toNumber(self2.Fr.sub(v, minShort));
        a = a - 2147483648;
        a = 4294967296 + a;
      }
      self2.i32[p >> 2] = a;
      self2.i32[(p >> 2) + 1] = 0;
      return;
    }
    self2.i32[p >> 2] = 0;
    self2.i32[(p >> 2) + 1] = 2147483648;
    const arr = Scalar3.toArray(v, 4294967296);
    for (let i = 0; i < self2.n32; i++) {
      const idx = arr.length - 1 - i;
      if (idx >= 0) {
        self2.i32[(p >> 2) + 2 + i] = arr[idx];
      } else {
        self2.i32[(p >> 2) + 2 + i] = 0;
      }
    }
  }
};
var WitnessCalculatorCircom2 = class {
  constructor(instance, sanityCheck) {
    this.instance = instance;
    this.version = this.instance.exports.getVersion();
    this.n32 = this.instance.exports.getFieldNumLen32();
    this.instance.exports.getRawPrime();
    const arr = new Array(this.n32);
    for (let i = 0; i < this.n32; i++) {
      arr[this.n32 - 1 - i] = this.instance.exports.readSharedRWMemory(i);
    }
    this.prime = Scalar3.fromArray(arr, 4294967296);
    this.witnessSize = this.instance.exports.getWitnessSize();
    this.sanityCheck = sanityCheck;
  }
  circom_version() {
    return this.instance.exports.getVersion();
  }
  async _doCalculateWitness(input, sanityCheck) {
    this.instance.exports.init(this.sanityCheck || sanityCheck ? 1 : 0);
    const keys = Object.keys(input);
    var input_counter = 0;
    keys.forEach((k) => {
      const h = fnvHash(k);
      const hMSB = parseInt(h.slice(0, 8), 16);
      const hLSB = parseInt(h.slice(8, 16), 16);
      const fArr = flatArray(input[k]);
      for (let i = 0; i < fArr.length; i++) {
        const arrFr = toArray32(fArr[i], this.n32);
        for (let j = 0; j < this.n32; j++) {
          this.instance.exports.writeSharedRWMemory(j, arrFr[this.n32 - 1 - j]);
        }
        try {
          this.instance.exports.setInputSignal(hMSB, hLSB, i);
          input_counter++;
        } catch (err) {
          throw new Error(err);
        }
      }
    });
    if (input_counter < this.instance.exports.getInputSize()) {
      throw new Error(`Not all inputs have been set. Only ${input_counter} out of ${this.instance.exports.getInputSize()}`);
    }
  }
  async calculateWitness(input, sanityCheck) {
    const w = [];
    await this._doCalculateWitness(input, sanityCheck);
    for (let i = 0; i < this.witnessSize; i++) {
      this.instance.exports.getWitness(i);
      const arr = new Uint32Array(this.n32);
      for (let j = 0; j < this.n32; j++) {
        arr[this.n32 - 1 - j] = this.instance.exports.readSharedRWMemory(j);
      }
      w.push(Scalar3.fromArray(arr, 4294967296));
    }
    return w;
  }
  async calculateWTNSBin(input, sanityCheck) {
    const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);
    const buff = new Uint8Array(buff32.buffer);
    await this._doCalculateWitness(input, sanityCheck);
    buff[0] = "w".charCodeAt(0);
    buff[1] = "t".charCodeAt(0);
    buff[2] = "n".charCodeAt(0);
    buff[3] = "s".charCodeAt(0);
    buff32[1] = 2;
    buff32[2] = 2;
    buff32[3] = 1;
    const n8 = this.n32 * 4;
    const idSection1length = 8 + n8;
    const idSection1lengthHex = idSection1length.toString(16);
    buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);
    buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);
    buff32[6] = n8;
    this.instance.exports.getRawPrime();
    var pos = 7;
    for (let j = 0; j < this.n32; j++) {
      buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);
    }
    pos += this.n32;
    buff32[pos] = this.witnessSize;
    pos++;
    buff32[pos] = 2;
    pos++;
    const idSection2length = n8 * this.witnessSize;
    const idSection2lengthHex = idSection2length.toString(16);
    buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);
    buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);
    pos += 2;
    for (let i = 0; i < this.witnessSize; i++) {
      this.instance.exports.getWitness(i);
      for (let j = 0; j < this.n32; j++) {
        buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);
      }
      pos += this.n32;
    }
    return buff;
  }
};

// ../../node_modules/snarkjs/src/wtns_calculate.js
var { unstringifyBigInts: unstringifyBigInts2 } = utils;
async function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {
  const input = unstringifyBigInts2(_input);
  const fdWasm = await readExisting3(wasmFileName);
  const wasm = await fdWasm.read(fdWasm.totalSize);
  await fdWasm.close();
  const wc = await builder(wasm);
  if (wc.circom_version() == 1) {
    const w = await wc.calculateBinWitness(input);
    const fdWtns = await createBinFile(wtnsFileName, "wtns", 2, 2);
    await writeBin(fdWtns, w, wc.prime);
    await fdWtns.close();
  } else {
    const fdWtns = await createOverride(wtnsFileName);
    const w = await wc.calculateWTNSBin(input);
    await fdWtns.write(w);
    await fdWtns.close();
  }
}

// ../../node_modules/snarkjs/src/groth16_fullprove.js
var { unstringifyBigInts: unstringifyBigInts3 } = utils;
async function groth16FullProve(_input, wasmFile, zkeyFileName, logger) {
  const input = unstringifyBigInts3(_input);
  const wtns = {
    type: "mem"
  };
  await wtnsCalculate(input, wasmFile, wtns);
  return await groth16Prove(zkeyFileName, wtns, logger);
}

// ../../node_modules/snarkjs/src/groth16_verify.js
var { unstringifyBigInts: unstringifyBigInts4 } = utils;
async function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {
  const vk_verifier = unstringifyBigInts4(_vk_verifier);
  const proof = unstringifyBigInts4(_proof);
  const publicSignals = unstringifyBigInts4(_publicSignals);
  const curve2 = await getCurveFromName3(vk_verifier.curve);
  const IC0 = curve2.G1.fromObject(vk_verifier.IC[0]);
  const IC = new Uint8Array(curve2.G1.F.n8 * 2 * publicSignals.length);
  const w = new Uint8Array(curve2.Fr.n8 * publicSignals.length);
  if (!publicInputsAreValid(curve2, publicSignals)) {
    if (logger)
      logger.error("Public inputs are not valid.");
    return false;
  }
  for (let i = 0; i < publicSignals.length; i++) {
    const buffP = curve2.G1.fromObject(vk_verifier.IC[i + 1]);
    IC.set(buffP, i * curve2.G1.F.n8 * 2);
    Scalar2.toRprLE(w, curve2.Fr.n8 * i, publicSignals[i], curve2.Fr.n8);
  }
  let cpub = await curve2.G1.multiExpAffine(IC, w);
  cpub = curve2.G1.add(cpub, IC0);
  const pi_a = curve2.G1.fromObject(proof.pi_a);
  const pi_b = curve2.G2.fromObject(proof.pi_b);
  const pi_c = curve2.G1.fromObject(proof.pi_c);
  if (!isWellConstructed(curve2, { pi_a, pi_b, pi_c })) {
    if (logger)
      logger.error("Proof commitments are not valid.");
    return false;
  }
  const vk_gamma_2 = curve2.G2.fromObject(vk_verifier.vk_gamma_2);
  const vk_delta_2 = curve2.G2.fromObject(vk_verifier.vk_delta_2);
  const vk_alpha_1 = curve2.G1.fromObject(vk_verifier.vk_alpha_1);
  const vk_beta_2 = curve2.G2.fromObject(vk_verifier.vk_beta_2);
  const res = await curve2.pairingEq(
    curve2.G1.neg(pi_a),
    pi_b,
    cpub,
    vk_gamma_2,
    pi_c,
    vk_delta_2,
    vk_alpha_1,
    vk_beta_2
  );
  if (!res) {
    if (logger)
      logger.error("Invalid proof");
    return false;
  }
  if (logger)
    logger.info("OK!");
  return true;
}
function isWellConstructed(curve2, proof) {
  const G1 = curve2.G1;
  const G2 = curve2.G2;
  return G1.isValid(proof.pi_a) && G2.isValid(proof.pi_b) && G1.isValid(proof.pi_c);
}
function publicInputsAreValid(curve2, publicInputs) {
  for (let i = 0; i < publicInputs.length; i++) {
    if (!Scalar2.lt(publicInputs[i], curve2.r)) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/snarkjs/src/groth16_exportsoliditycalldata.js
var { unstringifyBigInts: unstringifyBigInts5 } = utils;
function p256(n) {
  let nstr = n.toString(16);
  while (nstr.length < 64)
    nstr = "0" + nstr;
  nstr = `"0x${nstr}"`;
  return nstr;
}
async function groth16ExportSolidityCallData(_proof, _pub) {
  const proof = unstringifyBigInts5(_proof);
  const pub = unstringifyBigInts5(_pub);
  let inputs = "";
  for (let i = 0; i < pub.length; i++) {
    if (inputs != "")
      inputs = inputs + ",";
    inputs = inputs + p256(pub[i]);
  }
  let S;
  S = `[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],[${inputs}]`;
  return S;
}

// ../../node_modules/snarkjs/src/powersoftau_utils.js
var import_blake2b_wasm3 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/keypair.js
var import_blake2b_wasm2 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/powersoftau_new.js
var import_blake2b_wasm4 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/powersoftau_export_challenge.js
var import_blake2b_wasm5 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/powersoftau_import.js
var import_blake2b_wasm6 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/powersoftau_verify.js
var import_blake2b_wasm7 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/powersoftau_challenge_contribute.js
var import_blake2b_wasm8 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/powersoftau_beacon.js
var import_blake2b_wasm9 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/powersoftau_contribute.js
var import_blake2b_wasm10 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/r1cs_info.js
var bls12381r5 = Scalar2.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
var bn128r5 = Scalar2.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");

// ../../node_modules/snarkjs/src/wtns_debug.js
var { unstringifyBigInts: unstringifyBigInts6 } = utils;

// ../../node_modules/snarkjs/src/zkey_new.js
var import_blake2b_wasm11 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/zkey_verify_frominit.js
var import_blake2b_wasm12 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/zkey_contribute.js
var import_blake2b_wasm13 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/zkey_beacon.js
var import_blake2b_wasm14 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/zkey_bellman_contribute.js
var import_blake2b_wasm15 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/zkey_export_verificationkey.js
var { stringifyBigInts: stringifyBigInts3 } = utils;

// ../../node_modules/snarkjs/src/zkey_export_solidityverifier.js
var import_ejs2 = __toESM(require_ejs(), 1);

// ../../node_modules/snarkjs/src/fflonk_export_solidity_verifier.js
var import_ejs = __toESM(require_ejs(), 1);
var { unstringifyBigInts: unstringifyBigInts7, stringifyBigInts: stringifyBigInts4 } = utils;

// ../../node_modules/snarkjs/src/plonk_setup.js
var import_blake2b_wasm16 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/snarkjs/src/Keccak256Transcript.js
var import_js_sha3 = __toESM(require_sha3(), 1);
var { keccak256 } = import_js_sha3.default;

// ../../node_modules/snarkjs/src/plonk_prove.js
var { stringifyBigInts: stringifyBigInts5 } = utils;

// ../../node_modules/snarkjs/src/plonk_fullprove.js
var { unstringifyBigInts: unstringifyBigInts8 } = utils;

// ../../node_modules/snarkjs/src/plonk_verify.js
var { unstringifyBigInts: unstringifyBigInts9 } = utils;

// ../../node_modules/snarkjs/src/plonk_exportsoliditycalldata.js
var { unstringifyBigInts: unstringifyBigInts10 } = utils;

// ../../node_modules/snarkjs/src/fflonk_prove.js
var { stringifyBigInts: stringifyBigInts6 } = utils;

// ../../node_modules/snarkjs/src/fflonk_full_prove.js
var { unstringifyBigInts: unstringifyBigInts11 } = utils;

// ../../node_modules/snarkjs/src/fflonk_verify.js
var { unstringifyBigInts: unstringifyBigInts12 } = utils;

// ../../node_modules/snarkjs/src/fflonk_export_calldata.js
var { unstringifyBigInts: unstringifyBigInts13 } = utils;

// ../pcd-country-identity/src/utils.ts
function splitToWords(number, wordsize, numberElement) {
  let t = number;
  const words = [];
  for (let i = BigInt(0); i < numberElement; ++i) {
    const baseTwo = BigInt(2);
    words.push(`${t % BigInt(Math.pow(Number(baseTwo), Number(wordsize)))}`);
    t = BigInt(t / BigInt(Math.pow(Number(BigInt(2)), Number(wordsize))));
  }
  if (!(t == BigInt(0))) {
    throw `Number ${number} does not fit in ${(wordsize * numberElement).toString()} bits`;
  }
  return words;
}

// ../pcd-country-identity/src/pcd.ts
var import_json_bigint = __toESM(require_json_bigint());

// ../pcd-country-identity/src/CardBody.tsx
var import_styled_components6 = __toESM(require("styled-components"));
var import_passport_ui = __toESM(require_dist());
var import_jsx_runtime6 = require("react/jsx-runtime");
var Container = import_styled_components6.default.div`
  padding: 16px;
  overflow: hidden;
  width: 100%;
`;

// ../pcd-country-identity/src/prover.ts
var import_valid_url = __toESM(require_valid_url());

// ../../node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// ../../node_modules/axios/lib/utils.js
var { toString: toString4 } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString4.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray4 = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray4,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// ../../node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// ../../node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

// ../../node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// ../../node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString5(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// ../../node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// ../../node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// ../../node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// ../../node_modules/axios/lib/platform/node/classes/URLSearchParams.js
var import_url = __toESM(require("url"), 1);
var URLSearchParams_default = import_url.default.URLSearchParams;

// ../../node_modules/axios/lib/platform/node/index.js
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  protocols: ["http", "https", "file", "data"]
};

// ../../node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new node_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (node_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// ../../node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// ../../node_modules/axios/lib/defaults/index.js
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e4) {
      if (e4.name !== "SyntaxError") {
        throw e4;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e4) {
        if (strictJSONParsing) {
          if (e4.name === "SyntaxError") {
            throw AxiosError_default.from(e4, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e4;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: node_default.classes.FormData,
    Blob: node_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils_default.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils_default.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_default = defaults;

// ../../node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// ../../node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.freezeMethods(AxiosHeaders.prototype);
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// ../../node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// ../../node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// ../../node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// ../../node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// ../../node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// ../../node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// ../../node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// ../../node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
var import_http = __toESM(require("http"), 1);
var import_https = __toESM(require("https"), 1);
var import_util4 = __toESM(require("util"), 1);
var import_follow_redirects = __toESM(require_follow_redirects(), 1);
var import_zlib = __toESM(require("zlib"), 1);

// ../../node_modules/axios/lib/env/data.js
var VERSION = "1.4.0";

// ../../node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// ../../node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || node_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// ../../node_modules/axios/lib/adapters/http.js
var import_stream4 = __toESM(require("stream"), 1);

// ../../node_modules/axios/lib/helpers/AxiosTransformStream.js
var import_stream = __toESM(require("stream"), 1);

// ../../node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  const threshold = 1e3 / freq;
  let timer = null;
  return function throttled(force, args) {
    const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now;
      return fn.apply(null, args);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, args);
      }, threshold - (now - timestamp));
    }
  };
}
var throttle_default = throttle;

// ../../node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// ../../node_modules/axios/lib/helpers/AxiosTransformStream.js
var kInternals = Symbol("internals");
var AxiosTransformStream = class extends import_stream.default.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const self2 = this;
    const internals = this[kInternals] = {
      length: options.length,
      timeWindow: options.timeWindow,
      ticksRate: options.ticksRate,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    const _speedometer = speedometer_default(internals.ticksRate * options.samplesCount, internals.timeWindow);
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
    let bytesNotified = 0;
    internals.updateProgress = throttle_default(function throttledHandler() {
      const totalBytes = internals.length;
      const bytesTransferred = internals.bytesSeen;
      const progressBytes = bytesTransferred - bytesNotified;
      if (!progressBytes || self2.destroyed)
        return;
      const rate = _speedometer(progressBytes);
      bytesNotified = bytesTransferred;
      process.nextTick(() => {
        self2.emit("progress", {
          "loaded": bytesTransferred,
          "total": totalBytes,
          "progress": totalBytes ? bytesTransferred / totalBytes : void 0,
          "bytes": progressBytes,
          "rate": rate ? rate : void 0,
          "estimated": rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : void 0
        });
      });
    }, internals.ticksRate);
    const onFinish = () => {
      internals.updateProgress(true);
    };
    this.once("end", onFinish);
    this.once("error", onFinish);
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const self2 = this;
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    function pushChunk(_chunk, _callback) {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      if (internals.isCaptured) {
        internals.updateProgress();
      }
      if (self2.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    }
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
  setLength(length) {
    this[kInternals].length = +length;
    return this;
  }
};
var AxiosTransformStream_default = AxiosTransformStream;

// ../../node_modules/axios/lib/adapters/http.js
var import_events = __toESM(require("events"), 1);

// ../../node_modules/axios/lib/helpers/formDataToStream.js
var import_util3 = require("util");
var import_stream2 = require("stream");

// ../../node_modules/axios/lib/helpers/readBlob.js
var { asyncIterator } = Symbol;
var readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
var readBlob_default = readBlob;

// ../../node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = utils_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder = new import_util3.TextEncoder();
var CRLF = "\r\n";
var CRLF_BYTES = textEncoder.encode(CRLF);
var CRLF_BYTES_COUNT = 2;
var FormDataPart = class {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
};
var formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + utils_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return import_stream2.Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
var formDataToStream_default = formDataToStream;

// ../../node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
var import_stream3 = __toESM(require("stream"), 1);
var ZlibHeaderTransformStream = class extends import_stream3.default.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
};
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// ../../node_modules/axios/lib/helpers/callbackify.js
var callbackify = (fn, reducer) => {
  return utils_default.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
var callbackify_default = callbackify;

// ../../node_modules/axios/lib/adapters/http.js
var zlibOptions = {
  flush: import_zlib.default.constants.Z_SYNC_FLUSH,
  finishFlush: import_zlib.default.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(import_zlib.default.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = node_default.protocols.map((protocol) => {
  return protocol + ":";
});
function dispatchBeforeRedirect(options) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = (0, import_proxy_from_env.getProxyForUrl)(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone)
        return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
var http_default = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let { data, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup && utils_default.isAsyncFn(lookup)) {
      lookup = callbackify_default(lookup, (entry) => {
        if (utils_default.isString(entry)) {
          entry = [entry, entry.indexOf(".") < 0 ? 6 : 4];
        } else if (!utils_default.isArray(entry)) {
          throw new TypeError("lookup async function must return an array [ip: string, family: number]]");
        }
        return entry;
      });
    }
    const emitter = new import_events.default();
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    const parsed = new URL(fullPath, "http://localhost");
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = import_stream4.default.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default(
        "Unsupported protocol " + protocol,
        AxiosError_default.ERR_BAD_REQUEST,
        config
      ));
    }
    const headers = AxiosHeaders_default.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const onDownloadProgress = config.onDownloadProgress;
    const onUploadProgress = config.onUploadProgress;
    const maxRate = config.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils_default.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream_default(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await import_util4.default.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e4) {
        }
      }
    } else if (utils_default.isBlob(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = import_stream4.default.Readable.from(readBlob_default(data));
    } else if (data && !utils_default.isStream(data)) {
      if (Buffer.isBuffer(data)) {
      } else if (utils_default.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils_default.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError_default(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
      }
      headers.setContentLength(data.length, false);
      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError_default(
          "Request body larger than maxBodyLength limit",
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data)) {
        data = import_stream4.default.Readable.from(data, { objectMode: false });
      }
      data = import_stream4.default.pipeline([data, new AxiosTransformStream_default({
        length: contentLength,
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data.on("progress", (progress) => {
        onUploadProgress(Object.assign(progress, {
          upload: true
        }));
      });
    }
    let auth = void 0;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path;
    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      lookup,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? import_https.default : import_http.default;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed)
        return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress) {
        const transformStream = new AxiosTransformStream_default({
          length: utils_default.toFiniteNumber(responseLength),
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", (progress) => {
          onDownloadProgress(Object.assign(progress, {
            download: true
          }));
        });
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch (res.headers["content-encoding"]) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(import_zlib.default.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream_default());
            streams.push(import_zlib.default.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(import_zlib.default.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? import_stream4.default.pipeline(streams, utils_default.noop) : streams[0];
      const offListeners = import_stream4.default.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default(
              "maxContentLength size of " + config.maxContentLength + " exceeded",
              AxiosError_default.ERR_BAD_RESPONSE,
              config,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default(
            "maxContentLength size of " + config.maxContentLength + " exceeded",
            AxiosError_default.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed)
            return;
          reject(AxiosError_default.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            reject(AxiosError_default.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (isNaN(timeout)) {
        reject(new AxiosError_default(
          "error trying to parse `config.timeout` to int",
          AxiosError_default.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone)
          return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config.transitional || transitional_default;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError_default("Request stream has been aborted", config, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

// ../../node_modules/axios/lib/helpers/cookies.js
var cookies_default = node_default.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write2(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils_default.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils_default.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils_default.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write2() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);

// ../../node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = node_default.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url2) {
      let href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// ../../node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e4) => {
    const loaded = e4.loaded;
    const total = e4.lengthComputable ? e4.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e4
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils_default.isFormData(requestData)) {
      if (node_default.isStandardBrowserEnv || node_default.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType("multipart/form-data;", false);
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (node_default.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin_default(fullPath)) && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && node_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// ../../node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e4) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if (adapter = utils_default.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError_default(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils_default.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils_default.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};

// ../../node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// ../../node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// ../../node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// ../../node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    contextHeaders && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// ../../node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// ../../node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// ../../node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// ../../node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// ../../node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// ../../node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  mergeConfig: mergeConfig2
} = axios_default;

// ../pcd-country-identity/src/prover.ts
async function fetchKey(keyURL) {
  if ((0, import_valid_url.isWebUri)(keyURL)) {
    const keyData = await (await axios_default.get(keyURL, {
      responseType: "arraybuffer"
    })).data;
    return keyData;
  }
  return keyURL;
}
var KeyPath = class {
  keyURL;
  isLocation;
  constructor(keyURL, isLocation) {
    this.keyURL = keyURL;
    this.isLocation = isLocation;
  }
  async getKey() {
    if (this.isLocation)
      return this.keyURL;
    return await fetchKey(this.keyURL);
  }
};
var BackendProver = class {
  wasm;
  zkey;
  constructor(wasmURL, zkey) {
    this.wasm = new KeyPath(wasmURL, false);
    this.zkey = new KeyPath(zkey, false);
  }
  async proving(witness) {
    if (!witness.modulus.value) {
      throw new Error("Cannot make proof: missing modulus");
    }
    if (!witness.signature.value) {
      throw new Error("Cannot make proof: missing signature");
    }
    if (!witness.base_message.value) {
      throw new Error("Cannot make proof: missing message");
    }
    const input = {
      signature: splitToWords(
        BigInt(witness.signature.value),
        BigInt(64),
        BigInt(32)
      ),
      modulus: splitToWords(
        BigInt(witness.modulus.value),
        BigInt(64),
        BigInt(32)
      ),
      base_message: splitToWords(
        BigInt(witness.base_message.value),
        BigInt(64),
        BigInt(32)
      )
    };
    const { proof } = await groth16_exports.fullProve(
      input,
      await this.wasm.getKey(),
      await this.zkey.getKey()
    );
    return {
      modulus: witness.modulus.value,
      proof
    };
  }
};
var WebProver = class {
  wasm;
  zkey;
  constructor(wasmURL, zkey) {
    this.wasm = new KeyPath(wasmURL, false);
    this.zkey = new KeyPath(zkey, false);
  }
  async proving(witness) {
    const wasmBuffer = await this.wasm.getKey();
    const zkeyBuffer = await this.zkey.getKey();
    if (!witness.modulus.value) {
      throw new Error("Cannot make proof: missing mod");
    }
    if (!witness.signature.value) {
      throw new Error("Cannot make proof: missing signature");
    }
    if (!witness.base_message.value) {
      throw new Error("Cannot make proof: missing message");
    }
    const input = {
      signature: splitToWords(
        BigInt(witness.signature.value),
        BigInt(64),
        BigInt(32)
      ),
      modulus: splitToWords(
        BigInt(witness.modulus.value),
        BigInt(64),
        BigInt(32)
      ),
      base_message: splitToWords(
        BigInt(witness.base_message.value),
        BigInt(64),
        BigInt(32)
      )
    };
    const { proof } = await groth16_exports.fullProve(
      input,
      new Uint8Array(wasmBuffer),
      new Uint8Array(zkeyBuffer)
    );
    return {
      modulus: witness.modulus.value,
      proof
    };
  }
};

// ../pcd-country-identity/src/pcd.ts
var IdentityPCD = class {
  type = IdentityPCDTypeName;
  claim;
  proof;
  id;
  constructor(id, claim, proof) {
    this.id = id;
    this.claim = claim;
    this.proof = proof;
  }
};
var initArgs = void 0;
async function init(args) {
  initArgs = args;
}
async function prove(args) {
  if (!initArgs) {
    throw new Error(
      "cannot make semaphore signature proof: init has not been called yet"
    );
  }
  if (!args.modulus.value) {
    throw new Error("Invalid arguments");
  }
  const id = v4_default();
  const pcdClaim = {
    modulus: args.modulus.value
  };
  let prover;
  if (initArgs.isWebEnv) {
    prover = new WebProver(initArgs.wasmURL, initArgs.zkeyURL);
  } else {
    prover = new BackendProver(initArgs.wasmURL, initArgs.zkeyURL);
  }
  const pcdProof = await prover.proving(args);
  return new IdentityPCD(id, pcdClaim, pcdProof);
}
function serialize(pcd) {
  return Promise.resolve({
    type: IdentityPCDTypeName,
    pcd: (0, import_json_bigint.default)().stringify({
      type: pcd.type,
      id: pcd.id,
      claim: pcd.claim,
      proof: pcd.proof
    })
  });
}

// src/prove.ts
var proveWithWebProver = async (pcdArgs) => {
  const pcdInitArgs = {
    wasmURL: "https://d3dxq5smiosdl4.cloudfront.net/main.wasm",
    zkeyURL: "https://d3dxq5smiosdl4.cloudfront.net/circuit_final.zkey",
    isWebEnv: true
  };
  await init(pcdInitArgs);
  const pcd = await prove(pcdArgs);
  const serialized = await serialize(pcd);
  return { pcd, serialized };
};

// src/provider/countryIdentityProvider.tsx
var import_jsx_runtime7 = require("react/jsx-runtime");
function CountryIdentityProvider(props) {
  const [pcdStr, setPcdStr] = (0, import_react7.useState)("");
  const [pcd, setPcd] = (0, import_react7.useState)("");
  const [state, setState] = (0, import_react7.useState)({
    status: "logged-out"
  });
  (0, import_react7.useEffect)(() => {
    readFromLocalStorage().then(setAndWriteState);
  }, []);
  const setAndWriteState = (newState) => {
    console.log(`[COUNTRY-IDENTITY] new state ${shallowToString(newState)}`);
    setState(newState);
    writeToLocalStorage(newState);
  };
  const startReq = import_react8.default.useCallback(
    (request) => {
      console.log(`[COUNTRY-IDENTITY] startReq ${shallowToString(request)}`);
      setAndWriteState(handleLoginReq(request, setPcdStr, setPcd));
    },
    [setAndWriteState, setPcdStr, setPcd]
  );
  import_react8.default.useEffect(() => {
    if (pcdStr === "" || pcd === "")
      return;
    console.log(`[COUNTRY-IDENTITY] trying to log in with ${pcdStr}`);
    handleLogin(state, pcdStr, pcd).then((newState) => {
      if (newState)
        setAndWriteState(newState);
      else
        console.log(
          `[COUNTRY-IDENTITY] ${state.status}, ignoring pcd: ${pcdStr}`
        );
    }).catch((e4) => {
      console.error(e4);
      console.error(
        `[COUNTRY-IDENTITY] error logging in, ignoring pcd: ${pcdStr}`
      );
    });
  }, [pcdStr]);
  const val = import_react8.default.useMemo(() => ({ state, startReq }), [state]);
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CountryIdentityContext.Provider, { value: val, children: props.children });
}
async function readFromLocalStorage() {
  const json = window.localStorage["countryIdentity"];
  try {
    const state = await parseAndValidate(json);
    console.log(
      `[COUNTRY-IDENTITY] read stored state: ${shallowToString(state)}`
    );
    return state;
  } catch (e4) {
    console.error(`[COUNTRY-IDENTITY] error parsing stored state: ${e4}`);
    return { status: "logged-out" };
  }
}
function writeToLocalStorage(state) {
  console.log(
    `[COUNTRY-IDENTITY] writing to local storage, status ${state.status}`
  );
  window.localStorage["countryIdentity"] = serialize2(state);
}
function serialize2(state) {
  const { status } = state;
  let serState;
  if (status === "logged-in") {
    serState = {
      status,
      serializedPCD: state.serializedPCD,
      pcd: state.pcd
    };
  } else {
    serState = {
      status: "logged-out"
    };
  }
  return JSON.stringify(serState);
}
async function parseAndValidate(json) {
  if (json == null || json.trim() === "") {
    return { status: "logged-out" };
  }
  const stored = JSON.parse(json);
  if (!["logged-out", "logged-in"].includes(stored.status)) {
    throw new Error(`Invalid status ${stored.status}`);
  }
  if (stored.status === "logged-out") {
    return { status: stored.status };
  }
  const { status, serializedPCD, pcd } = stored;
  if (serializedPCD == null) {
    throw new Error(`Missing serialized PCD`);
  } else if (pcd == null) {
    throw new Error(`Missing PCD`);
  } else if (serializedPCD.type !== import_pcd_country_identity.IdentityPCDPackage.name) {
    throw new Error(`Invalid PCD type ${serializedPCD.type}`);
  }
  return {
    status,
    pcd: await import_pcd_country_identity.IdentityPCDPackage.deserialize(serializedPCD.pcd),
    serializedPCD
  };
}
function shallowToString(obj) {
  return JSON.stringify(obj, function(key, val) {
    if (key === "")
      return val;
    if (val == null)
      return null;
    if (typeof val === "bigint")
      return "" + val;
    if (Array.isArray(val))
      return "<array>";
    if (typeof val === "object")
      return "<object>";
    return val;
  });
}
function handleLoginReq(request, setPcdStr, setPcd) {
  const { type } = request;
  console.log("Type of request received: ", type);
  switch (type) {
    case "login":
      try {
        const { args } = request;
        proveWithWebProver(args).then(
          ({
            pcd,
            serialized
          }) => {
            if (typeof setPcdStr === "function") {
              setPcdStr(serialized);
            }
            if (typeof setPcd === "function") {
              setPcd(pcd);
            }
          }
        );
      } catch (error) {
        console.log(error);
      }
      return { status: "logging-in" };
    case "logout":
      return { status: "logged-out" };
    default:
      throw new Error(`Invalid request type ${type}`);
  }
}
async function handleLogin(state, pcdStr, _pcd) {
  if (state.status !== "logging-in") {
    console.log(
      `[COUNTRY-IDENTITY] ignoring message. State != logging-in: ${state}`
    );
    return null;
  }
  console.log(`[COUNTRY-IDENTITY] verifying ${pcdStr.type}`);
  if (!await import_pcd_country_identity.IdentityPCDPackage.verify(_pcd)) {
    throw new Error("Invalid proof");
  }
  return {
    status: "logged-in",
    serializedPCD: pcdStr,
    pcd: _pcd
  };
}

// src/components/Proof.tsx
var import_react9 = require("react");
var import_styled_components7 = __toESM(require("styled-components"));
var import_jsx_runtime8 = require("react/jsx-runtime");
var Container2 = import_styled_components7.default.div`
  font-family: system-ui, sans-serif;
  border: 1px solid black;
  border-radius: 8px;
  padding: 8px;
  margin-bottom: 8px;
`;
var Proof2 = ({ code, label }) => {
  const [collapsed, setCollapsed] = (0, import_react9.useState)(true);
  const toggle = (0, import_react9.useCallback)(() => {
    setCollapsed((collapsed2) => !collapsed2);
  }, []);
  let buttonText = collapsed ? "Expand" : "Collapse";
  if (label !== void 0) {
    buttonText += " " + label;
  }
  if (collapsed) {
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(RevealProofBtn, { onClick: toggle, children: buttonText });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(RevealProofBtn, { onClick: toggle, children: buttonText }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(ProofContainer, { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("pre", { children: code }) })
  ] });
};
var ProofContainer = import_styled_components7.default.div`
  border-radius: 8px;
  border: 1px solid grey;
  overflow-y: scroll;
  max-width: 100%;
  padding: 8px;
`;
var RevealProofBtn = import_styled_components7.default.button`
  padding: 0.5rem 1rem;
  font-size: 1rem;
  cursor: pointer;
  color: #000000;
  font-weight: bold;
  border-radius: 1.3125rem;
  background: #fff;
  box-shadow: 0px 3px 8px 1px rgba(0, 0, 0, 0.25);
  border: none;
  min-width: 12rem;
  min-height: 3rem;
  border-radius: 0.5rem;
`;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CountryIdentityProvider,
  LogInWithCountryIdentity,
  Proof,
  useCountryIdentity
});
/*! Bundled license information:

ejs/lib/ejs.js:
  (**
   * @file Embedded JavaScript templating engine. {@link http://ejs.co}
   * @author Matthew Eernisse <mde@fleegix.org>
   * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
   * @project EJS
   * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
   *)

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
